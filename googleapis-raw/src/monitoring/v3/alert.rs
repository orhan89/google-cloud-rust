// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/monitoring/v3/alert.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub documentation: ::protobuf::SingularPtrField<AlertPolicy_Documentation>,
    pub user_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub conditions: ::protobuf::RepeatedField<AlertPolicy_Condition>,
    pub combiner: AlertPolicy_ConditionCombinerType,
    pub enabled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub validity: ::protobuf::SingularPtrField<super::status::Status>,
    pub notification_channels: ::protobuf::RepeatedField<::std::string::String>,
    pub creation_record: ::protobuf::SingularPtrField<super::mutation_record::MutationRecord>,
    pub mutation_record: ::protobuf::SingularPtrField<super::mutation_record::MutationRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy {
    fn default() -> &'a AlertPolicy {
        <AlertPolicy as ::protobuf::Message>::default_instance()
    }
}

impl AlertPolicy {
    pub fn new() -> AlertPolicy {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.monitoring.v3.AlertPolicy.Documentation documentation = 13;


    pub fn get_documentation(&self) -> &AlertPolicy_Documentation {
        self.documentation.as_ref().unwrap_or_else(|| <AlertPolicy_Documentation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    pub fn has_documentation(&self) -> bool {
        self.documentation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: AlertPolicy_Documentation) {
        self.documentation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut AlertPolicy_Documentation {
        if self.documentation.is_none() {
            self.documentation.set_default();
        }
        self.documentation.as_mut().unwrap()
    }

    // Take field
    pub fn take_documentation(&mut self) -> AlertPolicy_Documentation {
        self.documentation.take().unwrap_or_else(|| AlertPolicy_Documentation::new())
    }

    // repeated .google.monitoring.v3.AlertPolicy.UserLabelsEntry user_labels = 16;


    pub fn get_user_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.user_labels
    }
    pub fn clear_user_labels(&mut self) {
        self.user_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.user_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.user_labels
    }

    // Take field
    pub fn take_user_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.user_labels, ::std::collections::HashMap::new())
    }

    // repeated .google.monitoring.v3.AlertPolicy.Condition conditions = 12;


    pub fn get_conditions(&self) -> &[AlertPolicy_Condition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<AlertPolicy_Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<AlertPolicy_Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<AlertPolicy_Condition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // .google.monitoring.v3.AlertPolicy.ConditionCombinerType combiner = 6;


    pub fn get_combiner(&self) -> AlertPolicy_ConditionCombinerType {
        self.combiner
    }
    pub fn clear_combiner(&mut self) {
        self.combiner = AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_combiner(&mut self, v: AlertPolicy_ConditionCombinerType) {
        self.combiner = v;
    }

    // .google.protobuf.BoolValue enabled = 17;


    pub fn get_enabled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.enabled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_enabled(&mut self) {
        self.enabled.clear();
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.enabled.is_none() {
            self.enabled.set_default();
        }
        self.enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.enabled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.rpc.Status validity = 18;


    pub fn get_validity(&self) -> &super::status::Status {
        self.validity.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validity(&mut self) {
        self.validity.clear();
    }

    pub fn has_validity(&self) -> bool {
        self.validity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validity(&mut self, v: super::status::Status) {
        self.validity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validity(&mut self) -> &mut super::status::Status {
        if self.validity.is_none() {
            self.validity.set_default();
        }
        self.validity.as_mut().unwrap()
    }

    // Take field
    pub fn take_validity(&mut self) -> super::status::Status {
        self.validity.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string notification_channels = 14;


    pub fn get_notification_channels(&self) -> &[::std::string::String] {
        &self.notification_channels
    }
    pub fn clear_notification_channels(&mut self) {
        self.notification_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_notification_channels(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.notification_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notification_channels(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.notification_channels
    }

    // Take field
    pub fn take_notification_channels(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.notification_channels, ::protobuf::RepeatedField::new())
    }

    // .google.monitoring.v3.MutationRecord creation_record = 10;


    pub fn get_creation_record(&self) -> &super::mutation_record::MutationRecord {
        self.creation_record.as_ref().unwrap_or_else(|| <super::mutation_record::MutationRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creation_record(&mut self) {
        self.creation_record.clear();
    }

    pub fn has_creation_record(&self) -> bool {
        self.creation_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_record(&mut self, v: super::mutation_record::MutationRecord) {
        self.creation_record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creation_record(&mut self) -> &mut super::mutation_record::MutationRecord {
        if self.creation_record.is_none() {
            self.creation_record.set_default();
        }
        self.creation_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_creation_record(&mut self) -> super::mutation_record::MutationRecord {
        self.creation_record.take().unwrap_or_else(|| super::mutation_record::MutationRecord::new())
    }

    // .google.monitoring.v3.MutationRecord mutation_record = 11;


    pub fn get_mutation_record(&self) -> &super::mutation_record::MutationRecord {
        self.mutation_record.as_ref().unwrap_or_else(|| <super::mutation_record::MutationRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mutation_record(&mut self) {
        self.mutation_record.clear();
    }

    pub fn has_mutation_record(&self) -> bool {
        self.mutation_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mutation_record(&mut self, v: super::mutation_record::MutationRecord) {
        self.mutation_record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mutation_record(&mut self) -> &mut super::mutation_record::MutationRecord {
        if self.mutation_record.is_none() {
            self.mutation_record.set_default();
        }
        self.mutation_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_mutation_record(&mut self) -> super::mutation_record::MutationRecord {
        self.mutation_record.take().unwrap_or_else(|| super::mutation_record::MutationRecord::new())
    }
}

impl ::protobuf::Message for AlertPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.documentation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.validity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creation_record {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mutation_record {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.documentation)?;
                },
                16 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.user_labels)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.combiner, 6, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.enabled)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validity)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notification_channels)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creation_record)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mutation_record)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if let Some(ref v) = self.documentation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(16, &self.user_labels);
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.combiner != AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.combiner);
        }
        if let Some(ref v) = self.enabled.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.validity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.notification_channels {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if let Some(ref v) = self.creation_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mutation_record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if let Some(ref v) = self.documentation.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(16, &self.user_labels, os)?;
        for v in &self.conditions {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.combiner != AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.combiner))?;
        }
        if let Some(ref v) = self.enabled.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.validity.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.notification_channels {
            os.write_string(14, &v)?;
        };
        if let Some(ref v) = self.creation_record.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mutation_record.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy {
        AlertPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AlertPolicy| { &m.name },
                |m: &mut AlertPolicy| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &AlertPolicy| { &m.display_name },
                |m: &mut AlertPolicy| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlertPolicy_Documentation>>(
                "documentation",
                |m: &AlertPolicy| { &m.documentation },
                |m: &mut AlertPolicy| { &mut m.documentation },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "user_labels",
                |m: &AlertPolicy| { &m.user_labels },
                |m: &mut AlertPolicy| { &mut m.user_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlertPolicy_Condition>>(
                "conditions",
                |m: &AlertPolicy| { &m.conditions },
                |m: &mut AlertPolicy| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlertPolicy_ConditionCombinerType>>(
                "combiner",
                |m: &AlertPolicy| { &m.combiner },
                |m: &mut AlertPolicy| { &mut m.combiner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "enabled",
                |m: &AlertPolicy| { &m.enabled },
                |m: &mut AlertPolicy| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "validity",
                |m: &AlertPolicy| { &m.validity },
                |m: &mut AlertPolicy| { &mut m.validity },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_channels",
                |m: &AlertPolicy| { &m.notification_channels },
                |m: &mut AlertPolicy| { &mut m.notification_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::mutation_record::MutationRecord>>(
                "creation_record",
                |m: &AlertPolicy| { &m.creation_record },
                |m: &mut AlertPolicy| { &mut m.creation_record },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::mutation_record::MutationRecord>>(
                "mutation_record",
                |m: &AlertPolicy| { &m.mutation_record },
                |m: &mut AlertPolicy| { &mut m.mutation_record },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy>(
                "AlertPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy::new)
    }
}

impl ::protobuf::Clear for AlertPolicy {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.documentation.clear();
        self.user_labels.clear();
        self.conditions.clear();
        self.combiner = AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED;
        self.enabled.clear();
        self.validity.clear();
        self.notification_channels.clear();
        self.creation_record.clear();
        self.mutation_record.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy_Documentation {
    // message fields
    pub content: ::std::string::String,
    pub mime_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy_Documentation {
    fn default() -> &'a AlertPolicy_Documentation {
        <AlertPolicy_Documentation as ::protobuf::Message>::default_instance()
    }
}

impl AlertPolicy_Documentation {
    pub fn new() -> AlertPolicy_Documentation {
        ::std::default::Default::default()
    }

    // string content = 1;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // string mime_type = 2;


    pub fn get_mime_type(&self) -> &str {
        &self.mime_type
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        &mut self.mime_type
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mime_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AlertPolicy_Documentation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mime_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.content);
        }
        if !self.mime_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mime_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_string(1, &self.content)?;
        }
        if !self.mime_type.is_empty() {
            os.write_string(2, &self.mime_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy_Documentation {
        AlertPolicy_Documentation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content",
                |m: &AlertPolicy_Documentation| { &m.content },
                |m: &mut AlertPolicy_Documentation| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mime_type",
                |m: &AlertPolicy_Documentation| { &m.mime_type },
                |m: &mut AlertPolicy_Documentation| { &mut m.mime_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy_Documentation>(
                "AlertPolicy.Documentation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy_Documentation {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy_Documentation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy_Documentation::new)
    }
}

impl ::protobuf::Clear for AlertPolicy_Documentation {
    fn clear(&mut self) {
        self.content.clear();
        self.mime_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy_Documentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_Documentation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy_Condition {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    // message oneof groups
    pub condition: ::std::option::Option<AlertPolicy_Condition_oneof_condition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy_Condition {
    fn default() -> &'a AlertPolicy_Condition {
        <AlertPolicy_Condition as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AlertPolicy_Condition_oneof_condition {
    condition_threshold(AlertPolicy_Condition_MetricThreshold),
    condition_absent(AlertPolicy_Condition_MetricAbsence),
}

impl AlertPolicy_Condition {
    pub fn new() -> AlertPolicy_Condition {
        ::std::default::Default::default()
    }

    // string name = 12;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 6;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.monitoring.v3.AlertPolicy.Condition.MetricThreshold condition_threshold = 1;


    pub fn get_condition_threshold(&self) -> &AlertPolicy_Condition_MetricThreshold {
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(ref v)) => v,
            _ => <AlertPolicy_Condition_MetricThreshold as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_condition_threshold(&mut self) {
        self.condition = ::std::option::Option::None;
    }

    pub fn has_condition_threshold(&self) -> bool {
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition_threshold(&mut self, v: AlertPolicy_Condition_MetricThreshold) {
        self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition_threshold(&mut self) -> &mut AlertPolicy_Condition_MetricThreshold {
        if let ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(_)) = self.condition {
        } else {
            self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(AlertPolicy_Condition_MetricThreshold::new()));
        }
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition_threshold(&mut self) -> AlertPolicy_Condition_MetricThreshold {
        if self.has_condition_threshold() {
            match self.condition.take() {
                ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(v)) => v,
                _ => panic!(),
            }
        } else {
            AlertPolicy_Condition_MetricThreshold::new()
        }
    }

    // .google.monitoring.v3.AlertPolicy.Condition.MetricAbsence condition_absent = 2;


    pub fn get_condition_absent(&self) -> &AlertPolicy_Condition_MetricAbsence {
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(ref v)) => v,
            _ => <AlertPolicy_Condition_MetricAbsence as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_condition_absent(&mut self) {
        self.condition = ::std::option::Option::None;
    }

    pub fn has_condition_absent(&self) -> bool {
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition_absent(&mut self, v: AlertPolicy_Condition_MetricAbsence) {
        self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition_absent(&mut self) -> &mut AlertPolicy_Condition_MetricAbsence {
        if let ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(_)) = self.condition {
        } else {
            self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(AlertPolicy_Condition_MetricAbsence::new()));
        }
        match self.condition {
            ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition_absent(&mut self) -> AlertPolicy_Condition_MetricAbsence {
        if self.has_condition_absent() {
            match self.condition.take() {
                ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(v)) => v,
                _ => panic!(),
            }
        } else {
            AlertPolicy_Condition_MetricAbsence::new()
        }
    }
}

impl ::protobuf::Message for AlertPolicy_Condition {
    fn is_initialized(&self) -> bool {
        if let Some(AlertPolicy_Condition_oneof_condition::condition_threshold(ref v)) = self.condition {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AlertPolicy_Condition_oneof_condition::condition_absent(ref v)) = self.condition {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_threshold(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.condition = ::std::option::Option::Some(AlertPolicy_Condition_oneof_condition::condition_absent(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.display_name);
        }
        if let ::std::option::Option::Some(ref v) = self.condition {
            match v {
                &AlertPolicy_Condition_oneof_condition::condition_threshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AlertPolicy_Condition_oneof_condition::condition_absent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(12, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(6, &self.display_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.condition {
            match v {
                &AlertPolicy_Condition_oneof_condition::condition_threshold(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AlertPolicy_Condition_oneof_condition::condition_absent(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy_Condition {
        AlertPolicy_Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AlertPolicy_Condition| { &m.name },
                |m: &mut AlertPolicy_Condition| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &AlertPolicy_Condition| { &m.display_name },
                |m: &mut AlertPolicy_Condition| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AlertPolicy_Condition_MetricThreshold>(
                "condition_threshold",
                AlertPolicy_Condition::has_condition_threshold,
                AlertPolicy_Condition::get_condition_threshold,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AlertPolicy_Condition_MetricAbsence>(
                "condition_absent",
                AlertPolicy_Condition::has_condition_absent,
                AlertPolicy_Condition::get_condition_absent,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy_Condition>(
                "AlertPolicy.Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy_Condition {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy_Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy_Condition::new)
    }
}

impl ::protobuf::Clear for AlertPolicy_Condition {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.condition = ::std::option::Option::None;
        self.condition = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy_Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy_Condition_Trigger {
    // message oneof groups
    pub field_type: ::std::option::Option<AlertPolicy_Condition_Trigger_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy_Condition_Trigger {
    fn default() -> &'a AlertPolicy_Condition_Trigger {
        <AlertPolicy_Condition_Trigger as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AlertPolicy_Condition_Trigger_oneof_type {
    count(i32),
    percent(f64),
}

impl AlertPolicy_Condition_Trigger {
    pub fn new() -> AlertPolicy_Condition_Trigger {
        ::std::default::Default::default()
    }

    // int32 count = 1;


    pub fn get_count(&self) -> i32 {
        match self.field_type {
            ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::count(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_count(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::count(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::count(v))
    }

    // double percent = 2;


    pub fn get_percent(&self) -> f64 {
        match self.field_type {
            ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::percent(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_percent(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::percent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: f64) {
        self.field_type = ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::percent(v))
    }
}

impl ::protobuf::Message for AlertPolicy_Condition_Trigger {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::count(is.read_int32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AlertPolicy_Condition_Trigger_oneof_type::percent(is.read_double()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AlertPolicy_Condition_Trigger_oneof_type::count(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &AlertPolicy_Condition_Trigger_oneof_type::percent(v) => {
                    my_size += 9;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AlertPolicy_Condition_Trigger_oneof_type::count(v) => {
                    os.write_int32(1, v)?;
                },
                &AlertPolicy_Condition_Trigger_oneof_type::percent(v) => {
                    os.write_double(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy_Condition_Trigger {
        AlertPolicy_Condition_Trigger::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "count",
                AlertPolicy_Condition_Trigger::has_count,
                AlertPolicy_Condition_Trigger::get_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "percent",
                AlertPolicy_Condition_Trigger::has_percent,
                AlertPolicy_Condition_Trigger::get_percent,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy_Condition_Trigger>(
                "AlertPolicy.Condition.Trigger",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy_Condition_Trigger {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy_Condition_Trigger> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy_Condition_Trigger::new)
    }
}

impl ::protobuf::Clear for AlertPolicy_Condition_Trigger {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy_Condition_Trigger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_Condition_Trigger {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy_Condition_MetricThreshold {
    // message fields
    pub filter: ::std::string::String,
    pub aggregations: ::protobuf::RepeatedField<super::common::Aggregation>,
    pub denominator_filter: ::std::string::String,
    pub denominator_aggregations: ::protobuf::RepeatedField<super::common::Aggregation>,
    pub comparison: super::common::ComparisonType,
    pub threshold_value: f64,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub trigger: ::protobuf::SingularPtrField<AlertPolicy_Condition_Trigger>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy_Condition_MetricThreshold {
    fn default() -> &'a AlertPolicy_Condition_MetricThreshold {
        <AlertPolicy_Condition_MetricThreshold as ::protobuf::Message>::default_instance()
    }
}

impl AlertPolicy_Condition_MetricThreshold {
    pub fn new() -> AlertPolicy_Condition_MetricThreshold {
        ::std::default::Default::default()
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // repeated .google.monitoring.v3.Aggregation aggregations = 8;


    pub fn get_aggregations(&self) -> &[super::common::Aggregation] {
        &self.aggregations
    }
    pub fn clear_aggregations(&mut self) {
        self.aggregations.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregations(&mut self, v: ::protobuf::RepeatedField<super::common::Aggregation>) {
        self.aggregations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregations(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Aggregation> {
        &mut self.aggregations
    }

    // Take field
    pub fn take_aggregations(&mut self) -> ::protobuf::RepeatedField<super::common::Aggregation> {
        ::std::mem::replace(&mut self.aggregations, ::protobuf::RepeatedField::new())
    }

    // string denominator_filter = 9;


    pub fn get_denominator_filter(&self) -> &str {
        &self.denominator_filter
    }
    pub fn clear_denominator_filter(&mut self) {
        self.denominator_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_denominator_filter(&mut self, v: ::std::string::String) {
        self.denominator_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denominator_filter(&mut self) -> &mut ::std::string::String {
        &mut self.denominator_filter
    }

    // Take field
    pub fn take_denominator_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denominator_filter, ::std::string::String::new())
    }

    // repeated .google.monitoring.v3.Aggregation denominator_aggregations = 10;


    pub fn get_denominator_aggregations(&self) -> &[super::common::Aggregation] {
        &self.denominator_aggregations
    }
    pub fn clear_denominator_aggregations(&mut self) {
        self.denominator_aggregations.clear();
    }

    // Param is passed by value, moved
    pub fn set_denominator_aggregations(&mut self, v: ::protobuf::RepeatedField<super::common::Aggregation>) {
        self.denominator_aggregations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denominator_aggregations(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Aggregation> {
        &mut self.denominator_aggregations
    }

    // Take field
    pub fn take_denominator_aggregations(&mut self) -> ::protobuf::RepeatedField<super::common::Aggregation> {
        ::std::mem::replace(&mut self.denominator_aggregations, ::protobuf::RepeatedField::new())
    }

    // .google.monitoring.v3.ComparisonType comparison = 4;


    pub fn get_comparison(&self) -> super::common::ComparisonType {
        self.comparison
    }
    pub fn clear_comparison(&mut self) {
        self.comparison = super::common::ComparisonType::COMPARISON_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_comparison(&mut self, v: super::common::ComparisonType) {
        self.comparison = v;
    }

    // double threshold_value = 5;


    pub fn get_threshold_value(&self) -> f64 {
        self.threshold_value
    }
    pub fn clear_threshold_value(&mut self) {
        self.threshold_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold_value(&mut self, v: f64) {
        self.threshold_value = v;
    }

    // .google.protobuf.Duration duration = 6;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 7;


    pub fn get_trigger(&self) -> &AlertPolicy_Condition_Trigger {
        self.trigger.as_ref().unwrap_or_else(|| <AlertPolicy_Condition_Trigger as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trigger(&mut self) {
        self.trigger.clear();
    }

    pub fn has_trigger(&self) -> bool {
        self.trigger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger(&mut self, v: AlertPolicy_Condition_Trigger) {
        self.trigger = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger(&mut self) -> &mut AlertPolicy_Condition_Trigger {
        if self.trigger.is_none() {
            self.trigger.set_default();
        }
        self.trigger.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger(&mut self) -> AlertPolicy_Condition_Trigger {
        self.trigger.take().unwrap_or_else(|| AlertPolicy_Condition_Trigger::new())
    }
}

impl ::protobuf::Message for AlertPolicy_Condition_MetricThreshold {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denominator_aggregations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trigger {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregations)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denominator_filter)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.denominator_aggregations)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.comparison, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.threshold_value = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trigger)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        for value in &self.aggregations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.denominator_filter.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.denominator_filter);
        }
        for value in &self.denominator_aggregations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.comparison != super::common::ComparisonType::COMPARISON_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.comparison);
        }
        if self.threshold_value != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        for v in &self.aggregations {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.denominator_filter.is_empty() {
            os.write_string(9, &self.denominator_filter)?;
        }
        for v in &self.denominator_aggregations {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.comparison != super::common::ComparisonType::COMPARISON_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.comparison))?;
        }
        if self.threshold_value != 0. {
            os.write_double(5, self.threshold_value)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy_Condition_MetricThreshold {
        AlertPolicy_Condition_MetricThreshold::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.filter },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Aggregation>>(
                "aggregations",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.aggregations },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.aggregations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "denominator_filter",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.denominator_filter },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.denominator_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Aggregation>>(
                "denominator_aggregations",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.denominator_aggregations },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.denominator_aggregations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::ComparisonType>>(
                "comparison",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.comparison },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.comparison },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "threshold_value",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.threshold_value },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.threshold_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.duration },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlertPolicy_Condition_Trigger>>(
                "trigger",
                |m: &AlertPolicy_Condition_MetricThreshold| { &m.trigger },
                |m: &mut AlertPolicy_Condition_MetricThreshold| { &mut m.trigger },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy_Condition_MetricThreshold>(
                "AlertPolicy.Condition.MetricThreshold",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy_Condition_MetricThreshold {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy_Condition_MetricThreshold> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy_Condition_MetricThreshold::new)
    }
}

impl ::protobuf::Clear for AlertPolicy_Condition_MetricThreshold {
    fn clear(&mut self) {
        self.filter.clear();
        self.aggregations.clear();
        self.denominator_filter.clear();
        self.denominator_aggregations.clear();
        self.comparison = super::common::ComparisonType::COMPARISON_UNSPECIFIED;
        self.threshold_value = 0.;
        self.duration.clear();
        self.trigger.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy_Condition_MetricThreshold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_Condition_MetricThreshold {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlertPolicy_Condition_MetricAbsence {
    // message fields
    pub filter: ::std::string::String,
    pub aggregations: ::protobuf::RepeatedField<super::common::Aggregation>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub trigger: ::protobuf::SingularPtrField<AlertPolicy_Condition_Trigger>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlertPolicy_Condition_MetricAbsence {
    fn default() -> &'a AlertPolicy_Condition_MetricAbsence {
        <AlertPolicy_Condition_MetricAbsence as ::protobuf::Message>::default_instance()
    }
}

impl AlertPolicy_Condition_MetricAbsence {
    pub fn new() -> AlertPolicy_Condition_MetricAbsence {
        ::std::default::Default::default()
    }

    // string filter = 1;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // repeated .google.monitoring.v3.Aggregation aggregations = 5;


    pub fn get_aggregations(&self) -> &[super::common::Aggregation] {
        &self.aggregations
    }
    pub fn clear_aggregations(&mut self) {
        self.aggregations.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregations(&mut self, v: ::protobuf::RepeatedField<super::common::Aggregation>) {
        self.aggregations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregations(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Aggregation> {
        &mut self.aggregations
    }

    // Take field
    pub fn take_aggregations(&mut self) -> ::protobuf::RepeatedField<super::common::Aggregation> {
        ::std::mem::replace(&mut self.aggregations, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Duration duration = 2;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.monitoring.v3.AlertPolicy.Condition.Trigger trigger = 3;


    pub fn get_trigger(&self) -> &AlertPolicy_Condition_Trigger {
        self.trigger.as_ref().unwrap_or_else(|| <AlertPolicy_Condition_Trigger as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trigger(&mut self) {
        self.trigger.clear();
    }

    pub fn has_trigger(&self) -> bool {
        self.trigger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger(&mut self, v: AlertPolicy_Condition_Trigger) {
        self.trigger = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger(&mut self) -> &mut AlertPolicy_Condition_Trigger {
        if self.trigger.is_none() {
            self.trigger.set_default();
        }
        self.trigger.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger(&mut self) -> AlertPolicy_Condition_Trigger {
        self.trigger.take().unwrap_or_else(|| AlertPolicy_Condition_Trigger::new())
    }
}

impl ::protobuf::Message for AlertPolicy_Condition_MetricAbsence {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trigger {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregations)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trigger)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.filter);
        }
        for value in &self.aggregations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.filter.is_empty() {
            os.write_string(1, &self.filter)?;
        }
        for v in &self.aggregations {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlertPolicy_Condition_MetricAbsence {
        AlertPolicy_Condition_MetricAbsence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &AlertPolicy_Condition_MetricAbsence| { &m.filter },
                |m: &mut AlertPolicy_Condition_MetricAbsence| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Aggregation>>(
                "aggregations",
                |m: &AlertPolicy_Condition_MetricAbsence| { &m.aggregations },
                |m: &mut AlertPolicy_Condition_MetricAbsence| { &mut m.aggregations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &AlertPolicy_Condition_MetricAbsence| { &m.duration },
                |m: &mut AlertPolicy_Condition_MetricAbsence| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlertPolicy_Condition_Trigger>>(
                "trigger",
                |m: &AlertPolicy_Condition_MetricAbsence| { &m.trigger },
                |m: &mut AlertPolicy_Condition_MetricAbsence| { &mut m.trigger },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlertPolicy_Condition_MetricAbsence>(
                "AlertPolicy.Condition.MetricAbsence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlertPolicy_Condition_MetricAbsence {
        static instance: ::protobuf::rt::LazyV2<AlertPolicy_Condition_MetricAbsence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlertPolicy_Condition_MetricAbsence::new)
    }
}

impl ::protobuf::Clear for AlertPolicy_Condition_MetricAbsence {
    fn clear(&mut self) {
        self.filter.clear();
        self.aggregations.clear();
        self.duration.clear();
        self.trigger.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlertPolicy_Condition_MetricAbsence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_Condition_MetricAbsence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AlertPolicy_ConditionCombinerType {
    COMBINE_UNSPECIFIED = 0,
    AND = 1,
    OR = 2,
    AND_WITH_MATCHING_RESOURCE = 3,
}

impl ::protobuf::ProtobufEnum for AlertPolicy_ConditionCombinerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlertPolicy_ConditionCombinerType> {
        match value {
            0 => ::std::option::Option::Some(AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AlertPolicy_ConditionCombinerType::AND),
            2 => ::std::option::Option::Some(AlertPolicy_ConditionCombinerType::OR),
            3 => ::std::option::Option::Some(AlertPolicy_ConditionCombinerType::AND_WITH_MATCHING_RESOURCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AlertPolicy_ConditionCombinerType] = &[
            AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED,
            AlertPolicy_ConditionCombinerType::AND,
            AlertPolicy_ConditionCombinerType::OR,
            AlertPolicy_ConditionCombinerType::AND_WITH_MATCHING_RESOURCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AlertPolicy_ConditionCombinerType>("AlertPolicy.ConditionCombinerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AlertPolicy_ConditionCombinerType {
}

impl ::std::default::Default for AlertPolicy_ConditionCombinerType {
    fn default() -> Self {
        AlertPolicy_ConditionCombinerType::COMBINE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AlertPolicy_ConditionCombinerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20google/monitoring/v3/alert.proto\x12\x14google.monitoring.v3\x1a!g\
    oogle/monitoring/v3/common.proto\x1a*google/monitoring/v3/mutation_recor\
    d.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wra\
    ppers.proto\x1a\x17google/rpc/status.proto\"\x91\x10\n\x0bAlertPolicy\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\
    \x18\x02\x20\x01(\tR\x0bdisplayName\x12U\n\rdocumentation\x18\r\x20\x01(\
    \x0b2/.google.monitoring.v3.AlertPolicy.DocumentationR\rdocumentation\
    \x12R\n\x0buser_labels\x18\x10\x20\x03(\x0b21.google.monitoring.v3.Alert\
    Policy.UserLabelsEntryR\nuserLabels\x12K\n\nconditions\x18\x0c\x20\x03(\
    \x0b2+.google.monitoring.v3.AlertPolicy.ConditionR\nconditions\x12S\n\
    \x08combiner\x18\x06\x20\x01(\x0e27.google.monitoring.v3.AlertPolicy.Con\
    ditionCombinerTypeR\x08combiner\x124\n\x07enabled\x18\x11\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x07enabled\x12.\n\x08validity\x18\x12\
    \x20\x01(\x0b2\x12.google.rpc.StatusR\x08validity\x123\n\x15notification\
    _channels\x18\x0e\x20\x03(\tR\x14notificationChannels\x12M\n\x0fcreation\
    _record\x18\n\x20\x01(\x0b2$.google.monitoring.v3.MutationRecordR\x0ecre\
    ationRecord\x12M\n\x0fmutation_record\x18\x0b\x20\x01(\x0b2$.google.moni\
    toring.v3.MutationRecordR\x0emutationRecord\x1aF\n\rDocumentation\x12\
    \x18\n\x07content\x18\x01\x20\x01(\tR\x07content\x12\x1b\n\tmime_type\
    \x18\x02\x20\x01(\tR\x08mimeType\x1a\xda\x08\n\tCondition\x12\x12\n\x04n\
    ame\x18\x0c\x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\x06\x20\x01(\
    \tR\x0bdisplayName\x12n\n\x13condition_threshold\x18\x01\x20\x01(\x0b2;.\
    google.monitoring.v3.AlertPolicy.Condition.MetricThresholdH\0R\x12condit\
    ionThreshold\x12f\n\x10condition_absent\x18\x02\x20\x01(\x0b29.google.mo\
    nitoring.v3.AlertPolicy.Condition.MetricAbsenceH\0R\x0fconditionAbsent\
    \x1aE\n\x07Trigger\x12\x16\n\x05count\x18\x01\x20\x01(\x05H\0R\x05count\
    \x12\x1a\n\x07percent\x18\x02\x20\x01(\x01H\0R\x07percentB\x06\n\x04type\
    \x1a\xf2\x03\n\x0fMetricThreshold\x12\x16\n\x06filter\x18\x02\x20\x01(\t\
    R\x06filter\x12E\n\x0caggregations\x18\x08\x20\x03(\x0b2!.google.monitor\
    ing.v3.AggregationR\x0caggregations\x12-\n\x12denominator_filter\x18\t\
    \x20\x01(\tR\x11denominatorFilter\x12\\\n\x18denominator_aggregations\
    \x18\n\x20\x03(\x0b2!.google.monitoring.v3.AggregationR\x17denominatorAg\
    gregations\x12D\n\ncomparison\x18\x04\x20\x01(\x0e2$.google.monitoring.v\
    3.ComparisonTypeR\ncomparison\x12'\n\x0fthreshold_value\x18\x05\x20\x01(\
    \x01R\x0ethresholdValue\x125\n\x08duration\x18\x06\x20\x01(\x0b2\x19.goo\
    gle.protobuf.DurationR\x08duration\x12M\n\x07trigger\x18\x07\x20\x01(\
    \x0b23.google.monitoring.v3.AlertPolicy.Condition.TriggerR\x07trigger\
    \x1a\xf4\x01\n\rMetricAbsence\x12\x16\n\x06filter\x18\x01\x20\x01(\tR\
    \x06filter\x12E\n\x0caggregations\x18\x05\x20\x03(\x0b2!.google.monitori\
    ng.v3.AggregationR\x0caggregations\x125\n\x08duration\x18\x02\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x08duration\x12M\n\x07trigger\x18\
    \x03\x20\x01(\x0b23.google.monitoring.v3.AlertPolicy.Condition.TriggerR\
    \x07triggerB\x0b\n\tcondition\x1a=\n\x0fUserLabelsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"a\n\x15ConditionCombinerType\x12\x17\n\x13COMBINE_UNSPECI\
    FIED\x10\0\x12\x07\n\x03AND\x10\x01\x12\x06\n\x02OR\x10\x02\x12\x1e\n\
    \x1aAND_WITH_MATCHING_RESOURCE\x10\x03B\xa2\x01\n\x18com.google.monitori\
    ng.v3B\nAlertProtoP\x01Z>google.golang.org/genproto/googleapis/monitorin\
    g/v3;monitoring\xaa\x02\x1aGoogle.Cloud.Monitoring.V3\xca\x02\x1aGoogle\
    \\Cloud\\Monitoring\\V3J\xedy\n\x07\x12\x05\x0f\0\xd2\x02\x01\n\xbe\x04\
    \n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20\
    LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\
    \x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20Y\
    ou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\
    \x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\
    \x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20w\
    riting,\x20software\n\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WA\
    RRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\
    \x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1d\n\t\n\x02\x03\
    \0\x12\x03\x13\0+\n\t\n\x02\x03\x01\x12\x03\x14\04\n\t\n\x02\x03\x02\x12\
    \x03\x15\0(\n\t\n\x02\x03\x03\x12\x03\x16\0(\n\t\n\x02\x03\x04\x12\x03\
    \x17\0!\n\x08\n\x01\x08\x12\x03\x19\07\n\t\n\x02\x08%\x12\x03\x19\07\n\
    \x08\n\x01\x08\x12\x03\x1a\0U\n\t\n\x02\x08\x0b\x12\x03\x1a\0U\n\x08\n\
    \x01\x08\x12\x03\x1b\0\"\n\t\n\x02\x08\n\x12\x03\x1b\0\"\n\x08\n\x01\x08\
    \x12\x03\x1c\0+\n\t\n\x02\x08\x08\x12\x03\x1c\0+\n\x08\n\x01\x08\x12\x03\
    \x1d\01\n\t\n\x02\x08\x01\x12\x03\x1d\01\n\x08\n\x01\x08\x12\x03\x1e\07\
    \n\t\n\x02\x08)\x12\x03\x1e\07\n\x8d\x02\n\x02\x04\0\x12\x05$\0\xd2\x02\
    \x01\x1a\xff\x01\x20A\x20description\x20of\x20the\x20conditions\x20under\
    \x20which\x20some\x20aspect\x20of\x20your\x20system\x20is\n\x20considere\
    d\x20to\x20be\x20\"unhealthy\"\x20and\x20the\x20ways\x20to\x20notify\x20\
    people\x20or\x20services\x20about\n\x20this\x20state.\x20For\x20an\x20ov\
    erview\x20of\x20alert\x20policies,\x20see\n\x20[Introduction\x20to\x20Al\
    erting](/monitoring/alerts/).\n\n\n\n\x03\x04\0\x01\x12\x03$\x08\x13\n]\
    \n\x04\x04\0\x03\0\x12\x04'\x022\x03\x1aO\x20A\x20content\x20string\x20a\
    nd\x20a\x20MIME\x20type\x20that\x20describes\x20the\x20content\x20string\
    's\n\x20format.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03'\n\x17\n\xeb\x01\n\
    \x06\x04\0\x03\0\x02\0\x12\x03,\x04\x17\x1a\xdb\x01\x20The\x20text\x20of\
    \x20the\x20documentation,\x20interpreted\x20according\x20to\x20`mime_typ\
    e`.\n\x20The\x20content\x20may\x20not\x20exceed\x208,192\x20Unicode\x20c\
    haracters\x20and\x20may\x20not\x20exceed\n\x20more\x20than\x2010,240\x20\
    bytes\x20when\x20encoded\x20in\x20UTF-8\x20format,\x20whichever\x20is\n\
    \x20smaller.\n\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03,\x04\n\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x01\x12\x03,\x0b\x12\n\x0e\n\x07\x04\0\x03\0\x02\
    \0\x03\x12\x03,\x15\x16\n\xbd\x01\n\x06\x04\0\x03\0\x02\x01\x12\x031\x04\
    \x19\x1a\xad\x01\x20The\x20format\x20of\x20the\x20`content`\x20field.\
    \x20Presently,\x20only\x20the\x20value\n\x20`\"text/markdown\"`\x20is\
    \x20supported.\x20See\n\x20[Markdown](https://en.wikipedia.org/wiki/Mark\
    down)\x20for\x20more\x20information.\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x05\x12\x031\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x031\x0b\x14\
    \n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x031\x17\x18\n\xbd\x01\n\x04\
    \x04\0\x03\x01\x12\x057\x02\xf1\x01\x03\x1a\xad\x01\x20A\x20condition\
    \x20is\x20a\x20true/false\x20test\x20that\x20determines\x20when\x20an\
    \x20alerting\x20policy\n\x20should\x20open\x20an\x20incident.\x20If\x20a\
    \x20condition\x20evaluates\x20to\x20true,\x20it\x20signifies\n\x20that\
    \x20something\x20is\x20wrong.\n\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x037\n\
    \x13\n\x97\x01\n\x06\x04\0\x03\x01\x03\0\x12\x04:\x04E\x05\x1a\x86\x01\
    \x20Specifies\x20how\x20many\x20time\x20series\x20must\x20fail\x20a\x20p\
    redicate\x20to\x20trigger\x20a\n\x20condition.\x20If\x20not\x20specified\
    ,\x20then\x20a\x20`{count:\x201}`\x20trigger\x20is\x20used.\n\n\x0e\n\
    \x07\x04\0\x03\x01\x03\0\x01\x12\x03:\x0c\x13\n&\n\x08\x04\0\x03\x01\x03\
    \0\x08\0\x12\x04<\x06D\x07\x1a\x14\x20A\x20type\x20of\x20trigger.\n\n\
    \x10\n\t\x04\0\x03\x01\x03\0\x08\0\x01\x12\x03<\x0c\x10\nv\n\x08\x04\0\
    \x03\x01\x03\0\x02\0\x12\x03?\x08\x18\x1ae\x20The\x20absolute\x20number\
    \x20of\x20time\x20series\x20that\x20must\x20fail\n\x20the\x20predicate\
    \x20for\x20the\x20condition\x20to\x20be\x20triggered.\n\n\x10\n\t\x04\0\
    \x03\x01\x03\0\x02\0\x05\x12\x03?\x08\r\n\x10\n\t\x04\0\x03\x01\x03\0\
    \x02\0\x01\x12\x03?\x0e\x13\n\x10\n\t\x04\0\x03\x01\x03\0\x02\0\x03\x12\
    \x03?\x16\x17\nq\n\x08\x04\0\x03\x01\x03\0\x02\x01\x12\x03C\x08\x1b\x1a`\
    \x20The\x20percentage\x20of\x20time\x20series\x20that\x20must\x20fail\
    \x20the\n\x20predicate\x20for\x20the\x20condition\x20to\x20be\x20trigger\
    ed.\n\n\x10\n\t\x04\0\x03\x01\x03\0\x02\x01\x05\x12\x03C\x08\x0e\n\x10\n\
    \t\x04\0\x03\x01\x03\0\x02\x01\x01\x12\x03C\x0f\x16\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\x01\x03\x12\x03C\x19\x1a\nc\n\x06\x04\0\x03\x01\x03\x01\
    \x12\x05I\x04\x98\x01\x05\x1aR\x20A\x20condition\x20type\x20that\x20comp\
    ares\x20a\x20collection\x20of\x20time\x20series\n\x20against\x20a\x20thr\
    eshold.\n\n\x0e\n\x07\x04\0\x03\x01\x03\x01\x01\x12\x03I\x0c\x1b\n\xa9\
    \x04\n\x08\x04\0\x03\x01\x03\x01\x02\0\x12\x03T\x06\x18\x1a\x97\x04\x20A\
    \x20[filter](/monitoring/api/v3/filters)\x20that\n\x20identifies\x20whic\
    h\x20time\x20series\x20should\x20be\x20compared\x20with\x20the\x20thresh\
    old.\n\n\x20The\x20filter\x20is\x20similar\x20to\x20the\x20one\x20that\
    \x20is\x20specified\x20in\x20the\n\x20[`ListTimeSeries`\n\x20request](/m\
    onitoring/api/ref_v3/rest/v3/projects.timeSeries/list)\x20(that\n\x20cal\
    l\x20is\x20useful\x20to\x20verify\x20the\x20time\x20series\x20that\x20wi\
    ll\x20be\x20retrieved\x20/\n\x20processed)\x20and\x20must\x20specify\x20\
    the\x20metric\x20type\x20and\x20optionally\x20may\x20contain\n\x20restri\
    ctions\x20on\x20resource\x20type,\x20resource\x20labels,\x20and\x20metri\
    c\x20labels.\n\x20This\x20field\x20may\x20not\x20exceed\x202048\x20Unico\
    de\x20characters\x20in\x20length.\n\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\
    \0\x05\x12\x03T\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\0\x01\x12\
    \x03T\r\x13\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\0\x03\x12\x03T\x16\x17\n\
    \xca\x04\n\x08\x04\0\x03\x01\x03\x01\x02\x01\x12\x03a\x06,\x1a\xb8\x04\
    \x20Specifies\x20the\x20alignment\x20of\x20data\x20points\x20in\x20indiv\
    idual\x20time\x20series\x20as\n\x20well\x20as\x20how\x20to\x20combine\
    \x20the\x20retrieved\x20time\x20series\x20together\x20(such\x20as\n\x20w\
    hen\x20aggregating\x20multiple\x20streams\x20on\x20each\x20resource\x20t\
    o\x20a\x20single\n\x20stream\x20for\x20each\x20resource\x20or\x20when\
    \x20aggregating\x20streams\x20across\x20all\n\x20members\x20of\x20a\x20g\
    roup\x20of\x20resrouces).\x20Multiple\x20aggregations\n\x20are\x20applie\
    d\x20in\x20the\x20order\x20specified.\n\n\x20This\x20field\x20is\x20simi\
    lar\x20to\x20the\x20one\x20in\x20the\x20[`ListTimeSeries`\n\x20request](\
    /monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).\x20It\n\x20is\
    \x20advisable\x20to\x20use\x20the\x20`ListTimeSeries`\x20method\x20when\
    \x20debugging\x20this\n\x20field.\n\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\
    \x01\x04\x12\x03a\x06\x0e\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x01\x06\
    \x12\x03a\x0f\x1a\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x01\x01\x12\x03a\
    \x1b'\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\x01\x03\x12\x03a*+\n\xf6\x03\n\
    \x08\x04\0\x03\x01\x03\x01\x02\x02\x12\x03l\x06$\x1a\xe4\x03\x20A\x20[fi\
    lter](/monitoring/api/v3/filters)\x20that\x20identifies\x20a\x20time\n\
    \x20series\x20that\x20should\x20be\x20used\x20as\x20the\x20denominator\
    \x20of\x20a\x20ratio\x20that\x20will\x20be\n\x20compared\x20with\x20the\
    \x20threshold.\x20If\x20a\x20`denominator_filter`\x20is\x20specified,\n\
    \x20the\x20time\x20series\x20specified\x20by\x20the\x20`filter`\x20field\
    \x20will\x20be\x20used\x20as\x20the\n\x20numerator.\n\n\x20The\x20filter\
    \x20must\x20specify\x20the\x20metric\x20type\x20and\x20optionally\x20may\
    \x20contain\n\x20restrictions\x20on\x20resource\x20type,\x20resource\x20\
    labels,\x20and\x20metric\x20labels.\n\x20This\x20field\x20may\x20not\x20\
    exceed\x202048\x20Unicode\x20characters\x20in\x20length.\n\n\x10\n\t\x04\
    \0\x03\x01\x03\x01\x02\x02\x05\x12\x03l\x06\x0c\n\x10\n\t\x04\0\x03\x01\
    \x03\x01\x02\x02\x01\x12\x03l\r\x1f\n\x10\n\t\x04\0\x03\x01\x03\x01\x02\
    \x02\x03\x12\x03l\"#\n\x9a\x04\n\x08\x04\0\x03\x01\x03\x01\x02\x03\x12\
    \x03x\x069\x1a\x88\x04\x20Specifies\x20the\x20alignment\x20of\x20data\
    \x20points\x20in\x20individual\x20time\x20series\n\x20selected\x20by\x20\
    `denominatorFilter`\x20as\n\x20well\x20as\x20how\x20to\x20combine\x20the\
    \x20retrieved\x20time\x20series\x20together\x20(such\x20as\n\x20when\x20\
    aggregating\x20multiple\x20streams\x20on\x20each\x20resource\x20to\x20a\
    \x20single\n\x20stream\x20for\x20each\x20resource\x20or\x20when\x20aggre\
    gating\x20streams\x20across\x20all\n\x20members\x20of\x20a\x20group\x20o\
    f\x20resources).\n\n\x20When\x20computing\x20ratios,\x20the\x20`aggregat\
    ions`\x20and\n\x20`denominator_aggregations`\x20fields\x20must\x20use\
    \x20the\x20same\x20alignment\x20period\n\x20and\x20produce\x20time\x20se\
    ries\x20that\x20have\x20the\x20same\x20periodicity\x20and\x20labels.\n\n\
    \x10\n\t\x04\0\x03\x01\x03\x01\x02\x03\x04\x12\x03x\x06\x0e\n\x10\n\t\
    \x04\0\x03\x01\x03\x01\x02\x03\x06\x12\x03x\x0f\x1a\n\x10\n\t\x04\0\x03\
    \x01\x03\x01\x02\x03\x01\x12\x03x\x1b3\n\x10\n\t\x04\0\x03\x01\x03\x01\
    \x02\x03\x03\x12\x03x68\n\xed\x02\n\x08\x04\0\x03\x01\x03\x01\x02\x04\
    \x12\x04\x80\x01\x06$\x1a\xda\x02\x20The\x20comparison\x20to\x20apply\
    \x20between\x20the\x20time\x20series\x20(indicated\x20by\x20`filter`\n\
    \x20and\x20`aggregation`)\x20and\x20the\x20threshold\x20(indicated\x20by\
    \x20`threshold_value`).\n\x20The\x20comparison\x20is\x20applied\x20on\
    \x20each\x20time\x20series,\x20with\x20the\x20time\x20series\n\x20on\x20\
    the\x20left-hand\x20side\x20and\x20the\x20threshold\x20on\x20the\x20righ\
    t-hand\x20side.\n\n\x20Only\x20`COMPARISON_LT`\x20and\x20`COMPARISON_GT`\
    \x20are\x20supported\x20currently.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\
    \x04\x06\x12\x04\x80\x01\x06\x14\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x04\
    \x01\x12\x04\x80\x01\x15\x1f\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x04\x03\
    \x12\x04\x80\x01\"#\nE\n\x08\x04\0\x03\x01\x03\x01\x02\x05\x12\x04\x83\
    \x01\x06!\x1a3\x20A\x20value\x20against\x20which\x20to\x20compare\x20the\
    \x20time\x20series.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x05\x12\
    \x04\x83\x01\x06\x0c\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x01\x12\x04\
    \x83\x01\r\x1c\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x05\x03\x12\x04\x83\
    \x01\x1f\x20\n\xff\x04\n\x08\x04\0\x03\x01\x03\x01\x02\x06\x12\x04\x8f\
    \x01\x06,\x1a\xec\x04\x20The\x20amount\x20of\x20time\x20that\x20a\x20tim\
    e\x20series\x20must\x20violate\x20the\n\x20threshold\x20to\x20be\x20cons\
    idered\x20failing.\x20Currently,\x20only\x20values\n\x20that\x20are\x20a\
    \x20multiple\x20of\x20a\x20minute--e.g.,\x200,\x2060,\x20120,\x20or\x203\
    00\n\x20seconds--are\x20supported.\x20If\x20an\x20invalid\x20value\x20is\
    \x20given,\x20an\n\x20error\x20will\x20be\x20returned.\x20When\x20choosi\
    ng\x20a\x20duration,\x20it\x20is\x20useful\x20to\n\x20keep\x20in\x20mind\
    \x20the\x20frequency\x20of\x20the\x20underlying\x20time\x20series\x20dat\
    a\n\x20(which\x20may\x20also\x20be\x20affected\x20by\x20any\x20alignment\
    s\x20specified\x20in\x20the\n\x20`aggregations`\x20field);\x20a\x20good\
    \x20duration\x20is\x20long\x20enough\x20so\x20that\x20a\x20single\n\x20o\
    utlier\x20does\x20not\x20generate\x20spurious\x20alerts,\x20but\x20short\
    \x20enough\x20that\n\x20unhealthy\x20states\x20are\x20detected\x20and\
    \x20alerted\x20on\x20quickly.\n\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x06\
    \x06\x12\x04\x8f\x01\x06\x1e\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x06\x01\
    \x12\x04\x8f\x01\x1f'\n\x11\n\t\x04\0\x03\x01\x03\x01\x02\x06\x03\x12\
    \x04\x8f\x01*+\n\xfb\x02\n\x08\x04\0\x03\x01\x03\x01\x02\x07\x12\x04\x97\
    \x01\x06\x1a\x1a\xe8\x02\x20The\x20number/percent\x20of\x20time\x20serie\
    s\x20for\x20which\x20the\x20comparison\x20must\x20hold\n\x20in\x20order\
    \x20for\x20the\x20condition\x20to\x20trigger.\x20If\x20unspecified,\x20t\
    hen\x20the\n\x20condition\x20will\x20trigger\x20if\x20the\x20comparison\
    \x20is\x20true\x20for\x20any\x20of\x20the\n\x20time\x20series\x20that\
    \x20have\x20been\x20identified\x20by\x20`filter`\x20and\x20`aggregations\
    `,\n\x20or\x20by\x20the\x20ratio,\x20if\x20`denominator_filter`\x20and\
    \x20`denominator_aggregations`\n\x20are\x20specified.\n\n\x11\n\t\x04\0\
    \x03\x01\x03\x01\x02\x07\x06\x12\x04\x97\x01\x06\r\n\x11\n\t\x04\0\x03\
    \x01\x03\x01\x02\x07\x01\x12\x04\x97\x01\x0e\x15\n\x11\n\t\x04\0\x03\x01\
    \x03\x01\x02\x07\x03\x12\x04\x97\x01\x18\x19\n\xcb\x02\n\x06\x04\0\x03\
    \x01\x03\x02\x12\x06\x9f\x01\x04\xc6\x01\x05\x1a\xb8\x02\x20A\x20conditi\
    on\x20type\x20that\x20checks\x20that\x20monitored\x20resources\n\x20are\
    \x20reporting\x20data.\x20The\x20configuration\x20defines\x20a\x20metric\
    \x20and\n\x20a\x20set\x20of\x20monitored\x20resources.\x20The\x20predica\
    te\x20is\x20considered\x20in\x20violation\n\x20when\x20a\x20time\x20seri\
    es\x20for\x20the\x20specified\x20metric\x20of\x20a\x20monitored\n\x20res\
    ource\x20does\x20not\x20include\x20any\x20data\x20in\x20the\x20specified\
    \x20`duration`.\n\n\x0f\n\x07\x04\0\x03\x01\x03\x02\x01\x12\x04\x9f\x01\
    \x0c\x19\n\xaa\x04\n\x08\x04\0\x03\x01\x03\x02\x02\0\x12\x04\xaa\x01\x06\
    \x18\x1a\x97\x04\x20A\x20[filter](/monitoring/api/v3/filters)\x20that\n\
    \x20identifies\x20which\x20time\x20series\x20should\x20be\x20compared\
    \x20with\x20the\x20threshold.\n\n\x20The\x20filter\x20is\x20similar\x20t\
    o\x20the\x20one\x20that\x20is\x20specified\x20in\x20the\n\x20[`ListTimeS\
    eries`\n\x20request](/monitoring/api/ref_v3/rest/v3/projects.timeSeries/\
    list)\x20(that\n\x20call\x20is\x20useful\x20to\x20verify\x20the\x20time\
    \x20series\x20that\x20will\x20be\x20retrieved\x20/\n\x20processed)\x20an\
    d\x20must\x20specify\x20the\x20metric\x20type\x20and\x20optionally\x20ma\
    y\x20contain\n\x20restrictions\x20on\x20resource\x20type,\x20resource\
    \x20labels,\x20and\x20metric\x20labels.\n\x20This\x20field\x20may\x20not\
    \x20exceed\x202048\x20Unicode\x20characters\x20in\x20length.\n\n\x11\n\t\
    \x04\0\x03\x01\x03\x02\x02\0\x05\x12\x04\xaa\x01\x06\x0c\n\x11\n\t\x04\0\
    \x03\x01\x03\x02\x02\0\x01\x12\x04\xaa\x01\r\x13\n\x11\n\t\x04\0\x03\x01\
    \x03\x02\x02\0\x03\x12\x04\xaa\x01\x16\x17\n\xcb\x04\n\x08\x04\0\x03\x01\
    \x03\x02\x02\x01\x12\x04\xb7\x01\x06,\x1a\xb8\x04\x20Specifies\x20the\
    \x20alignment\x20of\x20data\x20points\x20in\x20individual\x20time\x20ser\
    ies\x20as\n\x20well\x20as\x20how\x20to\x20combine\x20the\x20retrieved\
    \x20time\x20series\x20together\x20(such\x20as\n\x20when\x20aggregating\
    \x20multiple\x20streams\x20on\x20each\x20resource\x20to\x20a\x20single\n\
    \x20stream\x20for\x20each\x20resource\x20or\x20when\x20aggregating\x20st\
    reams\x20across\x20all\n\x20members\x20of\x20a\x20group\x20of\x20resrouc\
    es).\x20Multiple\x20aggregations\n\x20are\x20applied\x20in\x20the\x20ord\
    er\x20specified.\n\n\x20This\x20field\x20is\x20similar\x20to\x20the\x20o\
    ne\x20in\x20the\x20[`ListTimeSeries`\n\x20request](/monitoring/api/ref_v\
    3/rest/v3/projects.timeSeries/list).\x20It\n\x20is\x20advisable\x20to\
    \x20use\x20the\x20`ListTimeSeries`\x20method\x20when\x20debugging\x20thi\
    s\n\x20field.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x04\x12\x04\xb7\
    \x01\x06\x0e\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x06\x12\x04\xb7\x01\
    \x0f\x1a\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x01\x12\x04\xb7\x01\x1b\
    '\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x01\x03\x12\x04\xb7\x01*+\n\xbc\
    \x02\n\x08\x04\0\x03\x01\x03\x02\x02\x02\x12\x04\xbf\x01\x06,\x1a\xa9\
    \x02\x20The\x20amount\x20of\x20time\x20that\x20a\x20time\x20series\x20mu\
    st\x20fail\x20to\x20report\x20new\n\x20data\x20to\x20be\x20considered\
    \x20failing.\x20Currently,\x20only\x20values\x20that\n\x20are\x20a\x20mu\
    ltiple\x20of\x20a\x20minute--e.g.\x20\x2060,\x20120,\x20or\x20300\n\x20s\
    econds--are\x20supported.\x20If\x20an\x20invalid\x20value\x20is\x20given\
    ,\x20an\n\x20error\x20will\x20be\x20returned.\x20The\x20`Duration.nanos`\
    \x20field\x20is\n\x20ignored.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\
    \x06\x12\x04\xbf\x01\x06\x1e\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\x01\
    \x12\x04\xbf\x01\x1f'\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x02\x03\x12\
    \x04\xbf\x01*+\n\xa2\x02\n\x08\x04\0\x03\x01\x03\x02\x02\x03\x12\x04\xc5\
    \x01\x06\x1a\x1a\x8f\x02\x20The\x20number/percent\x20of\x20time\x20serie\
    s\x20for\x20which\x20the\x20comparison\x20must\x20hold\n\x20in\x20order\
    \x20for\x20the\x20condition\x20to\x20trigger.\x20If\x20unspecified,\x20t\
    hen\x20the\n\x20condition\x20will\x20trigger\x20if\x20the\x20comparison\
    \x20is\x20true\x20for\x20any\x20of\x20the\n\x20time\x20series\x20that\
    \x20have\x20been\x20identified\x20by\x20`filter`\x20and\x20`aggregations\
    `.\n\n\x11\n\t\x04\0\x03\x01\x03\x02\x02\x03\x06\x12\x04\xc5\x01\x06\r\n\
    \x11\n\t\x04\0\x03\x01\x03\x02\x02\x03\x01\x12\x04\xc5\x01\x0e\x15\n\x11\
    \n\t\x04\0\x03\x01\x03\x02\x02\x03\x03\x12\x04\xc5\x01\x18\x19\n\x9e\t\n\
    \x06\x04\0\x03\x01\x02\0\x12\x04\xe1\x01\x04\x15\x1a\x8d\t\x20Required\
    \x20if\x20the\x20condition\x20exists.\x20The\x20unique\x20resource\x20na\
    me\x20for\x20this\n\x20condition.\x20Its\x20syntax\x20is:\n\n\x20\x20\
    \x20\x20\x20projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[\
    CONDITION_ID]\n\n\x20`[CONDITION_ID]`\x20is\x20assigned\x20by\x20Stackdr\
    iver\x20Monitoring\x20when\x20the\n\x20condition\x20is\x20created\x20as\
    \x20part\x20of\x20a\x20new\x20or\x20updated\x20alerting\x20policy.\n\n\
    \x20When\x20calling\x20the\n\x20[alertPolicies.create][google.monitoring\
    .v3.AlertPolicyService.CreateAlertPolicy]\n\x20method,\x20do\x20not\x20i\
    nclude\x20the\x20`name`\x20field\x20in\x20the\x20conditions\x20of\x20the\
    \n\x20requested\x20alerting\x20policy.\x20Stackdriver\x20Monitoring\x20c\
    reates\x20the\n\x20condition\x20identifiers\x20and\x20includes\x20them\
    \x20in\x20the\x20new\x20policy.\n\n\x20When\x20calling\x20the\n\x20[aler\
    tPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPol\
    icy]\n\x20method\x20to\x20update\x20a\x20policy,\x20including\x20a\x20co\
    ndition\x20`name`\x20causes\x20the\n\x20existing\x20condition\x20to\x20b\
    e\x20updated.\x20Conditions\x20without\x20names\x20are\x20added\x20to\n\
    \x20the\x20updated\x20policy.\x20Existing\x20conditions\x20are\x20delete\
    d\x20if\x20they\x20are\x20not\n\x20updated.\n\n\x20Best\x20practice\x20i\
    s\x20to\x20preserve\x20`[CONDITION_ID]`\x20if\x20you\x20make\x20only\x20\
    small\n\x20changes,\x20such\x20as\x20those\x20to\x20condition\x20thresho\
    lds,\x20durations,\x20or\x20trigger\n\x20values.\x20\x20Otherwise,\x20tr\
    eat\x20the\x20change\x20as\x20a\x20new\x20condition\x20and\x20let\x20the\
    \n\x20existing\x20condition\x20be\x20deleted.\n\n\x0f\n\x07\x04\0\x03\
    \x01\x02\0\x05\x12\x04\xe1\x01\x04\n\n\x0f\n\x07\x04\0\x03\x01\x02\0\x01\
    \x12\x04\xe1\x01\x0b\x0f\n\x0f\n\x07\x04\0\x03\x01\x02\0\x03\x12\x04\xe1\
    \x01\x12\x14\n\xd7\x01\n\x06\x04\0\x03\x01\x02\x01\x12\x04\xe6\x01\x04\
    \x1c\x1a\xc6\x01\x20A\x20short\x20name\x20or\x20phrase\x20used\x20to\x20\
    identify\x20the\x20condition\x20in\x20dashboards,\n\x20notifications,\
    \x20and\x20incidents.\x20To\x20avoid\x20confusion,\x20don't\x20use\x20th\
    e\x20same\n\x20display\x20name\x20for\x20multiple\x20conditions\x20in\
    \x20the\x20same\x20policy.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x05\x12\
    \x04\xe6\x01\x04\n\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x04\xe6\x01\
    \x0b\x17\n\x0f\n\x07\x04\0\x03\x01\x02\x01\x03\x12\x04\xe6\x01\x1a\x1b\n\
    P\n\x06\x04\0\x03\x01\x08\0\x12\x06\xe9\x01\x04\xf0\x01\x05\x1a>\x20Only\
    \x20one\x20of\x20the\x20following\x20condition\x20types\x20will\x20be\
    \x20specified.\n\n\x0f\n\x07\x04\0\x03\x01\x08\0\x01\x12\x04\xe9\x01\n\
    \x13\nN\n\x06\x04\0\x03\x01\x02\x02\x12\x04\xeb\x01\x06.\x1a>\x20A\x20co\
    ndition\x20that\x20compares\x20a\x20time\x20series\x20against\x20a\x20th\
    reshold.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x06\x12\x04\xeb\x01\x06\x15\
    \n\x0f\n\x07\x04\0\x03\x01\x02\x02\x01\x12\x04\xeb\x01\x16)\n\x0f\n\x07\
    \x04\0\x03\x01\x02\x02\x03\x12\x04\xeb\x01,-\nc\n\x06\x04\0\x03\x01\x02\
    \x03\x12\x04\xef\x01\x06)\x1aS\x20A\x20condition\x20that\x20checks\x20th\
    at\x20a\x20time\x20series\x20continues\x20to\n\x20receive\x20new\x20data\
    \x20points.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x04\xef\x01\x06\
    \x13\n\x0f\n\x07\x04\0\x03\x01\x02\x03\x01\x12\x04\xef\x01\x14$\n\x0f\n\
    \x07\x04\0\x03\x01\x02\x03\x03\x12\x04\xef\x01'(\n5\n\x04\x04\0\x04\0\
    \x12\x06\xf4\x01\x02\x86\x02\x03\x1a%\x20Operators\x20for\x20combining\
    \x20conditions.\n\n\r\n\x05\x04\0\x04\0\x01\x12\x04\xf4\x01\x07\x1c\n*\n\
    \x06\x04\0\x04\0\x02\0\x12\x04\xf6\x01\x04\x1c\x1a\x1a\x20An\x20unspecif\
    ied\x20combiner.\n\n\x0f\n\x07\x04\0\x04\0\x02\0\x01\x12\x04\xf6\x01\x04\
    \x17\n\x0f\n\x07\x04\0\x04\0\x02\0\x02\x12\x04\xf6\x01\x1a\x1b\n\xfe\x01\
    \n\x06\x04\0\x04\0\x02\x01\x12\x04\xfc\x01\x04\x0c\x1a\xed\x01\x20Combin\
    e\x20conditions\x20using\x20the\x20logical\x20`AND`\x20operator.\x20An\n\
    \x20incident\x20is\x20created\x20only\x20if\x20all\x20conditions\x20are\
    \x20met\n\x20simultaneously.\x20This\x20combiner\x20is\x20satisfied\x20i\
    f\x20all\x20conditions\x20are\n\x20met,\x20even\x20if\x20they\x20are\x20\
    met\x20on\x20completely\x20different\x20resources.\n\n\x0f\n\x07\x04\0\
    \x04\0\x02\x01\x01\x12\x04\xfc\x01\x04\x07\n\x0f\n\x07\x04\0\x04\0\x02\
    \x01\x02\x12\x04\xfc\x01\n\x0b\n\x85\x01\n\x06\x04\0\x04\0\x02\x02\x12\
    \x04\x80\x02\x04\x0b\x1au\x20Combine\x20conditions\x20using\x20the\x20lo\
    gical\x20`OR`\x20operator.\x20An\x20incident\n\x20is\x20created\x20if\
    \x20any\x20of\x20the\x20listed\x20conditions\x20is\x20met.\n\n\x0f\n\x07\
    \x04\0\x04\0\x02\x02\x01\x12\x04\x80\x02\x04\x06\n\x0f\n\x07\x04\0\x04\0\
    \x02\x02\x02\x12\x04\x80\x02\t\n\n\xc9\x01\n\x06\x04\0\x04\0\x02\x03\x12\
    \x04\x85\x02\x04#\x1a\xb8\x01\x20Combine\x20conditions\x20using\x20logic\
    al\x20`AND`\x20operator,\x20but\x20unlike\x20the\x20regular\n\x20`AND`\
    \x20option,\x20an\x20incident\x20is\x20created\x20only\x20if\x20all\x20c\
    onditions\x20are\x20met\n\x20simultaneously\x20on\x20at\x20least\x20one\
    \x20resource.\n\n\x0f\n\x07\x04\0\x04\0\x02\x03\x01\x12\x04\x85\x02\x04\
    \x1e\n\x0f\n\x07\x04\0\x04\0\x02\x03\x02\x12\x04\x85\x02!\"\n\xbc\x03\n\
    \x04\x04\0\x02\0\x12\x04\x92\x02\x02\x12\x1a\xad\x03\x20Required\x20if\
    \x20the\x20policy\x20exists.\x20The\x20resource\x20name\x20for\x20this\
    \x20policy.\x20The\n\x20syntax\x20is:\n\n\x20\x20\x20\x20\x20projects/[P\
    ROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]\n\n\x20`[ALERT_POLICY_ID]`\
    \x20is\x20assigned\x20by\x20Stackdriver\x20Monitoring\x20when\x20the\x20\
    policy\n\x20is\x20created.\x20\x20When\x20calling\x20the\n\x20[alertPoli\
    cies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]\
    \n\x20method,\x20do\x20not\x20include\x20the\x20`name`\x20field\x20in\
    \x20the\x20alerting\x20policy\x20passed\x20as\n\x20part\x20of\x20the\x20\
    request.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x92\x02\x02\x08\n\r\n\x05\
    \x04\0\x02\0\x01\x12\x04\x92\x02\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\
    \x92\x02\x10\x11\n\x81\x02\n\x04\x04\0\x02\x01\x12\x04\x98\x02\x02\x1a\
    \x1a\xf2\x01\x20A\x20short\x20name\x20or\x20phrase\x20used\x20to\x20iden\
    tify\x20the\x20policy\x20in\x20dashboards,\n\x20notifications,\x20and\
    \x20incidents.\x20To\x20avoid\x20confusion,\x20don't\x20use\x20the\x20sa\
    me\n\x20display\x20name\x20for\x20multiple\x20policies\x20in\x20the\x20s\
    ame\x20project.\x20The\x20name\x20is\n\x20limited\x20to\x20512\x20Unicod\
    e\x20characters.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x98\x02\x02\x08\n\
    \r\n\x05\x04\0\x02\x01\x01\x12\x04\x98\x02\t\x15\n\r\n\x05\x04\0\x02\x01\
    \x03\x12\x04\x98\x02\x18\x19\n\xf6\x02\n\x04\x04\0\x02\x02\x12\x04\x9f\
    \x02\x02#\x1a\xe7\x02\x20Documentation\x20that\x20is\x20included\x20with\
    \x20notifications\x20and\x20incidents\x20related\x20to\n\x20this\x20poli\
    cy.\x20Best\x20practice\x20is\x20for\x20the\x20documentation\x20to\x20in\
    clude\x20information\n\x20to\x20help\x20responders\x20understand,\x20mit\
    igate,\x20escalate,\x20and\x20correct\x20the\n\x20underlying\x20problems\
    \x20detected\x20by\x20the\x20alerting\x20policy.\x20Notification\x20chan\
    nels\n\x20that\x20have\x20limited\x20capacity\x20might\x20not\x20show\
    \x20this\x20documentation.\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x9f\x02\
    \x02\x0f\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x9f\x02\x10\x1d\n\r\n\x05\
    \x04\0\x02\x02\x03\x12\x04\x9f\x02\x20\"\n\xf3\x02\n\x04\x04\0\x02\x03\
    \x12\x04\xa8\x02\x02'\x1a\xe4\x02\x20User-supplied\x20key/value\x20data\
    \x20to\x20be\x20used\x20for\x20organizing\x20and\n\x20identifying\x20the\
    \x20`AlertPolicy`\x20objects.\n\n\x20The\x20field\x20can\x20contain\x20u\
    p\x20to\x2064\x20entries.\x20Each\x20key\x20and\x20value\x20is\x20limite\
    d\x20to\n\x2063\x20Unicode\x20characters\x20or\x20128\x20bytes,\x20which\
    ever\x20is\x20smaller.\x20Labels\x20and\n\x20values\x20can\x20contain\
    \x20only\x20lowercase\x20letters,\x20numerals,\x20underscores,\x20and\n\
    \x20dashes.\x20Keys\x20must\x20begin\x20with\x20a\x20letter.\n\n\r\n\x05\
    \x04\0\x02\x03\x06\x12\x04\xa8\x02\x02\x15\n\r\n\x05\x04\0\x02\x03\x01\
    \x12\x04\xa8\x02\x16!\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xa8\x02$&\n\
    \xfc\x01\n\x04\x04\0\x02\x04\x12\x04\xae\x02\x02%\x1a\xed\x01\x20A\x20li\
    st\x20of\x20conditions\x20for\x20the\x20policy.\x20The\x20conditions\x20\
    are\x20combined\x20by\x20AND\x20or\n\x20OR\x20according\x20to\x20the\x20\
    `combiner`\x20field.\x20If\x20the\x20combined\x20conditions\x20evaluate\
    \n\x20to\x20true,\x20then\x20an\x20incident\x20is\x20created.\x20A\x20po\
    licy\x20can\x20have\x20from\x20one\x20to\x20six\n\x20conditions.\n\n\r\n\
    \x05\x04\0\x02\x04\x04\x12\x04\xae\x02\x02\n\n\r\n\x05\x04\0\x02\x04\x06\
    \x12\x04\xae\x02\x0b\x14\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\xae\x02\x15\
    \x1f\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xae\x02\"$\np\n\x04\x04\0\x02\
    \x05\x12\x04\xb2\x02\x02%\x1ab\x20How\x20to\x20combine\x20the\x20results\
    \x20of\x20multiple\x20conditions\n\x20to\x20determine\x20if\x20an\x20inc\
    ident\x20should\x20be\x20opened.\n\n\r\n\x05\x04\0\x02\x05\x06\x12\x04\
    \xb2\x02\x02\x17\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xb2\x02\x18\x20\n\r\
    \n\x05\x04\0\x02\x05\x03\x12\x04\xb2\x02#$\n\xe7\x02\n\x04\x04\0\x02\x06\
    \x12\x04\xb9\x02\x02)\x1a\xd8\x02\x20Whether\x20or\x20not\x20the\x20poli\
    cy\x20is\x20enabled.\x20On\x20write,\x20the\x20default\x20interpretation\
    \n\x20if\x20unset\x20is\x20that\x20the\x20policy\x20is\x20enabled.\x20On\
    \x20read,\x20clients\x20should\x20not\x20make\n\x20any\x20assumption\x20\
    about\x20the\x20state\x20if\x20it\x20has\x20not\x20been\x20populated.\
    \x20The\n\x20field\x20should\x20always\x20be\x20populated\x20on\x20List\
    \x20and\x20Get\x20operations,\x20unless\n\x20a\x20field\x20projection\
    \x20has\x20been\x20specified\x20that\x20strips\x20it\x20out.\n\n\r\n\x05\
    \x04\0\x02\x06\x06\x12\x04\xb9\x02\x02\x1b\n\r\n\x05\x04\0\x02\x06\x01\
    \x12\x04\xb9\x02\x1c#\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\xb9\x02&(\n\
    \xa5\x01\n\x04\x04\0\x02\x07\x12\x04\xbd\x02\x02\"\x1a\x96\x01\x20Read-o\
    nly\x20description\x20of\x20how\x20the\x20alert\x20policy\x20is\x20inval\
    id.\x20OK\x20if\x20the\x20alert\n\x20policy\x20is\x20valid.\x20If\x20not\
    \x20OK,\x20the\x20alert\x20policy\x20will\x20not\x20generate\x20incident\
    s.\n\n\r\n\x05\x04\0\x02\x07\x06\x12\x04\xbd\x02\x02\x13\n\r\n\x05\x04\0\
    \x02\x07\x01\x12\x04\xbd\x02\x14\x1c\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\
    \xbd\x02\x1f!\n\xcb\x04\n\x04\x04\0\x02\x08\x12\x04\xc9\x02\x02-\x1a\xbc\
    \x04\x20Identifies\x20the\x20notification\x20channels\x20to\x20which\x20\
    notifications\x20should\x20be\x20sent\n\x20when\x20incidents\x20are\x20o\
    pened\x20or\x20closed\x20or\x20when\x20new\x20violations\x20occur\x20on\
    \n\x20an\x20already\x20opened\x20incident.\x20Each\x20element\x20of\x20t\
    his\x20array\x20corresponds\x20to\n\x20the\x20`name`\x20field\x20in\x20e\
    ach\x20of\x20the\n\x20[`NotificationChannel`][google.monitoring.v3.Notif\
    icationChannel]\n\x20objects\x20that\x20are\x20returned\x20from\x20the\
    \x20[`ListNotificationChannels`]\n\x20[google.monitoring.v3.Notification\
    ChannelService.ListNotificationChannels]\n\x20method.\x20The\x20syntax\
    \x20of\x20the\x20entries\x20in\x20this\x20field\x20is:\n\n\x20\x20\x20\
    \x20\x20projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]\n\n\r\n\
    \x05\x04\0\x02\x08\x04\x12\x04\xc9\x02\x02\n\n\r\n\x05\x04\0\x02\x08\x05\
    \x12\x04\xc9\x02\x0b\x11\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\xc9\x02\x12\
    '\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\xc9\x02*,\n\x93\x01\n\x04\x04\0\
    \x02\t\x12\x04\xcd\x02\x02&\x1a\x84\x01\x20A\x20read-only\x20record\x20o\
    f\x20the\x20creation\x20of\x20the\x20alerting\x20policy.\x20If\x20provid\
    ed\n\x20in\x20a\x20call\x20to\x20create\x20or\x20update,\x20this\x20fiel\
    d\x20will\x20be\x20ignored.\n\n\r\n\x05\x04\0\x02\t\x06\x12\x04\xcd\x02\
    \x02\x10\n\r\n\x05\x04\0\x02\t\x01\x12\x04\xcd\x02\x11\x20\n\r\n\x05\x04\
    \0\x02\t\x03\x12\x04\xcd\x02#%\n\x9d\x01\n\x04\x04\0\x02\n\x12\x04\xd1\
    \x02\x02&\x1a\x8e\x01\x20A\x20read-only\x20record\x20of\x20the\x20most\
    \x20recent\x20change\x20to\x20the\x20alerting\x20policy.\x20If\n\x20prov\
    ided\x20in\x20a\x20call\x20to\x20create\x20or\x20update,\x20this\x20fiel\
    d\x20will\x20be\x20ignored.\n\n\r\n\x05\x04\0\x02\n\x06\x12\x04\xd1\x02\
    \x02\x10\n\r\n\x05\x04\0\x02\n\x01\x12\x04\xd1\x02\x11\x20\n\r\n\x05\x04\
    \0\x02\n\x03\x12\x04\xd1\x02#%b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
