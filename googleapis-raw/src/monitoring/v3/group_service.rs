// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/monitoring/v3/group_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupsRequest {
    // message fields
    pub name: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // message oneof groups
    pub filter: ::std::option::Option<ListGroupsRequest_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGroupsRequest {
    fn default() -> &'a ListGroupsRequest {
        <ListGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ListGroupsRequest_oneof_filter {
    children_of_group(::std::string::String),
    ancestors_of_group(::std::string::String),
    descendants_of_group(::std::string::String),
}

impl ListGroupsRequest {
    pub fn new() -> ListGroupsRequest {
        ::std::default::Default::default()
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string children_of_group = 2;


    pub fn get_children_of_group(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_children_of_group(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_children_of_group(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_children_of_group(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_children_of_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_children_of_group(&mut self) -> ::std::string::String {
        if self.has_children_of_group() {
            match self.filter.take() {
                ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string ancestors_of_group = 3;


    pub fn get_ancestors_of_group(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_ancestors_of_group(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_ancestors_of_group(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ancestors_of_group(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ancestors_of_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ancestors_of_group(&mut self) -> ::std::string::String {
        if self.has_ancestors_of_group() {
            match self.filter.take() {
                ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string descendants_of_group = 4;


    pub fn get_descendants_of_group(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_descendants_of_group(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_descendants_of_group(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_descendants_of_group(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_descendants_of_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_descendants_of_group(&mut self) -> ::std::string::String {
        if self.has_descendants_of_group() {
            match self.filter.take() {
                ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 page_size = 5;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 6;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListGroupsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::children_of_group(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::ancestors_of_group(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ListGroupsRequest_oneof_filter::descendants_of_group(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.page_token);
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ListGroupsRequest_oneof_filter::children_of_group(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &ListGroupsRequest_oneof_filter::ancestors_of_group(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &ListGroupsRequest_oneof_filter::descendants_of_group(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        if self.page_size != 0 {
            os.write_int32(5, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(6, &self.page_token)?;
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ListGroupsRequest_oneof_filter::children_of_group(ref v) => {
                    os.write_string(2, v)?;
                },
                &ListGroupsRequest_oneof_filter::ancestors_of_group(ref v) => {
                    os.write_string(3, v)?;
                },
                &ListGroupsRequest_oneof_filter::descendants_of_group(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupsRequest {
        ListGroupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListGroupsRequest| { &m.name },
                |m: &mut ListGroupsRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "children_of_group",
                ListGroupsRequest::has_children_of_group,
                ListGroupsRequest::get_children_of_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "ancestors_of_group",
                ListGroupsRequest::has_ancestors_of_group,
                ListGroupsRequest::get_ancestors_of_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "descendants_of_group",
                ListGroupsRequest::has_descendants_of_group,
                ListGroupsRequest::get_descendants_of_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListGroupsRequest| { &m.page_size },
                |m: &mut ListGroupsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListGroupsRequest| { &m.page_token },
                |m: &mut ListGroupsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGroupsRequest>(
                "ListGroupsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGroupsRequest {
        static instance: ::protobuf::rt::LazyV2<ListGroupsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGroupsRequest::new)
    }
}

impl ::protobuf::Clear for ListGroupsRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupsResponse {
    // message fields
    pub group: ::protobuf::RepeatedField<super::group::Group>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGroupsResponse {
    fn default() -> &'a ListGroupsResponse {
        <ListGroupsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListGroupsResponse {
    pub fn new() -> ListGroupsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.monitoring.v3.Group group = 1;


    pub fn get_group(&self) -> &[super::group::Group] {
        &self.group
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::protobuf::RepeatedField<super::group::Group>) {
        self.group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut ::protobuf::RepeatedField<super::group::Group> {
        &mut self.group
    }

    // Take field
    pub fn take_group(&mut self) -> ::protobuf::RepeatedField<super::group::Group> {
        ::std::mem::replace(&mut self.group, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListGroupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.group {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupsResponse {
        ListGroupsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::group::Group>>(
                "group",
                |m: &ListGroupsResponse| { &m.group },
                |m: &mut ListGroupsResponse| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListGroupsResponse| { &m.next_page_token },
                |m: &mut ListGroupsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGroupsResponse>(
                "ListGroupsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGroupsResponse {
        static instance: ::protobuf::rt::LazyV2<ListGroupsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGroupsResponse::new)
    }
}

impl ::protobuf::Clear for ListGroupsResponse {
    fn clear(&mut self) {
        self.group.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetGroupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetGroupRequest {
    fn default() -> &'a GetGroupRequest {
        <GetGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetGroupRequest {
    pub fn new() -> GetGroupRequest {
        ::std::default::Default::default()
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetGroupRequest {
        GetGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetGroupRequest| { &m.name },
                |m: &mut GetGroupRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetGroupRequest>(
                "GetGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetGroupRequest {
        static instance: ::protobuf::rt::LazyV2<GetGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetGroupRequest::new)
    }
}

impl ::protobuf::Clear for GetGroupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateGroupRequest {
    // message fields
    pub name: ::std::string::String,
    pub group: ::protobuf::SingularPtrField<super::group::Group>,
    pub validate_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateGroupRequest {
    fn default() -> &'a CreateGroupRequest {
        <CreateGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateGroupRequest {
    pub fn new() -> CreateGroupRequest {
        ::std::default::Default::default()
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.monitoring.v3.Group group = 2;


    pub fn get_group(&self) -> &super::group::Group {
        self.group.as_ref().unwrap_or_else(|| <super::group::Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: super::group::Group) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut super::group::Group {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> super::group::Group {
        self.group.take().unwrap_or_else(|| super::group::Group::new())
    }

    // bool validate_only = 3;


    pub fn get_validate_only(&self) -> bool {
        self.validate_only
    }
    pub fn clear_validate_only(&mut self) {
        self.validate_only = false;
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = v;
    }
}

impl ::protobuf::Message for CreateGroupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.validate_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.validate_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.validate_only != false {
            os.write_bool(3, self.validate_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateGroupRequest {
        CreateGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateGroupRequest| { &m.name },
                |m: &mut CreateGroupRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::group::Group>>(
                "group",
                |m: &CreateGroupRequest| { &m.group },
                |m: &mut CreateGroupRequest| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "validate_only",
                |m: &CreateGroupRequest| { &m.validate_only },
                |m: &mut CreateGroupRequest| { &mut m.validate_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateGroupRequest>(
                "CreateGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateGroupRequest {
        static instance: ::protobuf::rt::LazyV2<CreateGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateGroupRequest::new)
    }
}

impl ::protobuf::Clear for CreateGroupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.group.clear();
        self.validate_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateGroupRequest {
    // message fields
    pub group: ::protobuf::SingularPtrField<super::group::Group>,
    pub validate_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateGroupRequest {
    fn default() -> &'a UpdateGroupRequest {
        <UpdateGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateGroupRequest {
    pub fn new() -> UpdateGroupRequest {
        ::std::default::Default::default()
    }

    // .google.monitoring.v3.Group group = 2;


    pub fn get_group(&self) -> &super::group::Group {
        self.group.as_ref().unwrap_or_else(|| <super::group::Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: super::group::Group) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut super::group::Group {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> super::group::Group {
        self.group.take().unwrap_or_else(|| super::group::Group::new())
    }

    // bool validate_only = 3;


    pub fn get_validate_only(&self) -> bool {
        self.validate_only
    }
    pub fn clear_validate_only(&mut self) {
        self.validate_only = false;
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = v;
    }
}

impl ::protobuf::Message for UpdateGroupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.validate_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.validate_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.validate_only != false {
            os.write_bool(3, self.validate_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateGroupRequest {
        UpdateGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::group::Group>>(
                "group",
                |m: &UpdateGroupRequest| { &m.group },
                |m: &mut UpdateGroupRequest| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "validate_only",
                |m: &UpdateGroupRequest| { &m.validate_only },
                |m: &mut UpdateGroupRequest| { &mut m.validate_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateGroupRequest>(
                "UpdateGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateGroupRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateGroupRequest::new)
    }
}

impl ::protobuf::Clear for UpdateGroupRequest {
    fn clear(&mut self) {
        self.group.clear();
        self.validate_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteGroupRequest {
    // message fields
    pub name: ::std::string::String,
    pub recursive: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteGroupRequest {
    fn default() -> &'a DeleteGroupRequest {
        <DeleteGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteGroupRequest {
    pub fn new() -> DeleteGroupRequest {
        ::std::default::Default::default()
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool recursive = 4;


    pub fn get_recursive(&self) -> bool {
        self.recursive
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = false;
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = v;
    }
}

impl ::protobuf::Message for DeleteGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.recursive != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.recursive != false {
            os.write_bool(4, self.recursive)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteGroupRequest {
        DeleteGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteGroupRequest| { &m.name },
                |m: &mut DeleteGroupRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recursive",
                |m: &DeleteGroupRequest| { &m.recursive },
                |m: &mut DeleteGroupRequest| { &mut m.recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteGroupRequest>(
                "DeleteGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteGroupRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteGroupRequest::new)
    }
}

impl ::protobuf::Clear for DeleteGroupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.recursive = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupMembersRequest {
    // message fields
    pub name: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub filter: ::std::string::String,
    pub interval: ::protobuf::SingularPtrField<super::common::TimeInterval>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGroupMembersRequest {
    fn default() -> &'a ListGroupMembersRequest {
        <ListGroupMembersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListGroupMembersRequest {
    pub fn new() -> ListGroupMembersRequest {
        ::std::default::Default::default()
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string filter = 5;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // .google.monitoring.v3.TimeInterval interval = 6;


    pub fn get_interval(&self) -> &super::common::TimeInterval {
        self.interval.as_ref().unwrap_or_else(|| <super::common::TimeInterval as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interval(&mut self) {
        self.interval.clear();
    }

    pub fn has_interval(&self) -> bool {
        self.interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: super::common::TimeInterval) {
        self.interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interval(&mut self) -> &mut super::common::TimeInterval {
        if self.interval.is_none() {
            self.interval.set_default();
        }
        self.interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_interval(&mut self) -> super::common::TimeInterval {
        self.interval.take().unwrap_or_else(|| super::common::TimeInterval::new())
    }
}

impl ::protobuf::Message for ListGroupMembersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.filter);
        }
        if let Some(ref v) = self.interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        if !self.filter.is_empty() {
            os.write_string(5, &self.filter)?;
        }
        if let Some(ref v) = self.interval.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupMembersRequest {
        ListGroupMembersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListGroupMembersRequest| { &m.name },
                |m: &mut ListGroupMembersRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListGroupMembersRequest| { &m.page_size },
                |m: &mut ListGroupMembersRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListGroupMembersRequest| { &m.page_token },
                |m: &mut ListGroupMembersRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListGroupMembersRequest| { &m.filter },
                |m: &mut ListGroupMembersRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::TimeInterval>>(
                "interval",
                |m: &ListGroupMembersRequest| { &m.interval },
                |m: &mut ListGroupMembersRequest| { &mut m.interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGroupMembersRequest>(
                "ListGroupMembersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGroupMembersRequest {
        static instance: ::protobuf::rt::LazyV2<ListGroupMembersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGroupMembersRequest::new)
    }
}

impl ::protobuf::Clear for ListGroupMembersRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.filter.clear();
        self.interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupMembersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupMembersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListGroupMembersResponse {
    // message fields
    pub members: ::protobuf::RepeatedField<super::monitored_resource::MonitoredResource>,
    pub next_page_token: ::std::string::String,
    pub total_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListGroupMembersResponse {
    fn default() -> &'a ListGroupMembersResponse {
        <ListGroupMembersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListGroupMembersResponse {
    pub fn new() -> ListGroupMembersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.MonitoredResource members = 1;


    pub fn get_members(&self) -> &[super::monitored_resource::MonitoredResource] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<super::monitored_resource::MonitoredResource>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<super::monitored_resource::MonitoredResource> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<super::monitored_resource::MonitoredResource> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    // int32 total_size = 3;


    pub fn get_total_size(&self) -> i32 {
        self.total_size
    }
    pub fn clear_total_size(&mut self) {
        self.total_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_size(&mut self, v: i32) {
        self.total_size = v;
    }
}

impl ::protobuf::Message for ListGroupMembersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        if self.total_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.members {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        if self.total_size != 0 {
            os.write_int32(3, self.total_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListGroupMembersResponse {
        ListGroupMembersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::monitored_resource::MonitoredResource>>(
                "members",
                |m: &ListGroupMembersResponse| { &m.members },
                |m: &mut ListGroupMembersResponse| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListGroupMembersResponse| { &m.next_page_token },
                |m: &mut ListGroupMembersResponse| { &mut m.next_page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_size",
                |m: &ListGroupMembersResponse| { &m.total_size },
                |m: &mut ListGroupMembersResponse| { &mut m.total_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListGroupMembersResponse>(
                "ListGroupMembersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListGroupMembersResponse {
        static instance: ::protobuf::rt::LazyV2<ListGroupMembersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListGroupMembersResponse::new)
    }
}

impl ::protobuf::Clear for ListGroupMembersResponse {
    fn clear(&mut self) {
        self.members.clear();
        self.next_page_token.clear();
        self.total_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListGroupMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListGroupMembersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(google/monitoring/v3/group_service.proto\x12\x14google.monitoring.v3\
    \x1a\x1cgoogle/api/annotations.proto\x1a#google/api/monitored_resource.p\
    roto\x1a!google/monitoring/v3/common.proto\x1a\x20google/monitoring/v3/g\
    roup.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17google/api/client.p\
    roto\"\xff\x01\n\x11ListGroupsRequest\x12\x12\n\x04name\x18\x07\x20\x01(\
    \tR\x04name\x12,\n\x11children_of_group\x18\x02\x20\x01(\tH\0R\x0fchildr\
    enOfGroup\x12.\n\x12ancestors_of_group\x18\x03\x20\x01(\tH\0R\x10ancesto\
    rsOfGroup\x122\n\x14descendants_of_group\x18\x04\x20\x01(\tH\0R\x12desce\
    ndantsOfGroup\x12\x1b\n\tpage_size\x18\x05\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x06\x20\x01(\tR\tpageTokenB\x08\n\x06filter\"o\n\
    \x12ListGroupsResponse\x121\n\x05group\x18\x01\x20\x03(\x0b2\x1b.google.\
    monitoring.v3.GroupR\x05group\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\
    \tR\rnextPageToken\"%\n\x0fGetGroupRequest\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\"\x80\x01\n\x12CreateGroupRequest\x12\x12\n\x04name\x18\
    \x04\x20\x01(\tR\x04name\x121\n\x05group\x18\x02\x20\x01(\x0b2\x1b.googl\
    e.monitoring.v3.GroupR\x05group\x12#\n\rvalidate_only\x18\x03\x20\x01(\
    \x08R\x0cvalidateOnly\"l\n\x12UpdateGroupRequest\x121\n\x05group\x18\x02\
    \x20\x01(\x0b2\x1b.google.monitoring.v3.GroupR\x05group\x12#\n\rvalidate\
    _only\x18\x03\x20\x01(\x08R\x0cvalidateOnly\"F\n\x12DeleteGroupRequest\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1c\n\trecursive\x18\
    \x04\x20\x01(\x08R\trecursive\"\xc1\x01\n\x17ListGroupMembersRequest\x12\
    \x12\n\x04name\x18\x07\x20\x01(\tR\x04name\x12\x1b\n\tpage_size\x18\x03\
    \x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpa\
    geToken\x12\x16\n\x06filter\x18\x05\x20\x01(\tR\x06filter\x12>\n\x08inte\
    rval\x18\x06\x20\x01(\x0b2\".google.monitoring.v3.TimeIntervalR\x08inter\
    val\"\x9a\x01\n\x18ListGroupMembersResponse\x127\n\x07members\x18\x01\
    \x20\x03(\x0b2\x1d.google.api.MonitoredResourceR\x07members\x12&\n\x0fne\
    xt_page_token\x18\x02\x20\x01(\tR\rnextPageToken\x12\x1d\n\ntotal_size\
    \x18\x03\x20\x01(\x05R\ttotalSize2\xe7\x07\n\x0cGroupService\x12\x85\x01\
    \n\nListGroups\x12'.google.monitoring.v3.ListGroupsRequest\x1a(.google.m\
    onitoring.v3.ListGroupsResponse\"$\x82\xd3\xe4\x93\x02\x1e\x12\x1c/v3/{n\
    ame=projects/*}/groups\x12v\n\x08GetGroup\x12%.google.monitoring.v3.GetG\
    roupRequest\x1a\x1b.google.monitoring.v3.Group\"&\x82\xd3\xe4\x93\x02\
    \x20\x12\x1e/v3/{name=projects/*/groups/*}\x12\x81\x01\n\x0bCreateGroup\
    \x12(.google.monitoring.v3.CreateGroupRequest\x1a\x1b.google.monitoring.\
    v3.Group\"+\x82\xd3\xe4\x93\x02%\"\x1c/v3/{name=projects/*}/groups:\x05g\
    roup\x12\x89\x01\n\x0bUpdateGroup\x12(.google.monitoring.v3.UpdateGroupR\
    equest\x1a\x1b.google.monitoring.v3.Group\"3\x82\xd3\xe4\x93\x02-\x1a$/v\
    3/{group.name=projects/*/groups/*}:\x05group\x12w\n\x0bDeleteGroup\x12(.\
    google.monitoring.v3.DeleteGroupRequest\x1a\x16.google.protobuf.Empty\"&\
    \x82\xd3\xe4\x93\x02\x20*\x1e/v3/{name=projects/*/groups/*}\x12\xa1\x01\
    \n\x10ListGroupMembers\x12-.google.monitoring.v3.ListGroupMembersRequest\
    \x1a..google.monitoring.v3.ListGroupMembersResponse\".\x82\xd3\xe4\x93\
    \x02(\x12&/v3/{name=projects/*/groups/*}/members\x1a\xa9\x01\xd2A\x89\
    \x01https://www.googleapis.com/auth/cloud-platform,https://www.googleapi\
    s.com/auth/monitoring,https://www.googleapis.com/auth/monitoring.read\
    \xcaA\x19monitoring.googleapis.comB\xa9\x01\n\x18com.google.monitoring.v\
    3B\x11GroupServiceProtoP\x01Z>google.golang.org/genproto/googleapis/moni\
    toring/v3;monitoring\xaa\x02\x1aGoogle.Cloud.Monitoring.V3\xca\x02\x1aGo\
    ogle\\Cloud\\Monitoring\\V3J\xae?\n\x07\x12\x05\x0f\0\xe9\x01\x01\n\xbe\
    \x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\
    \x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Versio\
    n\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20Y\
    ou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\
    \x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\
    \x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20w\
    riting,\x20software\n\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WA\
    RRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\
    \x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1d\n\t\n\x02\x03\
    \0\x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0-\n\t\n\x02\x03\x02\x12\
    \x03\x15\0+\n\t\n\x02\x03\x03\x12\x03\x16\0*\n\t\n\x02\x03\x04\x12\x03\
    \x17\0%\n\t\n\x02\x03\x05\x12\x03\x18\0!\n\x08\n\x01\x08\x12\x03\x1a\07\
    \n\t\n\x02\x08%\x12\x03\x1a\07\n\x08\n\x01\x08\x12\x03\x1b\0U\n\t\n\x02\
    \x08\x0b\x12\x03\x1b\0U\n\x08\n\x01\x08\x12\x03\x1c\0\"\n\t\n\x02\x08\n\
    \x12\x03\x1c\0\"\n\x08\n\x01\x08\x12\x03\x1d\02\n\t\n\x02\x08\x08\x12\
    \x03\x1d\02\n\x08\n\x01\x08\x12\x03\x1e\01\n\t\n\x02\x08\x01\x12\x03\x1e\
    \01\n\x08\n\x01\x08\x12\x03\x1f\07\n\t\n\x02\x08)\x12\x03\x1f\07\n\x84\
    \x05\n\x02\x06\0\x12\x04-\0`\x01\x1a\xf7\x04\x20The\x20Group\x20API\x20l\
    ets\x20you\x20inspect\x20and\x20manage\x20your\n\x20[groups](#google.mon\
    itoring.v3.Group).\n\n\x20A\x20group\x20is\x20a\x20named\x20filter\x20th\
    at\x20is\x20used\x20to\x20identify\n\x20a\x20collection\x20of\x20monitor\
    ed\x20resources.\x20Groups\x20are\x20typically\x20used\x20to\n\x20mirror\
    \x20the\x20physical\x20and/or\x20logical\x20topology\x20of\x20the\x20env\
    ironment.\n\x20Because\x20group\x20membership\x20is\x20computed\x20dynam\
    ically,\x20monitored\n\x20resources\x20that\x20are\x20started\x20in\x20t\
    he\x20future\x20are\x20automatically\x20placed\n\x20in\x20matching\x20gr\
    oups.\x20By\x20using\x20a\x20group\x20to\x20name\x20monitored\x20resourc\
    es\x20in,\n\x20for\x20example,\x20an\x20alert\x20policy,\x20the\x20targe\
    t\x20of\x20that\x20alert\x20policy\x20is\n\x20updated\x20automatically\
    \x20as\x20monitored\x20resources\x20are\x20added\x20and\x20removed\n\x20\
    from\x20the\x20infrastructure.\n\n\n\n\x03\x06\0\x01\x12\x03-\x08\x14\n\
    \n\n\x03\x06\0\x03\x12\x03.\x02A\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x03.\
    \x02A\n\x0b\n\x03\x06\0\x03\x12\x04/\x0228\n\r\n\x05\x06\0\x03\x9a\x08\
    \x12\x04/\x0228\n*\n\x04\x06\0\x02\0\x12\x045\x029\x03\x1a\x1c\x20Lists\
    \x20the\x20existing\x20groups.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x035\
    \x06\x10\n\x0c\n\x05\x06\0\x02\0\x02\x12\x035\x11\"\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x035-?\n\r\n\x05\x06\0\x02\0\x04\x12\x046\x048\x06\n\x11\
    \n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x046\x048\x06\n$\n\x04\x06\0\x02\
    \x01\x12\x04<\x02@\x03\x1a\x16\x20Gets\x20a\x20single\x20group.\n\n\x0c\
    \n\x05\x06\0\x02\x01\x01\x12\x03<\x06\x0e\n\x0c\n\x05\x06\0\x02\x01\x02\
    \x12\x03<\x0f\x1e\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03<).\n\r\n\x05\x06\
    \0\x02\x01\x04\x12\x04=\x04?\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\
    \"\x12\x04=\x04?\x06\n$\n\x04\x06\0\x02\x02\x12\x04C\x02H\x03\x1a\x16\
    \x20Creates\x20a\x20new\x20group.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\
    \x03C\x06\x11\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03C\x12$\n\x0c\n\x05\
    \x06\0\x02\x02\x03\x12\x03C/4\n\r\n\x05\x06\0\x02\x02\x04\x12\x04D\x04G\
    \x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04D\x04G\x06\n^\n\
    \x04\x06\0\x02\x03\x12\x04L\x02Q\x03\x1aP\x20Updates\x20an\x20existing\
    \x20group.\n\x20You\x20can\x20change\x20any\x20group\x20attributes\x20ex\
    cept\x20`name`.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03L\x06\x11\n\x0c\n\
    \x05\x06\0\x02\x03\x02\x12\x03L\x12$\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03L/4\n\r\n\x05\x06\0\x02\x03\x04\x12\x04M\x04P\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04M\x04P\x06\n*\n\x04\x06\0\x02\x04\x12\
    \x04T\x02X\x03\x1a\x1c\x20Deletes\x20an\x20existing\x20group.\n\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03T\x06\x11\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03T\x12$\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03T/D\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04U\x04W\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x04U\x04W\x06\nJ\n\x04\x06\0\x02\x05\x12\x04[\x02_\x03\x1a<\x20List\
    s\x20the\x20monitored\x20resources\x20that\x20are\x20members\x20of\x20a\
    \x20group.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03[\x06\x16\n\x0c\n\x05\
    \x06\0\x02\x05\x02\x12\x03[\x17.\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03[9\
    Q\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\\\x04^\x06\n\x11\n\t\x06\0\x02\x05\
    \x04\xb0\xca\xbc\"\x12\x04\\\x04^\x06\n'\n\x02\x04\0\x12\x05c\0\x86\x01\
    \x01\x1a\x1a\x20The\x20`ListGroup`\x20request.\n\n\n\n\x03\x04\0\x01\x12\
    \x03c\x08\x19\nm\n\x04\x04\0\x02\0\x12\x03f\x02\x12\x1a`\x20The\x20proje\
    ct\x20whose\x20groups\x20are\x20to\x20be\x20listed.\x20The\x20format\x20\
    is\n\x20`\"projects/{project_id_or_number}\"`.\n\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03f\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03f\t\r\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03f\x10\x11\n\xe6\x01\n\x04\x04\0\x08\0\x12\
    \x04k\x02}\x03\x1a\xd7\x01\x20An\x20optional\x20filter\x20consisting\x20\
    of\x20a\x20single\x20group\x20name.\x20\x20The\x20filters\x20limit\n\x20\
    the\x20groups\x20returned\x20based\x20on\x20their\x20parent-child\x20rel\
    ationship\x20with\x20the\n\x20specified\x20group.\x20If\x20no\x20filter\
    \x20is\x20specified,\x20all\x20groups\x20are\x20returned.\n\n\x0c\n\x05\
    \x04\0\x08\0\x01\x12\x03k\x08\x0e\n\xce\x01\n\x04\x04\0\x02\x01\x12\x03o\
    \x04!\x1a\xc0\x01\x20A\x20group\x20name:\x20`\"projects/{project_id_or_n\
    umber}/groups/{group_id}\"`.\n\x20Returns\x20groups\x20whose\x20`parentN\
    ame`\x20field\x20contains\x20the\x20group\n\x20name.\x20\x20If\x20no\x20\
    groups\x20have\x20this\x20parent,\x20the\x20results\x20are\x20empty.\n\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03o\x04\n\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03o\x0b\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03o\x1f\x20\n\
    \xca\x02\n\x04\x04\0\x02\x02\x12\x03v\x04\"\x1a\xbc\x02\x20A\x20group\
    \x20name:\x20`\"projects/{project_id_or_number}/groups/{group_id}\"`.\n\
    \x20Returns\x20groups\x20that\x20are\x20ancestors\x20of\x20the\x20specif\
    ied\x20group.\n\x20The\x20groups\x20are\x20returned\x20in\x20order,\x20s\
    tarting\x20with\x20the\x20immediate\x20parent\x20and\n\x20ending\x20with\
    \x20the\x20most\x20distant\x20ancestor.\x20\x20If\x20the\x20specified\
    \x20group\x20has\x20no\n\x20immediate\x20parent,\x20the\x20results\x20ar\
    e\x20empty.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03v\x04\n\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03v\x0b\x1d\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x03v\x20!\n\x85\x02\n\x04\x04\0\x02\x03\x12\x03|\x04$\x1a\xf7\x01\x20A\
    \x20group\x20name:\x20`\"projects/{project_id_or_number}/groups/{group_i\
    d}\"`.\n\x20Returns\x20the\x20descendants\x20of\x20the\x20specified\x20g\
    roup.\x20\x20This\x20is\x20a\x20superset\x20of\n\x20the\x20results\x20re\
    turned\x20by\x20the\x20`childrenOfGroup`\x20filter,\x20and\x20includes\n\
    \x20children-of-children,\x20and\x20so\x20forth.\n\n\x0c\n\x05\x04\0\x02\
    \x03\x05\x12\x03|\x04\n\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03|\x0b\x1f\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03|\"#\nR\n\x04\x04\0\x02\x04\x12\x04\
    \x80\x01\x02\x16\x1aD\x20A\x20positive\x20number\x20that\x20is\x20the\
    \x20maximum\x20number\x20of\x20results\x20to\x20return.\n\n\r\n\x05\x04\
    \0\x02\x04\x05\x12\x04\x80\x01\x02\x07\n\r\n\x05\x04\0\x02\x04\x01\x12\
    \x04\x80\x01\x08\x11\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\x80\x01\x14\x15\
    \n\xe8\x01\n\x04\x04\0\x02\x05\x12\x04\x85\x01\x02\x18\x1a\xd9\x01\x20If\
    \x20this\x20field\x20is\x20not\x20empty\x20then\x20it\x20must\x20contain\
    \x20the\x20`nextPageToken`\x20value\n\x20returned\x20by\x20a\x20previous\
    \x20call\x20to\x20this\x20method.\x20\x20Using\x20this\x20field\x20cause\
    s\x20the\n\x20method\x20to\x20return\x20additional\x20results\x20from\
    \x20the\x20previous\x20method\x20call.\n\n\r\n\x05\x04\0\x02\x05\x05\x12\
    \x04\x85\x01\x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\x85\x01\t\x13\n\
    \r\n\x05\x04\0\x02\x05\x03\x12\x04\x85\x01\x16\x17\n*\n\x02\x04\x01\x12\
    \x06\x89\x01\0\x91\x01\x01\x1a\x1c\x20The\x20`ListGroups`\x20response.\n\
    \n\x0b\n\x03\x04\x01\x01\x12\x04\x89\x01\x08\x1a\n<\n\x04\x04\x01\x02\0\
    \x12\x04\x8b\x01\x02\x1b\x1a.\x20The\x20groups\x20that\x20match\x20the\
    \x20specified\x20filters.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x8b\x01\
    \x02\n\n\r\n\x05\x04\x01\x02\0\x06\x12\x04\x8b\x01\x0b\x10\n\r\n\x05\x04\
    \x01\x02\0\x01\x12\x04\x8b\x01\x11\x16\n\r\n\x05\x04\x01\x02\0\x03\x12\
    \x04\x8b\x01\x19\x1a\n\xd1\x01\n\x04\x04\x01\x02\x01\x12\x04\x90\x01\x02\
    \x1d\x1a\xc2\x01\x20If\x20there\x20are\x20more\x20results\x20than\x20hav\
    e\x20been\x20returned,\x20then\x20this\x20field\x20is\x20set\n\x20to\x20\
    a\x20non-empty\x20value.\x20\x20To\x20see\x20the\x20additional\x20result\
    s,\n\x20use\x20that\x20value\x20as\x20`pageToken`\x20in\x20the\x20next\
    \x20call\x20to\x20this\x20method.\n\n\r\n\x05\x04\x01\x02\x01\x05\x12\
    \x04\x90\x01\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x90\x01\t\x18\
    \n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x90\x01\x1b\x1c\n'\n\x02\x04\x02\
    \x12\x06\x94\x01\0\x98\x01\x01\x1a\x19\x20The\x20`GetGroup`\x20request.\
    \n\n\x0b\n\x03\x04\x02\x01\x12\x04\x94\x01\x08\x17\nl\n\x04\x04\x02\x02\
    \0\x12\x04\x97\x01\x02\x12\x1a^\x20The\x20group\x20to\x20retrieve.\x20Th\
    e\x20format\x20is\n\x20`\"projects/{project_id_or_number}/groups/{group_\
    id}\"`.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x97\x01\x02\x08\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\x97\x01\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\x97\x01\x10\x11\n*\n\x02\x04\x03\x12\x06\x9b\x01\0\xa6\x01\x01\x1a\
    \x1c\x20The\x20`CreateGroup`\x20request.\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\x9b\x01\x08\x1a\nm\n\x04\x04\x03\x02\0\x12\x04\x9e\x01\x02\x12\x1a_\
    \x20The\x20project\x20in\x20which\x20to\x20create\x20the\x20group.\x20Th\
    e\x20format\x20is\n\x20`\"projects/{project_id_or_number}\"`.\n\n\r\n\
    \x05\x04\x03\x02\0\x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\
    \x01\x12\x04\x9e\x01\t\r\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x9e\x01\x10\
    \x11\ns\n\x04\x04\x03\x02\x01\x12\x04\xa2\x01\x02\x12\x1ae\x20A\x20group\
    \x20definition.\x20It\x20is\x20an\x20error\x20to\x20define\x20the\x20`na\
    me`\x20field\x20because\n\x20the\x20system\x20assigns\x20the\x20name.\n\
    \n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xa2\x01\x02\x07\n\r\n\x05\x04\x03\
    \x02\x01\x01\x12\x04\xa2\x01\x08\r\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\
    \xa2\x01\x10\x11\nK\n\x04\x04\x03\x02\x02\x12\x04\xa5\x01\x02\x19\x1a=\
    \x20If\x20true,\x20validate\x20this\x20request\x20but\x20do\x20not\x20cr\
    eate\x20the\x20group.\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xa5\x01\
    \x02\x06\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xa5\x01\x07\x14\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\xa5\x01\x17\x18\n*\n\x02\x04\x04\x12\x06\
    \xa9\x01\0\xb0\x01\x01\x1a\x1c\x20The\x20`UpdateGroup`\x20request.\n\n\
    \x0b\n\x03\x04\x04\x01\x12\x04\xa9\x01\x08\x1a\n\xa1\x01\n\x04\x04\x04\
    \x02\0\x12\x04\xac\x01\x02\x12\x1a\x92\x01\x20The\x20new\x20definition\
    \x20of\x20the\x20group.\x20\x20All\x20fields\x20of\x20the\x20existing\
    \x20group,\n\x20excepting\x20`name`,\x20are\x20replaced\x20with\x20the\
    \x20corresponding\x20fields\x20of\x20this\x20group.\n\n\r\n\x05\x04\x04\
    \x02\0\x06\x12\x04\xac\x01\x02\x07\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\
    \xac\x01\x08\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xac\x01\x10\x11\nT\n\
    \x04\x04\x04\x02\x01\x12\x04\xaf\x01\x02\x19\x1aF\x20If\x20true,\x20vali\
    date\x20this\x20request\x20but\x20do\x20not\x20update\x20the\x20existing\
    \x20group.\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xaf\x01\x02\x06\n\r\n\
    \x05\x04\x04\x02\x01\x01\x12\x04\xaf\x01\x07\x14\n\r\n\x05\x04\x04\x02\
    \x01\x03\x12\x04\xaf\x01\x17\x18\n\x80\x01\n\x02\x04\x05\x12\x06\xb4\x01\
    \0\xbd\x01\x01\x1ar\x20The\x20`DeleteGroup`\x20request.\x20The\x20defaul\
    t\x20behavior\x20is\x20to\x20be\x20able\x20to\x20delete\x20a\n\x20single\
    \x20group\x20without\x20any\x20descendants.\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\xb4\x01\x08\x1a\nj\n\x04\x04\x05\x02\0\x12\x04\xb7\x01\x02\x12\
    \x1a\\\x20The\x20group\x20to\x20delete.\x20The\x20format\x20is\n\x20`\"p\
    rojects/{project_id_or_number}/groups/{group_id}\"`.\n\n\r\n\x05\x04\x05\
    \x02\0\x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \xb7\x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb7\x01\x10\x11\n\xd8\
    \x01\n\x04\x04\x05\x02\x01\x12\x04\xbc\x01\x02\x15\x1a\xc9\x01\x20If\x20\
    this\x20field\x20is\x20true,\x20then\x20the\x20request\x20means\x20to\
    \x20delete\x20a\x20group\x20with\x20all\n\x20its\x20descendants.\x20Othe\
    rwise,\x20the\x20request\x20means\x20to\x20delete\x20a\x20group\x20only\
    \x20when\n\x20it\x20has\x20no\x20descendants.\x20The\x20default\x20value\
    \x20is\x20false.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xbc\x01\x02\x06\
    \n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xbc\x01\x07\x10\n\r\n\x05\x04\x05\
    \x02\x01\x03\x12\x04\xbc\x01\x13\x14\n/\n\x02\x04\x06\x12\x06\xc0\x01\0\
    \xdb\x01\x01\x1a!\x20The\x20`ListGroupMembers`\x20request.\n\n\x0b\n\x03\
    \x04\x06\x01\x12\x04\xc0\x01\x08\x1f\ny\n\x04\x04\x06\x02\0\x12\x04\xc3\
    \x01\x02\x12\x1ak\x20The\x20group\x20whose\x20members\x20are\x20listed.\
    \x20The\x20format\x20is\n\x20`\"projects/{project_id_or_number}/groups/{\
    group_id}\"`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xc3\x01\x02\x08\n\r\
    \n\x05\x04\x06\x02\0\x01\x12\x04\xc3\x01\t\r\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\xc3\x01\x10\x11\nR\n\x04\x04\x06\x02\x01\x12\x04\xc6\x01\x02\
    \x16\x1aD\x20A\x20positive\x20number\x20that\x20is\x20the\x20maximum\x20\
    number\x20of\x20results\x20to\x20return.\n\n\r\n\x05\x04\x06\x02\x01\x05\
    \x12\x04\xc6\x01\x02\x07\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xc6\x01\
    \x08\x11\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc6\x01\x14\x15\n\xe8\x01\
    \n\x04\x04\x06\x02\x02\x12\x04\xcb\x01\x02\x18\x1a\xd9\x01\x20If\x20this\
    \x20field\x20is\x20not\x20empty\x20then\x20it\x20must\x20contain\x20the\
    \x20`nextPageToken`\x20value\n\x20returned\x20by\x20a\x20previous\x20cal\
    l\x20to\x20this\x20method.\x20\x20Using\x20this\x20field\x20causes\x20th\
    e\n\x20method\x20to\x20return\x20additional\x20results\x20from\x20the\
    \x20previous\x20method\x20call.\n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\
    \xcb\x01\x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xcb\x01\t\x13\n\r\
    \n\x05\x04\x06\x02\x02\x03\x12\x04\xcb\x01\x16\x17\n\xea\x02\n\x04\x04\
    \x06\x02\x03\x12\x04\xd4\x01\x02\x14\x1a\xdb\x02\x20An\x20optional\x20[l\
    ist\x20filter](/monitoring/api/learn_more#filtering)\x20describing\n\x20\
    the\x20members\x20to\x20be\x20returned.\x20\x20The\x20filter\x20may\x20r\
    eference\x20the\x20type,\x20labels,\x20and\n\x20metadata\x20of\x20monito\
    red\x20resources\x20that\x20comprise\x20the\x20group.\n\x20For\x20exampl\
    e,\x20to\x20return\x20only\x20resources\x20representing\x20Compute\x20En\
    gine\x20VM\n\x20instances,\x20use\x20this\x20filter:\n\n\x20\x20\x20\x20\
    \x20resource.type\x20=\x20\"gce_instance\"\n\n\r\n\x05\x04\x06\x02\x03\
    \x05\x12\x04\xd4\x01\x02\x08\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xd4\
    \x01\t\x0f\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xd4\x01\x12\x13\n\x90\
    \x02\n\x04\x04\x06\x02\x04\x12\x04\xda\x01\x02\x1c\x1a\x81\x02\x20An\x20\
    optional\x20time\x20interval\x20for\x20which\x20results\x20should\x20be\
    \x20returned.\x20Only\n\x20members\x20that\x20were\x20part\x20of\x20the\
    \x20group\x20during\x20the\x20specified\x20interval\x20are\n\x20included\
    \x20in\x20the\x20response.\x20\x20If\x20no\x20interval\x20is\x20provided\
    \x20then\x20the\x20group\n\x20membership\x20over\x20the\x20last\x20minut\
    e\x20is\x20returned.\n\n\r\n\x05\x04\x06\x02\x04\x06\x12\x04\xda\x01\x02\
    \x0e\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xda\x01\x0f\x17\n\r\n\x05\x04\
    \x06\x02\x04\x03\x12\x04\xda\x01\x1a\x1b\n0\n\x02\x04\x07\x12\x06\xde\
    \x01\0\xe9\x01\x01\x1a\"\x20The\x20`ListGroupMembers`\x20response.\n\n\
    \x0b\n\x03\x04\x07\x01\x12\x04\xde\x01\x08\x20\n:\n\x04\x04\x07\x02\0\
    \x12\x04\xe0\x01\x024\x1a,\x20A\x20set\x20of\x20monitored\x20resources\
    \x20in\x20the\x20group.\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xe0\x01\
    \x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xe0\x01\x0b'\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xe0\x01(/\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe0\
    \x0123\n\xd1\x01\n\x04\x04\x07\x02\x01\x12\x04\xe5\x01\x02\x1d\x1a\xc2\
    \x01\x20If\x20there\x20are\x20more\x20results\x20than\x20have\x20been\
    \x20returned,\x20then\x20this\x20field\x20is\n\x20set\x20to\x20a\x20non-\
    empty\x20value.\x20\x20To\x20see\x20the\x20additional\x20results,\x20use\
    \x20that\x20value\x20as\n\x20`pageToken`\x20in\x20the\x20next\x20call\
    \x20to\x20this\x20method.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xe5\
    \x01\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xe5\x01\t\x18\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\xe5\x01\x1b\x1c\nC\n\x04\x04\x07\x02\
    \x02\x12\x04\xe8\x01\x02\x17\x1a5\x20The\x20total\x20number\x20of\x20ele\
    ments\x20matching\x20this\x20request.\n\n\r\n\x05\x04\x07\x02\x02\x05\
    \x12\x04\xe8\x01\x02\x07\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xe8\x01\
    \x08\x12\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xe8\x01\x15\x16b\x06proto\
    3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
