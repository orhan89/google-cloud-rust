// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/logging/v2/logging_config.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct LogSink {
    // message fields
    pub name: ::std::string::String,
    pub destination: ::std::string::String,
    pub filter: ::std::string::String,
    pub output_version_format: LogSink_VersionFormat,
    pub writer_identity: ::std::string::String,
    pub include_children: bool,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub options: ::std::option::Option<LogSink_oneof_options>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogSink {
    fn default() -> &'a LogSink {
        <LogSink as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LogSink_oneof_options {
    bigquery_options(BigQueryOptions),
}

impl LogSink {
    pub fn new() -> LogSink {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string destination = 3;


    pub fn get_destination(&self) -> &str {
        &self.destination
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    // string filter = 5;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // .google.logging.v2.LogSink.VersionFormat output_version_format = 6;


    pub fn get_output_version_format(&self) -> LogSink_VersionFormat {
        self.output_version_format
    }
    pub fn clear_output_version_format(&mut self) {
        self.output_version_format = LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_output_version_format(&mut self, v: LogSink_VersionFormat) {
        self.output_version_format = v;
    }

    // string writer_identity = 8;


    pub fn get_writer_identity(&self) -> &str {
        &self.writer_identity
    }
    pub fn clear_writer_identity(&mut self) {
        self.writer_identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_writer_identity(&mut self, v: ::std::string::String) {
        self.writer_identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writer_identity(&mut self) -> &mut ::std::string::String {
        &mut self.writer_identity
    }

    // Take field
    pub fn take_writer_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.writer_identity, ::std::string::String::new())
    }

    // bool include_children = 9;


    pub fn get_include_children(&self) -> bool {
        self.include_children
    }
    pub fn clear_include_children(&mut self) {
        self.include_children = false;
    }

    // Param is passed by value, moved
    pub fn set_include_children(&mut self, v: bool) {
        self.include_children = v;
    }

    // .google.logging.v2.BigQueryOptions bigquery_options = 12;


    pub fn get_bigquery_options(&self) -> &BigQueryOptions {
        match self.options {
            ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(ref v)) => v,
            _ => <BigQueryOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bigquery_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_bigquery_options(&self) -> bool {
        match self.options {
            ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bigquery_options(&mut self, v: BigQueryOptions) {
        self.options = ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bigquery_options(&mut self) -> &mut BigQueryOptions {
        if let ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(_)) = self.options {
        } else {
            self.options = ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(BigQueryOptions::new()));
        }
        match self.options {
            ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bigquery_options(&mut self) -> BigQueryOptions {
        if self.has_bigquery_options() {
            match self.options.take() {
                ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(v)) => v,
                _ => panic!(),
            }
        } else {
            BigQueryOptions::new()
        }
    }

    // .google.protobuf.Timestamp create_time = 13;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 14;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp start_time = 10;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 11;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for LogSink {
    fn is_initialized(&self) -> bool {
        if let Some(LogSink_oneof_options::bigquery_options(ref v)) = self.options {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output_version_format, 6, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.writer_identity)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_children = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.options = ::std::option::Option::Some(LogSink_oneof_options::bigquery_options(is.read_message()?));
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.filter);
        }
        if self.output_version_format != LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.output_version_format);
        }
        if !self.writer_identity.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.writer_identity);
        }
        if self.include_children != false {
            my_size += 2;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.options {
            match v {
                &LogSink_oneof_options::bigquery_options(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.destination.is_empty() {
            os.write_string(3, &self.destination)?;
        }
        if !self.filter.is_empty() {
            os.write_string(5, &self.filter)?;
        }
        if self.output_version_format != LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.output_version_format))?;
        }
        if !self.writer_identity.is_empty() {
            os.write_string(8, &self.writer_identity)?;
        }
        if self.include_children != false {
            os.write_bool(9, self.include_children)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.options {
            match v {
                &LogSink_oneof_options::bigquery_options(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogSink {
        LogSink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LogSink| { &m.name },
                |m: &mut LogSink| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination",
                |m: &LogSink| { &m.destination },
                |m: &mut LogSink| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &LogSink| { &m.filter },
                |m: &mut LogSink| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogSink_VersionFormat>>(
                "output_version_format",
                |m: &LogSink| { &m.output_version_format },
                |m: &mut LogSink| { &mut m.output_version_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "writer_identity",
                |m: &LogSink| { &m.writer_identity },
                |m: &mut LogSink| { &mut m.writer_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_children",
                |m: &LogSink| { &m.include_children },
                |m: &mut LogSink| { &mut m.include_children },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BigQueryOptions>(
                "bigquery_options",
                LogSink::has_bigquery_options,
                LogSink::get_bigquery_options,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &LogSink| { &m.create_time },
                |m: &mut LogSink| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &LogSink| { &m.update_time },
                |m: &mut LogSink| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &LogSink| { &m.start_time },
                |m: &mut LogSink| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &LogSink| { &m.end_time },
                |m: &mut LogSink| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogSink>(
                "LogSink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogSink {
        static instance: ::protobuf::rt::LazyV2<LogSink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogSink::new)
    }
}

impl ::protobuf::Clear for LogSink {
    fn clear(&mut self) {
        self.name.clear();
        self.destination.clear();
        self.filter.clear();
        self.output_version_format = LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED;
        self.writer_identity.clear();
        self.include_children = false;
        self.options = ::std::option::Option::None;
        self.create_time.clear();
        self.update_time.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogSink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LogSink_VersionFormat {
    VERSION_FORMAT_UNSPECIFIED = 0,
    V2 = 1,
    V1 = 2,
}

impl ::protobuf::ProtobufEnum for LogSink_VersionFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogSink_VersionFormat> {
        match value {
            0 => ::std::option::Option::Some(LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED),
            1 => ::std::option::Option::Some(LogSink_VersionFormat::V2),
            2 => ::std::option::Option::Some(LogSink_VersionFormat::V1),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LogSink_VersionFormat] = &[
            LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED,
            LogSink_VersionFormat::V2,
            LogSink_VersionFormat::V1,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LogSink_VersionFormat>("LogSink.VersionFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LogSink_VersionFormat {
}

impl ::std::default::Default for LogSink_VersionFormat {
    fn default() -> Self {
        LogSink_VersionFormat::VERSION_FORMAT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for LogSink_VersionFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BigQueryOptions {
    // message fields
    pub use_partitioned_tables: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BigQueryOptions {
    fn default() -> &'a BigQueryOptions {
        <BigQueryOptions as ::protobuf::Message>::default_instance()
    }
}

impl BigQueryOptions {
    pub fn new() -> BigQueryOptions {
        ::std::default::Default::default()
    }

    // bool use_partitioned_tables = 1;


    pub fn get_use_partitioned_tables(&self) -> bool {
        self.use_partitioned_tables
    }
    pub fn clear_use_partitioned_tables(&mut self) {
        self.use_partitioned_tables = false;
    }

    // Param is passed by value, moved
    pub fn set_use_partitioned_tables(&mut self, v: bool) {
        self.use_partitioned_tables = v;
    }
}

impl ::protobuf::Message for BigQueryOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_partitioned_tables = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.use_partitioned_tables != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.use_partitioned_tables != false {
            os.write_bool(1, self.use_partitioned_tables)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BigQueryOptions {
        BigQueryOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_partitioned_tables",
                |m: &BigQueryOptions| { &m.use_partitioned_tables },
                |m: &mut BigQueryOptions| { &mut m.use_partitioned_tables },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BigQueryOptions>(
                "BigQueryOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BigQueryOptions {
        static instance: ::protobuf::rt::LazyV2<BigQueryOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BigQueryOptions::new)
    }
}

impl ::protobuf::Clear for BigQueryOptions {
    fn clear(&mut self) {
        self.use_partitioned_tables = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BigQueryOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BigQueryOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSinksRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSinksRequest {
    fn default() -> &'a ListSinksRequest {
        <ListSinksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSinksRequest {
    pub fn new() -> ListSinksRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }
}

impl ::protobuf::Message for ListSinksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSinksRequest {
        ListSinksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListSinksRequest| { &m.parent },
                |m: &mut ListSinksRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListSinksRequest| { &m.page_token },
                |m: &mut ListSinksRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListSinksRequest| { &m.page_size },
                |m: &mut ListSinksRequest| { &mut m.page_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSinksRequest>(
                "ListSinksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSinksRequest {
        static instance: ::protobuf::rt::LazyV2<ListSinksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSinksRequest::new)
    }
}

impl ::protobuf::Clear for ListSinksRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSinksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSinksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSinksResponse {
    // message fields
    pub sinks: ::protobuf::RepeatedField<LogSink>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSinksResponse {
    fn default() -> &'a ListSinksResponse {
        <ListSinksResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSinksResponse {
    pub fn new() -> ListSinksResponse {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.LogSink sinks = 1;


    pub fn get_sinks(&self) -> &[LogSink] {
        &self.sinks
    }
    pub fn clear_sinks(&mut self) {
        self.sinks.clear();
    }

    // Param is passed by value, moved
    pub fn set_sinks(&mut self, v: ::protobuf::RepeatedField<LogSink>) {
        self.sinks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sinks(&mut self) -> &mut ::protobuf::RepeatedField<LogSink> {
        &mut self.sinks
    }

    // Take field
    pub fn take_sinks(&mut self) -> ::protobuf::RepeatedField<LogSink> {
        ::std::mem::replace(&mut self.sinks, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSinksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sinks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sinks)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sinks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sinks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSinksResponse {
        ListSinksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                "sinks",
                |m: &ListSinksResponse| { &m.sinks },
                |m: &mut ListSinksResponse| { &mut m.sinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListSinksResponse| { &m.next_page_token },
                |m: &mut ListSinksResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSinksResponse>(
                "ListSinksResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSinksResponse {
        static instance: ::protobuf::rt::LazyV2<ListSinksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSinksResponse::new)
    }
}

impl ::protobuf::Clear for ListSinksResponse {
    fn clear(&mut self) {
        self.sinks.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSinksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSinksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSinkRequest {
    fn default() -> &'a GetSinkRequest {
        <GetSinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSinkRequest {
    pub fn new() -> GetSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;


    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }
    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSinkRequest {
        GetSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sink_name",
                |m: &GetSinkRequest| { &m.sink_name },
                |m: &mut GetSinkRequest| { &mut m.sink_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSinkRequest>(
                "GetSinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSinkRequest {
        static instance: ::protobuf::rt::LazyV2<GetSinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSinkRequest::new)
    }
}

impl ::protobuf::Clear for GetSinkRequest {
    fn clear(&mut self) {
        self.sink_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSinkRequest {
    // message fields
    pub parent: ::std::string::String,
    pub sink: ::protobuf::SingularPtrField<LogSink>,
    pub unique_writer_identity: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSinkRequest {
    fn default() -> &'a CreateSinkRequest {
        <CreateSinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSinkRequest {
    pub fn new() -> CreateSinkRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.logging.v2.LogSink sink = 2;


    pub fn get_sink(&self) -> &LogSink {
        self.sink.as_ref().unwrap_or_else(|| <LogSink as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: LogSink) {
        self.sink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut LogSink {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> LogSink {
        self.sink.take().unwrap_or_else(|| LogSink::new())
    }

    // bool unique_writer_identity = 3;


    pub fn get_unique_writer_identity(&self) -> bool {
        self.unique_writer_identity
    }
    pub fn clear_unique_writer_identity(&mut self) {
        self.unique_writer_identity = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_writer_identity(&mut self, v: bool) {
        self.unique_writer_identity = v;
    }
}

impl ::protobuf::Message for CreateSinkRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_writer_identity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.sink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unique_writer_identity != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unique_writer_identity != false {
            os.write_bool(3, self.unique_writer_identity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSinkRequest {
        CreateSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateSinkRequest| { &m.parent },
                |m: &mut CreateSinkRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                "sink",
                |m: &CreateSinkRequest| { &m.sink },
                |m: &mut CreateSinkRequest| { &mut m.sink },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unique_writer_identity",
                |m: &CreateSinkRequest| { &m.unique_writer_identity },
                |m: &mut CreateSinkRequest| { &mut m.unique_writer_identity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSinkRequest>(
                "CreateSinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSinkRequest {
        static instance: ::protobuf::rt::LazyV2<CreateSinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSinkRequest::new)
    }
}

impl ::protobuf::Clear for CreateSinkRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.sink.clear();
        self.unique_writer_identity = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    pub sink: ::protobuf::SingularPtrField<LogSink>,
    pub unique_writer_identity: bool,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSinkRequest {
    fn default() -> &'a UpdateSinkRequest {
        <UpdateSinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSinkRequest {
    pub fn new() -> UpdateSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;


    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }
    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }

    // .google.logging.v2.LogSink sink = 2;


    pub fn get_sink(&self) -> &LogSink {
        self.sink.as_ref().unwrap_or_else(|| <LogSink as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: LogSink) {
        self.sink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut LogSink {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> LogSink {
        self.sink.take().unwrap_or_else(|| LogSink::new())
    }

    // bool unique_writer_identity = 3;


    pub fn get_unique_writer_identity(&self) -> bool {
        self.unique_writer_identity
    }
    pub fn clear_unique_writer_identity(&mut self) {
        self.unique_writer_identity = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_writer_identity(&mut self, v: bool) {
        self.unique_writer_identity = v;
    }

    // .google.protobuf.FieldMask update_mask = 4;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSinkRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_writer_identity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        if let Some(ref v) = self.sink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unique_writer_identity != false {
            my_size += 2;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unique_writer_identity != false {
            os.write_bool(3, self.unique_writer_identity)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSinkRequest {
        UpdateSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sink_name",
                |m: &UpdateSinkRequest| { &m.sink_name },
                |m: &mut UpdateSinkRequest| { &mut m.sink_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogSink>>(
                "sink",
                |m: &UpdateSinkRequest| { &m.sink },
                |m: &mut UpdateSinkRequest| { &mut m.sink },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unique_writer_identity",
                |m: &UpdateSinkRequest| { &m.unique_writer_identity },
                |m: &mut UpdateSinkRequest| { &mut m.unique_writer_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateSinkRequest| { &m.update_mask },
                |m: &mut UpdateSinkRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSinkRequest>(
                "UpdateSinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSinkRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateSinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSinkRequest::new)
    }
}

impl ::protobuf::Clear for UpdateSinkRequest {
    fn clear(&mut self) {
        self.sink_name.clear();
        self.sink.clear();
        self.unique_writer_identity = false;
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSinkRequest {
    // message fields
    pub sink_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSinkRequest {
    fn default() -> &'a DeleteSinkRequest {
        <DeleteSinkRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSinkRequest {
    pub fn new() -> DeleteSinkRequest {
        ::std::default::Default::default()
    }

    // string sink_name = 1;


    pub fn get_sink_name(&self) -> &str {
        &self.sink_name
    }
    pub fn clear_sink_name(&mut self) {
        self.sink_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_sink_name(&mut self, v: ::std::string::String) {
        self.sink_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_name(&mut self) -> &mut ::std::string::String {
        &mut self.sink_name
    }

    // Take field
    pub fn take_sink_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sink_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sink_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sink_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sink_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sink_name.is_empty() {
            os.write_string(1, &self.sink_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSinkRequest {
        DeleteSinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sink_name",
                |m: &DeleteSinkRequest| { &m.sink_name },
                |m: &mut DeleteSinkRequest| { &mut m.sink_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSinkRequest>(
                "DeleteSinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSinkRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSinkRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSinkRequest {
    fn clear(&mut self) {
        self.sink_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogExclusion {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub filter: ::std::string::String,
    pub disabled: bool,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub update_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogExclusion {
    fn default() -> &'a LogExclusion {
        <LogExclusion as ::protobuf::Message>::default_instance()
    }
}

impl LogExclusion {
    pub fn new() -> LogExclusion {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string filter = 3;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // bool disabled = 4;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }

    // .google.protobuf.Timestamp create_time = 5;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp update_time = 6;


    pub fn get_update_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.update_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_time(&mut self) {
        self.update_time.clear();
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.update_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.update_time.is_none() {
            self.update_time.set_default();
        }
        self.update_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.update_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for LogExclusion {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filter);
        }
        if self.disabled != false {
            my_size += 2;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.filter.is_empty() {
            os.write_string(3, &self.filter)?;
        }
        if self.disabled != false {
            os.write_bool(4, self.disabled)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogExclusion {
        LogExclusion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LogExclusion| { &m.name },
                |m: &mut LogExclusion| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &LogExclusion| { &m.description },
                |m: &mut LogExclusion| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &LogExclusion| { &m.filter },
                |m: &mut LogExclusion| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &LogExclusion| { &m.disabled },
                |m: &mut LogExclusion| { &mut m.disabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &LogExclusion| { &m.create_time },
                |m: &mut LogExclusion| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "update_time",
                |m: &LogExclusion| { &m.update_time },
                |m: &mut LogExclusion| { &mut m.update_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogExclusion>(
                "LogExclusion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogExclusion {
        static instance: ::protobuf::rt::LazyV2<LogExclusion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogExclusion::new)
    }
}

impl ::protobuf::Clear for LogExclusion {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.filter.clear();
        self.disabled = false;
        self.create_time.clear();
        self.update_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogExclusion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogExclusion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListExclusionsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListExclusionsRequest {
    fn default() -> &'a ListExclusionsRequest {
        <ListExclusionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListExclusionsRequest {
    pub fn new() -> ListExclusionsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }
}

impl ::protobuf::Message for ListExclusionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListExclusionsRequest {
        ListExclusionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListExclusionsRequest| { &m.parent },
                |m: &mut ListExclusionsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListExclusionsRequest| { &m.page_token },
                |m: &mut ListExclusionsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListExclusionsRequest| { &m.page_size },
                |m: &mut ListExclusionsRequest| { &mut m.page_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListExclusionsRequest>(
                "ListExclusionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListExclusionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListExclusionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListExclusionsRequest::new)
    }
}

impl ::protobuf::Clear for ListExclusionsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListExclusionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListExclusionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListExclusionsResponse {
    // message fields
    pub exclusions: ::protobuf::RepeatedField<LogExclusion>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListExclusionsResponse {
    fn default() -> &'a ListExclusionsResponse {
        <ListExclusionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListExclusionsResponse {
    pub fn new() -> ListExclusionsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.logging.v2.LogExclusion exclusions = 1;


    pub fn get_exclusions(&self) -> &[LogExclusion] {
        &self.exclusions
    }
    pub fn clear_exclusions(&mut self) {
        self.exclusions.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclusions(&mut self, v: ::protobuf::RepeatedField<LogExclusion>) {
        self.exclusions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclusions(&mut self) -> &mut ::protobuf::RepeatedField<LogExclusion> {
        &mut self.exclusions
    }

    // Take field
    pub fn take_exclusions(&mut self) -> ::protobuf::RepeatedField<LogExclusion> {
        ::std::mem::replace(&mut self.exclusions, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListExclusionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exclusions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.exclusions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.exclusions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListExclusionsResponse {
        ListExclusionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                "exclusions",
                |m: &ListExclusionsResponse| { &m.exclusions },
                |m: &mut ListExclusionsResponse| { &mut m.exclusions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListExclusionsResponse| { &m.next_page_token },
                |m: &mut ListExclusionsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListExclusionsResponse>(
                "ListExclusionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListExclusionsResponse {
        static instance: ::protobuf::rt::LazyV2<ListExclusionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListExclusionsResponse::new)
    }
}

impl ::protobuf::Clear for ListExclusionsResponse {
    fn clear(&mut self) {
        self.exclusions.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListExclusionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListExclusionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetExclusionRequest {
    fn default() -> &'a GetExclusionRequest {
        <GetExclusionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetExclusionRequest {
    pub fn new() -> GetExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetExclusionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetExclusionRequest {
        GetExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetExclusionRequest| { &m.name },
                |m: &mut GetExclusionRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetExclusionRequest>(
                "GetExclusionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetExclusionRequest {
        static instance: ::protobuf::rt::LazyV2<GetExclusionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetExclusionRequest::new)
    }
}

impl ::protobuf::Clear for GetExclusionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateExclusionRequest {
    // message fields
    pub parent: ::std::string::String,
    pub exclusion: ::protobuf::SingularPtrField<LogExclusion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateExclusionRequest {
    fn default() -> &'a CreateExclusionRequest {
        <CreateExclusionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateExclusionRequest {
    pub fn new() -> CreateExclusionRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.logging.v2.LogExclusion exclusion = 2;


    pub fn get_exclusion(&self) -> &LogExclusion {
        self.exclusion.as_ref().unwrap_or_else(|| <LogExclusion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exclusion(&mut self) {
        self.exclusion.clear();
    }

    pub fn has_exclusion(&self) -> bool {
        self.exclusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusion(&mut self, v: LogExclusion) {
        self.exclusion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exclusion(&mut self) -> &mut LogExclusion {
        if self.exclusion.is_none() {
            self.exclusion.set_default();
        }
        self.exclusion.as_mut().unwrap()
    }

    // Take field
    pub fn take_exclusion(&mut self) -> LogExclusion {
        self.exclusion.take().unwrap_or_else(|| LogExclusion::new())
    }
}

impl ::protobuf::Message for CreateExclusionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exclusion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateExclusionRequest {
        CreateExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateExclusionRequest| { &m.parent },
                |m: &mut CreateExclusionRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                "exclusion",
                |m: &CreateExclusionRequest| { &m.exclusion },
                |m: &mut CreateExclusionRequest| { &mut m.exclusion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateExclusionRequest>(
                "CreateExclusionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateExclusionRequest {
        static instance: ::protobuf::rt::LazyV2<CreateExclusionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateExclusionRequest::new)
    }
}

impl ::protobuf::Clear for CreateExclusionRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.exclusion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    pub exclusion: ::protobuf::SingularPtrField<LogExclusion>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateExclusionRequest {
    fn default() -> &'a UpdateExclusionRequest {
        <UpdateExclusionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateExclusionRequest {
    pub fn new() -> UpdateExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.logging.v2.LogExclusion exclusion = 2;


    pub fn get_exclusion(&self) -> &LogExclusion {
        self.exclusion.as_ref().unwrap_or_else(|| <LogExclusion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exclusion(&mut self) {
        self.exclusion.clear();
    }

    pub fn has_exclusion(&self) -> bool {
        self.exclusion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusion(&mut self, v: LogExclusion) {
        self.exclusion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exclusion(&mut self) -> &mut LogExclusion {
        if self.exclusion.is_none() {
            self.exclusion.set_default();
        }
        self.exclusion.as_mut().unwrap()
    }

    // Take field
    pub fn take_exclusion(&mut self) -> LogExclusion {
        self.exclusion.take().unwrap_or_else(|| LogExclusion::new())
    }

    // .google.protobuf.FieldMask update_mask = 3;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateExclusionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.exclusion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exclusion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.exclusion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateExclusionRequest {
        UpdateExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UpdateExclusionRequest| { &m.name },
                |m: &mut UpdateExclusionRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogExclusion>>(
                "exclusion",
                |m: &UpdateExclusionRequest| { &m.exclusion },
                |m: &mut UpdateExclusionRequest| { &mut m.exclusion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateExclusionRequest| { &m.update_mask },
                |m: &mut UpdateExclusionRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateExclusionRequest>(
                "UpdateExclusionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateExclusionRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateExclusionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateExclusionRequest::new)
    }
}

impl ::protobuf::Clear for UpdateExclusionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.exclusion.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteExclusionRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteExclusionRequest {
    fn default() -> &'a DeleteExclusionRequest {
        <DeleteExclusionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteExclusionRequest {
    pub fn new() -> DeleteExclusionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteExclusionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteExclusionRequest {
        DeleteExclusionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteExclusionRequest| { &m.name },
                |m: &mut DeleteExclusionRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteExclusionRequest>(
                "DeleteExclusionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteExclusionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteExclusionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteExclusionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteExclusionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteExclusionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteExclusionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&google/logging/v2/logging_config.proto\x12\x11google.logging.v2\x1a\
    \x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\
    \x1a\x20google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestam\
    p.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.pro\
    to\"\x9e\x05\n\x07LogSink\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdestination\x18\x03\x20\x01(\tR\x0bdestination\x12\x16\n\
    \x06filter\x18\x05\x20\x01(\tR\x06filter\x12`\n\x15output_version_format\
    \x18\x06\x20\x01(\x0e2(.google.logging.v2.LogSink.VersionFormatR\x13outp\
    utVersionFormatB\x02\x18\x01\x12'\n\x0fwriter_identity\x18\x08\x20\x01(\
    \tR\x0ewriterIdentity\x12)\n\x10include_children\x18\t\x20\x01(\x08R\x0f\
    includeChildren\x12O\n\x10bigquery_options\x18\x0c\x20\x01(\x0b2\".googl\
    e.logging.v2.BigQueryOptionsH\0R\x0fbigqueryOptions\x12;\n\x0bcreate_tim\
    e\x18\r\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\
    \x0bupdate_time\x18\x0e\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nup\
    dateTime\x12=\n\nstart_time\x18\n\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\tstartTimeB\x02\x18\x01\x129\n\x08end_time\x18\x0b\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x07endTimeB\x02\x18\x01\"?\n\rVersionFor\
    mat\x12\x1e\n\x1aVERSION_FORMAT_UNSPECIFIED\x10\0\x12\x06\n\x02V2\x10\
    \x01\x12\x06\n\x02V1\x10\x02B\t\n\x07options\"G\n\x0fBigQueryOptions\x12\
    4\n\x16use_partitioned_tables\x18\x01\x20\x01(\x08R\x14usePartitionedTab\
    les\"f\n\x10ListSinksRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06\
    parent\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToken\x12\x1b\n\tp\
    age_size\x18\x03\x20\x01(\x05R\x08pageSize\"m\n\x11ListSinksResponse\x12\
    0\n\x05sinks\x18\x01\x20\x03(\x0b2\x1a.google.logging.v2.LogSinkR\x05sin\
    ks\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"-\n\x0e\
    GetSinkRequest\x12\x1b\n\tsink_name\x18\x01\x20\x01(\tR\x08sinkName\"\
    \x91\x01\n\x11CreateSinkRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parent\x12.\n\x04sink\x18\x02\x20\x01(\x0b2\x1a.google.logging.v2.Lo\
    gSinkR\x04sink\x124\n\x16unique_writer_identity\x18\x03\x20\x01(\x08R\
    \x14uniqueWriterIdentity\"\xd3\x01\n\x11UpdateSinkRequest\x12\x1b\n\tsin\
    k_name\x18\x01\x20\x01(\tR\x08sinkName\x12.\n\x04sink\x18\x02\x20\x01(\
    \x0b2\x1a.google.logging.v2.LogSinkR\x04sink\x124\n\x16unique_writer_ide\
    ntity\x18\x03\x20\x01(\x08R\x14uniqueWriterIdentity\x12;\n\x0bupdate_mas\
    k\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"0\n\
    \x11DeleteSinkRequest\x12\x1b\n\tsink_name\x18\x01\x20\x01(\tR\x08sinkNa\
    me\"\xf2\x01\n\x0cLogExclusion\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x16\
    \n\x06filter\x18\x03\x20\x01(\tR\x06filter\x12\x1a\n\x08disabled\x18\x04\
    \x20\x01(\x08R\x08disabled\x12;\n\x0bcreate_time\x18\x05\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ncreateTime\x12;\n\x0bupdate_time\x18\
    \x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nupdateTime\"k\n\x15Li\
    stExclusionsRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\
    \x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToken\x12\x1b\n\tpage_si\
    ze\x18\x03\x20\x01(\x05R\x08pageSize\"\x81\x01\n\x16ListExclusionsRespon\
    se\x12?\n\nexclusions\x18\x01\x20\x03(\x0b2\x1f.google.logging.v2.LogExc\
    lusionR\nexclusions\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextP\
    ageToken\")\n\x13GetExclusionRequest\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\"o\n\x16CreateExclusionRequest\x12\x16\n\x06parent\x18\x01\
    \x20\x01(\tR\x06parent\x12=\n\texclusion\x18\x02\x20\x01(\x0b2\x1f.googl\
    e.logging.v2.LogExclusionR\texclusion\"\xa8\x01\n\x16UpdateExclusionRequ\
    est\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12=\n\texclusion\x18\
    \x02\x20\x01(\x0b2\x1f.google.logging.v2.LogExclusionR\texclusion\x12;\n\
    \x0bupdate_mask\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nup\
    dateMask\",\n\x16DeleteExclusionRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name2\xf6\x1a\n\x0fConfigServiceV2\x12\x87\x02\n\tListSinks\
    \x12#.google.logging.v2.ListSinksRequest\x1a$.google.logging.v2.ListSink\
    sResponse\"\xae\x01\x82\xd3\xe4\x93\x02\xa7\x01\x12\x16/v2/{parent=*/*}/\
    sinksZ\x1f\x12\x1d/v2/{parent=projects/*}/sinksZ$\x12\"/v2/{parent=organ\
    izations/*}/sinksZ\x1e\x12\x1c/v2/{parent=folders/*}/sinksZ&\x12$/v2/{pa\
    rent=billingAccounts/*}/sinks\x12\x92\x02\n\x07GetSink\x12!.google.loggi\
    ng.v2.GetSinkRequest\x1a\x1a.google.logging.v2.LogSink\"\xc7\x01\x82\xd3\
    \xe4\x93\x02\xc0\x01\x12\x1b/v2/{sink_name=*/*/sinks/*}Z$\x12\"/v2/{sink\
    _name=projects/*/sinks/*}Z)\x12'/v2/{sink_name=organizations/*/sinks/*}Z\
    #\x12!/v2/{sink_name=folders/*/sinks/*}Z+\x12)/v2/{sink_name=billingAcco\
    unts/*/sinks/*}\x12\x9d\x02\n\nCreateSink\x12$.google.logging.v2.CreateS\
    inkRequest\x1a\x1a.google.logging.v2.LogSink\"\xcc\x01\x82\xd3\xe4\x93\
    \x02\xc5\x01\"\x16/v2/{parent=*/*}/sinks:\x04sinkZ%\"\x1d/v2/{parent=pro\
    jects/*}/sinks:\x04sinkZ*\"\"/v2/{parent=organizations/*}/sinks:\x04sink\
    Z$\"\x1c/v2/{parent=folders/*}/sinks:\x04sinkZ,\"$/v2/{parent=billingAcc\
    ounts/*}/sinks:\x04sink\x12\xf1\x03\n\nUpdateSink\x12$.google.logging.v2\
    .UpdateSinkRequest\x1a\x1a.google.logging.v2.LogSink\"\xa0\x03\x82\xd3\
    \xe4\x93\x02\x99\x03\x1a\x1b/v2/{sink_name=*/*/sinks/*}:\x04sinkZ*\x1a\"\
    /v2/{sink_name=projects/*/sinks/*}:\x04sinkZ/\x1a'/v2/{sink_name=organiz\
    ations/*/sinks/*}:\x04sinkZ)\x1a!/v2/{sink_name=folders/*/sinks/*}:\x04s\
    inkZ1\x1a)/v2/{sink_name=billingAccounts/*/sinks/*}:\x04sinkZ*2\"/v2/{si\
    nk_name=projects/*/sinks/*}:\x04sinkZ/2'/v2/{sink_name=organizations/*/s\
    inks/*}:\x04sinkZ)2!/v2/{sink_name=folders/*/sinks/*}:\x04sinkZ12)/v2/{s\
    ink_name=billingAccounts/*/sinks/*}:\x04sink\x12\x94\x02\n\nDeleteSink\
    \x12$.google.logging.v2.DeleteSinkRequest\x1a\x16.google.protobuf.Empty\
    \"\xc7\x01\x82\xd3\xe4\x93\x02\xc0\x01*\x1b/v2/{sink_name=*/*/sinks/*}Z$\
    *\"/v2/{sink_name=projects/*/sinks/*}Z)*'/v2/{sink_name=organizations/*/\
    sinks/*}Z#*!/v2/{sink_name=folders/*/sinks/*}Z+*)/v2/{sink_name=billingA\
    ccounts/*/sinks/*}\x12\xaf\x02\n\x0eListExclusions\x12(.google.logging.v\
    2.ListExclusionsRequest\x1a).google.logging.v2.ListExclusionsResponse\"\
    \xc7\x01\x82\xd3\xe4\x93\x02\xc0\x01\x12\x1b/v2/{parent=*/*}/exclusionsZ\
    $\x12\"/v2/{parent=projects/*}/exclusionsZ)\x12'/v2/{parent=organization\
    s/*}/exclusionsZ#\x12!/v2/{parent=folders/*}/exclusionsZ+\x12)/v2/{paren\
    t=billingAccounts/*}/exclusions\x12\xa1\x02\n\x0cGetExclusion\x12&.googl\
    e.logging.v2.GetExclusionRequest\x1a\x1f.google.logging.v2.LogExclusion\
    \"\xc7\x01\x82\xd3\xe4\x93\x02\xc0\x01\x12\x1b/v2/{name=*/*/exclusions/*\
    }Z$\x12\"/v2/{name=projects/*/exclusions/*}Z)\x12'/v2/{name=organization\
    s/*/exclusions/*}Z#\x12!/v2/{name=folders/*/exclusions/*}Z+\x12)/v2/{nam\
    e=billingAccounts/*/exclusions/*}\x12\xde\x02\n\x0fCreateExclusion\x12).\
    google.logging.v2.CreateExclusionRequest\x1a\x1f.google.logging.v2.LogEx\
    clusion\"\xfe\x01\x82\xd3\xe4\x93\x02\xf7\x01\"\x1b/v2/{parent=*/*}/excl\
    usions:\texclusionZ/\"\"/v2/{parent=projects/*}/exclusions:\texclusionZ4\
    \"'/v2/{parent=organizations/*}/exclusions:\texclusionZ.\"!/v2/{parent=f\
    olders/*}/exclusions:\texclusionZ6\")/v2/{parent=billingAccounts/*}/excl\
    usions:\texclusion\x12\xde\x02\n\x0fUpdateExclusion\x12).google.logging.\
    v2.UpdateExclusionRequest\x1a\x1f.google.logging.v2.LogExclusion\"\xfe\
    \x01\x82\xd3\xe4\x93\x02\xf7\x012\x1b/v2/{name=*/*/exclusions/*}:\texclu\
    sionZ/2\"/v2/{name=projects/*/exclusions/*}:\texclusionZ42'/v2/{name=org\
    anizations/*/exclusions/*}:\texclusionZ.2!/v2/{name=folders/*/exclusions\
    /*}:\texclusionZ62)/v2/{name=billingAccounts/*/exclusions/*}:\texclusion\
    \x12\x9e\x02\n\x0fDeleteExclusion\x12).google.logging.v2.DeleteExclusion\
    Request\x1a\x16.google.protobuf.Empty\"\xc7\x01\x82\xd3\xe4\x93\x02\xc0\
    \x01*\x1b/v2/{name=*/*/exclusions/*}Z$*\"/v2/{name=projects/*/exclusions\
    /*}Z)*'/v2/{name=organizations/*/exclusions/*}Z#*!/v2/{name=folders/*/ex\
    clusions/*}Z+*)/v2/{name=billingAccounts/*/exclusions/*}\x1a\xdf\x01\xd2\
    A\xc2\x01https://www.googleapis.com/auth/cloud-platform,https://www.goog\
    leapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth\
    /logging.admin,https://www.googleapis.com/auth/logging.read\xcaA\x16logg\
    ing.googleapis.comB\x9e\x01\n\x15com.google.logging.v2B\x12LoggingConfig\
    ProtoP\x01Z8google.golang.org/genproto/googleapis/logging/v2;logging\xf8\
    \x01\x01\xaa\x02\x17Google.Cloud.Logging.V2\xca\x02\x17Google\\Cloud\\Lo\
    gging\\V2J\x9b\x9c\x01\n\x07\x12\x05\x0f\0\xa3\x05\x01\n\xbe\x04\n\x01\
    \x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\x20LLC.\n\
    \n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\
    \x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\
    \x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20ma\
    y\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1a\n\t\n\x02\x03\0\x12\
    \x03\x13\0(\n\t\n\x02\x03\x01\x12\x03\x14\0%\n\t\n\x02\x03\x02\x12\x03\
    \x15\0*\n\t\n\x02\x03\x03\x12\x03\x16\0)\n\t\n\x02\x03\x04\x12\x03\x17\0\
    &\n\t\n\x02\x03\x05\x12\x03\x18\0!\n\x08\n\x01\x08\x12\x03\x1a\0\x1f\n\t\
    \n\x02\x08\x1f\x12\x03\x1a\0\x1f\n\x08\n\x01\x08\x12\x03\x1b\04\n\t\n\
    \x02\x08%\x12\x03\x1b\04\n\x08\n\x01\x08\x12\x03\x1c\0O\n\t\n\x02\x08\
    \x0b\x12\x03\x1c\0O\n\x08\n\x01\x08\x12\x03\x1d\0\"\n\t\n\x02\x08\n\x12\
    \x03\x1d\0\"\n\x08\n\x01\x08\x12\x03\x1e\03\n\t\n\x02\x08\x08\x12\x03\
    \x1e\03\n\x08\n\x01\x08\x12\x03\x1f\0.\n\t\n\x02\x08\x01\x12\x03\x1f\0.\
    \n\x08\n\x01\x08\x12\x03\x20\04\n\t\n\x02\x08)\x12\x03\x20\04\nG\n\x02\
    \x06\0\x12\x05#\0\x96\x02\x01\x1a:\x20Service\x20for\x20configuring\x20s\
    inks\x20used\x20to\x20route\x20log\x20entries.\n\n\n\n\x03\x06\0\x01\x12\
    \x03#\x08\x17\n\n\n\x03\x06\0\x03\x12\x03$\x02>\n\x0c\n\x05\x06\0\x03\
    \x99\x08\x12\x03$\x02>\n\x0b\n\x03\x06\0\x03\x12\x04%\x02)5\n\r\n\x05\
    \x06\0\x03\x9a\x08\x12\x04%\x02)5\n\x1c\n\x04\x06\0\x02\0\x12\x04,\x02<\
    \x03\x1a\x0e\x20Lists\x20sinks.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03,\
    \x06\x0f\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03,\x10\x20\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03,+<\n\r\n\x05\x06\0\x02\0\x04\x12\x04-\x04;\x06\n\x11\
    \n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04-\x04;\x06\n\x1c\n\x04\x06\0\
    \x02\x01\x12\x04?\x02O\x03\x1a\x0e\x20Gets\x20a\x20sink.\n\n\x0c\n\x05\
    \x06\0\x02\x01\x01\x12\x03?\x06\r\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03?\
    \x0e\x1c\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03?'.\n\r\n\x05\x06\0\x02\
    \x01\x04\x12\x04@\x04N\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\
    \x04@\x04N\x06\n\xac\x02\n\x04\x06\0\x02\x02\x12\x04U\x02j\x03\x1a\x9d\
    \x02\x20Creates\x20a\x20sink\x20that\x20exports\x20specified\x20log\x20e\
    ntries\x20to\x20a\x20destination.\x20The\n\x20export\x20of\x20newly-inge\
    sted\x20log\x20entries\x20begins\x20immediately,\x20unless\x20the\x20sin\
    k's\n\x20`writer_identity`\x20is\x20not\x20permitted\x20to\x20write\x20t\
    o\x20the\x20destination.\x20A\x20sink\x20can\n\x20export\x20log\x20entri\
    es\x20only\x20from\x20the\x20resource\x20owning\x20the\x20sink.\n\n\x0c\
    \n\x05\x06\0\x02\x02\x01\x12\x03U\x06\x10\n\x0c\n\x05\x06\0\x02\x02\x02\
    \x12\x03U\x11\"\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03U-4\n\r\n\x05\x06\0\
    \x02\x02\x04\x12\x04V\x04i\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\
    \x12\x04V\x04i\x06\n\x82\x02\n\x04\x06\0\x02\x03\x12\x05q\x02\x96\x01\
    \x03\x1a\xf2\x01\x20Updates\x20a\x20sink.\x20This\x20method\x20replaces\
    \x20the\x20following\x20fields\x20in\x20the\x20existing\n\x20sink\x20wit\
    h\x20values\x20from\x20the\x20new\x20sink:\x20`destination`,\x20and\x20`\
    filter`.\n\n\x20The\x20updated\x20sink\x20might\x20also\x20have\x20a\x20\
    new\x20`writer_identity`;\x20see\x20the\n\x20`unique_writer_identity`\
    \x20field.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03q\x06\x10\n\x0c\n\x05\
    \x06\0\x02\x03\x02\x12\x03q\x11\"\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03q\
    -4\n\x0e\n\x05\x06\0\x02\x03\x04\x12\x05r\x04\x95\x01\x06\n\x12\n\t\x06\
    \0\x02\x03\x04\xb0\xca\xbc\"\x12\x05r\x04\x95\x01\x06\ny\n\x04\x06\0\x02\
    \x04\x12\x06\x9a\x01\x02\xaa\x01\x03\x1ai\x20Deletes\x20a\x20sink.\x20If\
    \x20the\x20sink\x20has\x20a\x20unique\x20`writer_identity`,\x20then\x20t\
    hat\n\x20service\x20account\x20is\x20also\x20deleted.\n\n\r\n\x05\x06\0\
    \x02\x04\x01\x12\x04\x9a\x01\x06\x10\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\
    \x9a\x01\x11\"\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\x9a\x01-B\n\x0f\n\x05\
    \x06\0\x02\x04\x04\x12\x06\x9b\x01\x04\xa9\x01\x06\n\x13\n\t\x06\0\x02\
    \x04\x04\xb0\xca\xbc\"\x12\x06\x9b\x01\x04\xa9\x01\x06\n@\n\x04\x06\0\
    \x02\x05\x12\x06\xad\x01\x02\xbd\x01\x03\x1a0\x20Lists\x20all\x20the\x20\
    exclusions\x20in\x20a\x20parent\x20resource.\n\n\r\n\x05\x06\0\x02\x05\
    \x01\x12\x04\xad\x01\x06\x14\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\xad\x01\
    \x15*\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\xad\x015K\n\x0f\n\x05\x06\0\
    \x02\x05\x04\x12\x06\xae\x01\x04\xbc\x01\x06\n\x13\n\t\x06\0\x02\x05\x04\
    \xb0\xca\xbc\"\x12\x06\xae\x01\x04\xbc\x01\x06\n7\n\x04\x06\0\x02\x06\
    \x12\x06\xc0\x01\x02\xd0\x01\x03\x1a'\x20Gets\x20the\x20description\x20o\
    f\x20an\x20exclusion.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\xc0\x01\x06\
    \x12\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\xc0\x01\x13&\n\r\n\x05\x06\0\
    \x02\x06\x03\x12\x04\xc0\x011=\n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\xc1\
    \x01\x04\xcf\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x06\
    \xc1\x01\x04\xcf\x01\x06\n\xb9\x01\n\x04\x06\0\x02\x07\x12\x06\xd5\x01\
    \x02\xea\x01\x03\x1a\xa8\x01\x20Creates\x20a\x20new\x20exclusion\x20in\
    \x20a\x20specified\x20parent\x20resource.\n\x20Only\x20log\x20entries\
    \x20belonging\x20to\x20that\x20resource\x20can\x20be\x20excluded.\n\x20Y\
    ou\x20can\x20have\x20up\x20to\x2010\x20exclusions\x20in\x20a\x20resource\
    .\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xd5\x01\x06\x15\n\r\n\x05\x06\0\
    \x02\x07\x02\x12\x04\xd5\x01\x16,\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\
    \xd5\x017C\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\xd6\x01\x04\xe9\x01\x06\
    \n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\xd6\x01\x04\xe9\x01\
    \x06\nJ\n\x04\x06\0\x02\x08\x12\x06\xed\x01\x02\x82\x02\x03\x1a:\x20Chan\
    ges\x20one\x20or\x20more\x20properties\x20of\x20an\x20existing\x20exclus\
    ion.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xed\x01\x06\x15\n\r\n\x05\x06\
    \0\x02\x08\x02\x12\x04\xed\x01\x16,\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\
    \xed\x017C\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xee\x01\x04\x81\x02\x06\
    \n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xee\x01\x04\x81\x02\
    \x06\n'\n\x04\x06\0\x02\t\x12\x06\x85\x02\x02\x95\x02\x03\x1a\x17\x20Del\
    etes\x20an\x20exclusion.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\x85\x02\x06\
    \x15\n\r\n\x05\x06\0\x02\t\x02\x12\x04\x85\x02\x16,\n\r\n\x05\x06\0\x02\
    \t\x03\x12\x04\x85\x027L\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\x86\x02\x04\
    \x94\x02\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\x86\x02\x04\
    \x94\x02\x06\n\xc7\x02\n\x02\x04\0\x12\x06\x9d\x02\0\xfe\x02\x01\x1a\xb8\
    \x02\x20Describes\x20a\x20sink\x20used\x20to\x20export\x20log\x20entries\
    \x20to\x20one\x20of\x20the\x20following\n\x20destinations\x20in\x20any\
    \x20project:\x20a\x20Cloud\x20Storage\x20bucket,\x20a\x20BigQuery\x20dat\
    aset,\x20or\x20a\n\x20Cloud\x20Pub/Sub\x20topic.\x20A\x20logs\x20filter\
    \x20controls\x20which\x20log\x20entries\x20are\x20exported.\n\x20The\x20\
    sink\x20must\x20be\x20created\x20within\x20a\x20project,\x20organization\
    ,\x20billing\x20account,\x20or\n\x20folder.\n\n\x0b\n\x03\x04\0\x01\x12\
    \x04\x9d\x02\x08\x0f\n\xb1\x01\n\x04\x04\0\x04\0\x12\x06\xa1\x02\x02\xaa\
    \x02\x03\x1a\xa0\x01\x20Available\x20log\x20entry\x20formats.\x20Log\x20\
    entries\x20can\x20be\x20written\x20to\n\x20Logging\x20in\x20either\x20fo\
    rmat\x20and\x20can\x20be\x20exported\x20in\x20either\x20format.\n\x20Ver\
    sion\x202\x20is\x20the\x20preferred\x20format.\n\n\r\n\x05\x04\0\x04\0\
    \x01\x12\x04\xa1\x02\x07\x14\nH\n\x06\x04\0\x04\0\x02\0\x12\x04\xa3\x02\
    \x04#\x1a8\x20An\x20unspecified\x20format\x20version\x20that\x20will\x20\
    default\x20to\x20V2.\n\n\x0f\n\x07\x04\0\x04\0\x02\0\x01\x12\x04\xa3\x02\
    \x04\x1e\n\x0f\n\x07\x04\0\x04\0\x02\0\x02\x12\x04\xa3\x02!\"\n.\n\x06\
    \x04\0\x04\0\x02\x01\x12\x04\xa6\x02\x04\x0b\x1a\x1e\x20`LogEntry`\x20ve\
    rsion\x202\x20format.\n\n\x0f\n\x07\x04\0\x04\0\x02\x01\x01\x12\x04\xa6\
    \x02\x04\x06\n\x0f\n\x07\x04\0\x04\0\x02\x01\x02\x12\x04\xa6\x02\t\n\n.\
    \n\x06\x04\0\x04\0\x02\x02\x12\x04\xa9\x02\x04\x0b\x1a\x1e\x20`LogEntry`\
    \x20version\x201\x20format.\n\n\x0f\n\x07\x04\0\x04\0\x02\x02\x01\x12\
    \x04\xa9\x02\x04\x06\n\x0f\n\x07\x04\0\x04\0\x02\x02\x02\x12\x04\xa9\x02\
    \t\n\n\xb6\x02\n\x04\x04\0\x02\0\x12\x04\xb1\x02\x02\x12\x1a\xa7\x02\x20\
    Required.\x20The\x20client-assigned\x20sink\x20identifier,\x20unique\x20\
    within\x20the\n\x20project.\x20Example:\x20`\"my-syslog-errors-to-pubsub\
    \"`.\x20Sink\x20identifiers\x20are\n\x20limited\x20to\x20100\x20characte\
    rs\x20and\x20can\x20include\x20only\x20the\x20following\x20characters:\n\
    \x20upper\x20and\x20lower-case\x20alphanumeric\x20characters,\x20undersc\
    ores,\x20hyphens,\x20and\n\x20periods.\n\n\r\n\x05\x04\0\x02\0\x05\x12\
    \x04\xb1\x02\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xb1\x02\t\r\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\xb1\x02\x10\x11\n\xe6\x03\n\x04\x04\0\x02\
    \x01\x12\x04\xbd\x02\x02\x19\x1a\xd7\x03\x20Required.\x20The\x20export\
    \x20destination:\n\n\x20\x20\x20\x20\x20\"storage.googleapis.com/[GCS_BU\
    CKET]\"\n\x20\x20\x20\x20\x20\"bigquery.googleapis.com/projects/[PROJECT\
    _ID]/datasets/[DATASET]\"\n\x20\x20\x20\x20\x20\"pubsub.googleapis.com/p\
    rojects/[PROJECT_ID]/topics/[TOPIC_ID]\"\n\n\x20The\x20sink's\x20`writer\
    _identity`,\x20set\x20when\x20the\x20sink\x20is\x20created,\x20must\n\
    \x20have\x20permission\x20to\x20write\x20to\x20the\x20destination\x20or\
    \x20else\x20the\x20log\n\x20entries\x20are\x20not\x20exported.\x20For\
    \x20more\x20information,\x20see\n\x20[Exporting\x20Logs\x20with\x20Sinks\
    ](/logging/docs/api/tasks/exporting-logs).\n\n\r\n\x05\x04\0\x02\x01\x05\
    \x12\x04\xbd\x02\x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xbd\x02\t\
    \x14\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xbd\x02\x17\x18\n\x9d\x02\n\x04\
    \x04\0\x02\x02\x12\x04\xc4\x02\x02\x14\x1a\x8e\x02\x20Optional.\x20An\
    \x20[advanced\x20logs\x20filter](/logging/docs/view/advanced-queries).\
    \x20The\x20only\n\x20exported\x20log\x20entries\x20are\x20those\x20that\
    \x20are\x20in\x20the\x20resource\x20owning\x20the\x20sink\x20and\n\x20th\
    at\x20match\x20the\x20filter.\x20For\x20example:\n\n\x20\x20\x20\x20\x20\
    logName=\"projects/[PROJECT_ID]/logs/[LOG_ID]\"\x20AND\x20severity>=ERRO\
    R\n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xc4\x02\x02\x08\n\r\n\x05\x04\0\
    \x02\x02\x01\x12\x04\xc4\x02\t\x0f\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\
    \xc4\x02\x12\x13\n\x97\x01\n\x04\x04\0\x02\x03\x12\x04\xc8\x02\x02>\x1a\
    \x88\x01\x20Deprecated.\x20The\x20log\x20entry\x20format\x20to\x20use\
    \x20for\x20this\x20sink's\x20exported\x20log\n\x20entries.\x20The\x20v2\
    \x20format\x20is\x20used\x20by\x20default\x20and\x20cannot\x20be\x20chan\
    ged.\n\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\xc8\x02\x02\x0f\n\r\n\x05\x04\
    \0\x02\x03\x01\x12\x04\xc8\x02\x10%\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\
    \xc8\x02()\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\xc8\x02*=\n\x0e\n\x06\x04\
    \0\x02\x03\x08\x03\x12\x04\xc8\x02+<\n\xff\x05\n\x04\x04\0\x02\x04\x12\
    \x04\xd8\x02\x02\x1d\x1a\xf0\x05\x20Output\x20only.\x20An\x20IAM\x20iden\
    tity&mdash;a\x20service\x20account\x20or\x20group&mdash;under\n\x20which\
    \x20Logging\x20writes\x20the\x20exported\x20log\x20entries\x20to\x20the\
    \x20sink's\x20destination.\n\x20This\x20field\x20is\x20set\x20by\n\x20[s\
    inks.create][google.logging.v2.ConfigServiceV2.CreateSink]\n\x20and\n\
    \x20[sinks.update][google.logging.v2.ConfigServiceV2.UpdateSink]\n\x20ba\
    sed\x20on\x20the\x20value\x20of\x20`unique_writer_identity`\x20in\x20tho\
    se\x20methods.\n\n\x20Until\x20you\x20grant\x20this\x20identity\x20write\
    -access\x20to\x20the\x20destination,\x20log\x20entry\n\x20exports\x20fro\
    m\x20this\x20sink\x20will\x20fail.\x20For\x20more\x20information,\n\x20s\
    ee\x20[Granting\x20Access\x20for\x20a\n\x20Resource](/iam/docs/granting-\
    roles-to-service-accounts#granting_access_to_a_service_account_for_a_res\
    ource).\n\x20Consult\x20the\x20destination\x20service's\x20documentation\
    \x20to\x20determine\x20the\n\x20appropriate\x20IAM\x20roles\x20to\x20ass\
    ign\x20to\x20the\x20identity.\n\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\xd8\
    \x02\x02\x08\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\xd8\x02\t\x18\n\r\n\x05\
    \x04\0\x02\x04\x03\x12\x04\xd8\x02\x1b\x1c\n\xd6\x06\n\x04\x04\0\x02\x05\
    \x12\x04\xe7\x02\x02\x1c\x1a\xc7\x06\x20Optional.\x20This\x20field\x20ap\
    plies\x20only\x20to\x20sinks\x20owned\x20by\x20organizations\x20and\n\
    \x20folders.\x20If\x20the\x20field\x20is\x20false,\x20the\x20default,\
    \x20only\x20the\x20logs\x20owned\x20by\x20the\n\x20sink's\x20parent\x20r\
    esource\x20are\x20available\x20for\x20export.\x20If\x20the\x20field\x20i\
    s\x20true,\x20then\n\x20logs\x20from\x20all\x20the\x20projects,\x20folde\
    rs,\x20and\x20billing\x20accounts\x20contained\x20in\x20the\n\x20sink's\
    \x20parent\x20resource\x20are\x20also\x20available\x20for\x20export.\x20\
    Whether\x20a\x20particular\n\x20log\x20entry\x20from\x20the\x20children\
    \x20is\x20exported\x20depends\x20on\x20the\x20sink's\x20filter\n\x20expr\
    ession.\x20For\x20example,\x20if\x20this\x20field\x20is\x20true,\x20then\
    \x20the\x20filter\n\x20`resource.type=gce_instance`\x20would\x20export\
    \x20all\x20Compute\x20Engine\x20VM\x20instance\n\x20log\x20entries\x20fr\
    om\x20all\x20projects\x20in\x20the\x20sink's\x20parent.\x20To\x20only\
    \x20export\x20entries\n\x20from\x20certain\x20child\x20projects,\x20filt\
    er\x20on\x20the\x20project\x20part\x20of\x20the\x20log\x20name:\n\n\x20\
    \x20\x20\x20\x20logName:(\"projects/test-project1/\"\x20OR\x20\"projects\
    /test-project2/\")\x20AND\n\x20\x20\x20\x20\x20resource.type=gce_instanc\
    e\n\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\xe7\x02\x02\x06\n\r\n\x05\x04\0\
    \x02\x05\x01\x12\x04\xe7\x02\x07\x17\n\r\n\x05\x04\0\x02\x05\x03\x12\x04\
    \xe7\x02\x1a\x1b\n:\n\x04\x04\0\x08\0\x12\x06\xea\x02\x02\xed\x02\x03\
    \x1a*\x20Optional.\x20Destination\x20dependent\x20options.\n\n\r\n\x05\
    \x04\0\x08\0\x01\x12\x04\xea\x02\x08\x0f\nO\n\x04\x04\0\x02\x06\x12\x04\
    \xec\x02\x04*\x1aA\x20Optional.\x20Options\x20that\x20affect\x20sinks\
    \x20exporting\x20data\x20to\x20BigQuery.\n\n\r\n\x05\x04\0\x02\x06\x06\
    \x12\x04\xec\x02\x04\x13\n\r\n\x05\x04\0\x02\x06\x01\x12\x04\xec\x02\x14\
    $\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\xec\x02')\nq\n\x04\x04\0\x02\x07\
    \x12\x04\xf2\x02\x02-\x1ac\x20Output\x20only.\x20The\x20creation\x20time\
    stamp\x20of\x20the\x20sink.\n\n\x20This\x20field\x20may\x20not\x20be\x20\
    present\x20for\x20older\x20sinks.\n\n\r\n\x05\x04\0\x02\x07\x06\x12\x04\
    \xf2\x02\x02\x1b\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xf2\x02\x1c'\n\r\n\
    \x05\x04\0\x02\x07\x03\x12\x04\xf2\x02*,\nt\n\x04\x04\0\x02\x08\x12\x04\
    \xf7\x02\x02-\x1af\x20Output\x20only.\x20The\x20last\x20update\x20timest\
    amp\x20of\x20the\x20sink.\n\n\x20This\x20field\x20may\x20not\x20be\x20pr\
    esent\x20for\x20older\x20sinks.\n\n\r\n\x05\x04\0\x02\x08\x06\x12\x04\
    \xf7\x02\x02\x1b\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\xf7\x02\x1c'\n\r\n\
    \x05\x04\0\x02\x08\x03\x12\x04\xf7\x02*,\n2\n\x04\x04\0\x02\t\x12\x04\
    \xfa\x02\x02@\x1a$\x20Do\x20not\x20use.\x20This\x20field\x20is\x20ignore\
    d.\n\n\r\n\x05\x04\0\x02\t\x06\x12\x04\xfa\x02\x02\x1b\n\r\n\x05\x04\0\
    \x02\t\x01\x12\x04\xfa\x02\x1c&\n\r\n\x05\x04\0\x02\t\x03\x12\x04\xfa\
    \x02)+\n\r\n\x05\x04\0\x02\t\x08\x12\x04\xfa\x02,?\n\x0e\n\x06\x04\0\x02\
    \t\x08\x03\x12\x04\xfa\x02->\n2\n\x04\x04\0\x02\n\x12\x04\xfd\x02\x02>\
    \x1a$\x20Do\x20not\x20use.\x20This\x20field\x20is\x20ignored.\n\n\r\n\
    \x05\x04\0\x02\n\x06\x12\x04\xfd\x02\x02\x1b\n\r\n\x05\x04\0\x02\n\x01\
    \x12\x04\xfd\x02\x1c$\n\r\n\x05\x04\0\x02\n\x03\x12\x04\xfd\x02')\n\r\n\
    \x05\x04\0\x02\n\x08\x12\x04\xfd\x02*=\n\x0e\n\x06\x04\0\x02\n\x08\x03\
    \x12\x04\xfd\x02+<\nW\n\x02\x04\x01\x12\x06\x81\x03\0\x8a\x03\x01\x1aI\
    \x20Options\x20that\x20change\x20functionality\x20of\x20a\x20sink\x20exp\
    orting\x20data\x20to\x20BigQuery.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x81\
    \x03\x08\x17\n\xab\x03\n\x04\x04\x01\x02\0\x12\x04\x89\x03\x02\"\x1a\x9c\
    \x03\x20Optional.\x20Whether\x20to\x20use\x20[BigQuery's\x20partition\n\
    \x20tables](/bigquery/docs/partitioned-tables).\x20By\x20default,\x20Log\
    ging\n\x20creates\x20dated\x20tables\x20based\x20on\x20the\x20log\x20ent\
    ries'\x20timestamps,\x20e.g.\n\x20syslog_20170523.\x20With\x20partitione\
    d\x20tables\x20the\x20date\x20suffix\x20is\x20no\x20longer\n\x20present\
    \x20and\x20[special\x20query\n\x20syntax](/bigquery/docs/querying-partit\
    ioned-tables)\x20has\x20to\x20be\x20used\x20instead.\n\x20In\x20both\x20\
    cases,\x20tables\x20are\x20sharded\x20based\x20on\x20UTC\x20timezone.\n\
    \n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x89\x03\x02\x06\n\r\n\x05\x04\x01\
    \x02\0\x01\x12\x04\x89\x03\x07\x1d\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\
    \x89\x03\x20!\n.\n\x02\x04\x02\x12\x06\x8d\x03\0\xa0\x03\x01\x1a\x20\x20\
    The\x20parameters\x20to\x20`ListSinks`.\n\n\x0b\n\x03\x04\x02\x01\x12\
    \x04\x8d\x03\x08\x18\n\xd8\x01\n\x04\x04\x02\x02\0\x12\x04\x94\x03\x02\
    \x14\x1a\xc9\x01\x20Required.\x20The\x20parent\x20resource\x20whose\x20s\
    inks\x20are\x20to\x20be\x20listed:\n\n\x20\x20\x20\x20\x20\"projects/[PR\
    OJECT_ID]\"\n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]\"\n\
    \x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]\"\n\x20\x20\
    \x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\r\n\x05\x04\x02\x02\0\x05\x12\
    \x04\x94\x03\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x94\x03\t\x0f\n\
    \r\n\x05\x04\x02\x02\0\x03\x12\x04\x94\x03\x12\x13\n\x9f\x02\n\x04\x04\
    \x02\x02\x01\x12\x04\x9a\x03\x02\x18\x1a\x90\x02\x20Optional.\x20If\x20p\
    resent,\x20then\x20retrieve\x20the\x20next\x20batch\x20of\x20results\x20\
    from\x20the\n\x20preceding\x20call\x20to\x20this\x20method.\x20`pageToke\
    n`\x20must\x20be\x20the\x20value\x20of\n\x20`nextPageToken`\x20from\x20t\
    he\x20previous\x20response.\x20The\x20values\x20of\x20other\x20method\n\
    \x20parameters\x20should\x20be\x20identical\x20to\x20those\x20in\x20the\
    \x20previous\x20call.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\x9a\x03\
    \x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x9a\x03\t\x13\n\r\n\x05\
    \x04\x02\x02\x01\x03\x12\x04\x9a\x03\x16\x17\n\xd8\x01\n\x04\x04\x02\x02\
    \x02\x12\x04\x9f\x03\x02\x16\x1a\xc9\x01\x20Optional.\x20The\x20maximum\
    \x20number\x20of\x20results\x20to\x20return\x20from\x20this\x20request.\
    \n\x20Non-positive\x20values\x20are\x20ignored.\x20The\x20presence\x20of\
    \x20`nextPageToken`\x20in\x20the\n\x20response\x20indicates\x20that\x20m\
    ore\x20results\x20might\x20be\x20available.\n\n\r\n\x05\x04\x02\x02\x02\
    \x05\x12\x04\x9f\x03\x02\x07\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x9f\
    \x03\x08\x11\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\x9f\x03\x14\x15\n1\n\
    \x02\x04\x03\x12\x06\xa3\x03\0\xab\x03\x01\x1a#\x20Result\x20returned\
    \x20from\x20`ListSinks`.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa3\x03\x08\
    \x19\n\x20\n\x04\x04\x03\x02\0\x12\x04\xa5\x03\x02\x1d\x1a\x12\x20A\x20l\
    ist\x20of\x20sinks.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xa5\x03\x02\n\
    \n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xa5\x03\x0b\x12\n\r\n\x05\x04\x03\
    \x02\0\x01\x12\x04\xa5\x03\x13\x18\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\
    \xa5\x03\x1b\x1c\n\xdf\x01\n\x04\x04\x03\x02\x01\x12\x04\xaa\x03\x02\x1d\
    \x1a\xd0\x01\x20If\x20there\x20might\x20be\x20more\x20results\x20than\
    \x20appear\x20in\x20this\x20response,\x20then\n\x20`nextPageToken`\x20is\
    \x20included.\x20To\x20get\x20the\x20next\x20set\x20of\x20results,\x20ca\
    ll\x20the\x20same\n\x20method\x20again\x20using\x20the\x20value\x20of\
    \x20`nextPageToken`\x20as\x20`pageToken`.\n\n\r\n\x05\x04\x03\x02\x01\
    \x05\x12\x04\xaa\x03\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xaa\
    \x03\t\x18\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xaa\x03\x1b\x1c\n,\n\
    \x02\x04\x04\x12\x06\xae\x03\0\xb8\x03\x01\x1a\x1e\x20The\x20parameters\
    \x20to\x20`GetSink`.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xae\x03\x08\x16\n\
    \xbd\x02\n\x04\x04\x04\x02\0\x12\x04\xb7\x03\x02\x17\x1a\xae\x02\x20Requ\
    ired.\x20The\x20resource\x20name\x20of\x20the\x20sink:\n\n\x20\x20\x20\
    \x20\x20\"projects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\x20\
    \"organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\
    \x20\"billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\"\n\x20\x20\
    \x20\x20\x20\"folders/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\x20Example:\x20`\
    \"projects/my-project-id/sinks/my-sink-id\"`.\n\n\r\n\x05\x04\x04\x02\0\
    \x05\x12\x04\xb7\x03\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb7\x03\
    \t\x12\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xb7\x03\x15\x16\n/\n\x02\x04\
    \x05\x12\x06\xbb\x03\0\xd6\x03\x01\x1a!\x20The\x20parameters\x20to\x20`C\
    reateSink`.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xbb\x03\x08\x19\n\x9a\x02\
    \n\x04\x04\x05\x02\0\x12\x04\xc4\x03\x02\x14\x1a\x8b\x02\x20Required.\
    \x20The\x20resource\x20in\x20which\x20to\x20create\x20the\x20sink:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"org\
    anizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[B\
    ILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\
    \x20Examples:\x20`\"projects/my-logging-project\"`,\x20`\"organizations/\
    123456789\"`.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xc4\x03\x02\x08\n\r\
    \n\x05\x04\x05\x02\0\x01\x12\x04\xc4\x03\t\x0f\n\r\n\x05\x04\x05\x02\0\
    \x03\x12\x04\xc4\x03\x12\x13\np\n\x04\x04\x05\x02\x01\x12\x04\xc8\x03\
    \x02\x13\x1ab\x20Required.\x20The\x20new\x20sink,\x20whose\x20`name`\x20\
    parameter\x20is\x20a\x20sink\x20identifier\x20that\n\x20is\x20not\x20alr\
    eady\x20in\x20use.\n\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\xc8\x03\x02\t\
    \n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xc8\x03\n\x0e\n\r\n\x05\x04\x05\
    \x02\x01\x03\x12\x04\xc8\x03\x11\x12\n\xd3\x05\n\x04\x04\x05\x02\x02\x12\
    \x04\xd5\x03\x02\"\x1a\xc4\x05\x20Optional.\x20Determines\x20the\x20kind\
    \x20of\x20IAM\x20identity\x20returned\x20as\x20`writer_identity`\n\x20in\
    \x20the\x20new\x20sink.\x20If\x20this\x20value\x20is\x20omitted\x20or\
    \x20set\x20to\x20false,\x20and\x20if\x20the\n\x20sink's\x20parent\x20is\
    \x20a\x20project,\x20then\x20the\x20value\x20returned\x20as\x20`writer_i\
    dentity`\x20is\n\x20the\x20same\x20group\x20or\x20service\x20account\x20\
    used\x20by\x20Logging\x20before\x20the\x20addition\x20of\n\x20writer\x20\
    identities\x20to\x20this\x20API.\x20The\x20sink's\x20destination\x20must\
    \x20be\x20in\x20the\x20same\n\x20project\x20as\x20the\x20sink\x20itself.\
    \n\n\x20If\x20this\x20field\x20is\x20set\x20to\x20true,\x20or\x20if\x20t\
    he\x20sink\x20is\x20owned\x20by\x20a\x20non-project\n\x20resource\x20suc\
    h\x20as\x20an\x20organization,\x20then\x20the\x20value\x20of\x20`writer_\
    identity`\x20will\n\x20be\x20a\x20unique\x20service\x20account\x20used\
    \x20only\x20for\x20exports\x20from\x20the\x20new\x20sink.\x20For\n\x20mo\
    re\x20information,\x20see\x20`writer_identity`\x20in\x20[LogSink][google\
    .logging.v2.LogSink].\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xd5\x03\
    \x02\x06\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xd5\x03\x07\x1d\n\r\n\x05\
    \x04\x05\x02\x02\x03\x12\x04\xd5\x03\x20!\n/\n\x02\x04\x06\x12\x06\xd9\
    \x03\0\x85\x04\x01\x1a!\x20The\x20parameters\x20to\x20`UpdateSink`.\n\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\xd9\x03\x08\x19\n\x84\x03\n\x04\x04\x06\
    \x02\0\x12\x04\xe3\x03\x02\x17\x1a\xf5\x02\x20Required.\x20The\x20full\
    \x20resource\x20name\x20of\x20the\x20sink\x20to\x20update,\x20including\
    \x20the\n\x20parent\x20resource\x20and\x20the\x20sink\x20identifier:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\x20\x20\
    \x20\x20\x20\"organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\n\x20\
    \x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\"\
    \n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\x20Exa\
    mple:\x20`\"projects/my-project-id/sinks/my-sink-id\"`.\n\n\r\n\x05\x04\
    \x06\x02\0\x05\x12\x04\xe3\x03\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\
    \x04\xe3\x03\t\x12\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xe3\x03\x15\x16\n\
    s\n\x04\x04\x06\x02\x01\x12\x04\xe7\x03\x02\x13\x1ae\x20Required.\x20The\
    \x20updated\x20sink,\x20whose\x20name\x20is\x20the\x20same\x20identifier\
    \x20that\x20appears\n\x20as\x20part\x20of\x20`sink_name`.\n\n\r\n\x05\
    \x04\x06\x02\x01\x06\x12\x04\xe7\x03\x02\t\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xe7\x03\n\x0e\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xe7\x03\x11\
    \x12\n\x8c\x05\n\x04\x04\x06\x02\x02\x12\x04\xf4\x03\x02\"\x1a\xfd\x04\
    \x20Optional.\x20See\x20[sinks.create][google.logging.v2.ConfigServiceV2\
    .CreateSink]\n\x20for\x20a\x20description\x20of\x20this\x20field.\x20Whe\
    n\x20updating\x20a\x20sink,\x20the\x20effect\x20of\x20this\n\x20field\
    \x20on\x20the\x20value\x20of\x20`writer_identity`\x20in\x20the\x20update\
    d\x20sink\x20depends\x20on\x20both\n\x20the\x20old\x20and\x20new\x20valu\
    es\x20of\x20this\x20field:\n\n\x20+\x20\x20\x20If\x20the\x20old\x20and\
    \x20new\x20values\x20of\x20this\x20field\x20are\x20both\x20false\x20or\
    \x20both\x20true,\n\x20\x20\x20\x20\x20then\x20there\x20is\x20no\x20chan\
    ge\x20to\x20the\x20sink's\x20`writer_identity`.\n\x20+\x20\x20\x20If\x20\
    the\x20old\x20value\x20is\x20false\x20and\x20the\x20new\x20value\x20is\
    \x20true,\x20then\n\x20\x20\x20\x20\x20`writer_identity`\x20is\x20change\
    d\x20to\x20a\x20unique\x20service\x20account.\n\x20+\x20\x20\x20It\x20is\
    \x20an\x20error\x20if\x20the\x20old\x20value\x20is\x20true\x20and\x20the\
    \x20new\x20value\x20is\n\x20\x20\x20\x20\x20set\x20to\x20false\x20or\x20\
    defaulted\x20to\x20false.\n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xf4\
    \x03\x02\x06\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xf4\x03\x07\x1d\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xf4\x03\x20!\n\x96\x05\n\x04\x04\x06\
    \x02\x03\x12\x04\x84\x04\x02,\x1a\x87\x05\x20Optional.\x20Field\x20mask\
    \x20that\x20specifies\x20the\x20fields\x20in\x20`sink`\x20that\x20need\n\
    \x20an\x20update.\x20A\x20sink\x20field\x20will\x20be\x20overwritten\x20\
    if,\x20and\x20only\x20if,\x20it\x20is\n\x20in\x20the\x20update\x20mask.\
    \x20`name`\x20and\x20output\x20only\x20fields\x20cannot\x20be\x20updated\
    .\n\n\x20An\x20empty\x20updateMask\x20is\x20temporarily\x20treated\x20as\
    \x20using\x20the\x20following\x20mask\n\x20for\x20backwards\x20compatibi\
    lity\x20purposes:\n\x20\x20\x20destination,filter,includeChildren\n\x20A\
    t\x20some\x20point\x20in\x20the\x20future,\x20behavior\x20will\x20be\x20\
    removed\x20and\x20specifying\x20an\n\x20empty\x20updateMask\x20will\x20b\
    e\x20an\x20error.\n\n\x20For\x20a\x20detailed\x20`FieldMask`\x20definiti\
    on,\x20see\n\x20https://developers.google.com/protocol-buffers/docs/refe\
    rence/google.protobuf#google.protobuf.FieldMask\n\n\x20Example:\x20`upda\
    teMask=filter`.\n\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\x84\x04\x02\x1b\
    \n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x84\x04\x1c'\n\r\n\x05\x04\x06\
    \x02\x03\x03\x12\x04\x84\x04*+\n/\n\x02\x04\x07\x12\x06\x88\x04\0\x93\
    \x04\x01\x1a!\x20The\x20parameters\x20to\x20`DeleteSink`.\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x88\x04\x08\x19\n\x84\x03\n\x04\x04\x07\x02\0\x12\
    \x04\x92\x04\x02\x17\x1a\xf5\x02\x20Required.\x20The\x20full\x20resource\
    \x20name\x20of\x20the\x20sink\x20to\x20delete,\x20including\x20the\n\x20\
    parent\x20resource\x20and\x20the\x20sink\x20identifier:\n\n\x20\x20\x20\
    \x20\x20\"projects/[PROJECT_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\x20\
    \"organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]\"\n\x20\x20\x20\x20\
    \x20\"billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]\"\n\x20\x20\
    \x20\x20\x20\"folders/[FOLDER_ID]/sinks/[SINK_ID]\"\n\n\x20Example:\x20`\
    \"projects/my-project-id/sinks/my-sink-id\"`.\n\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\x92\x04\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x92\x04\
    \t\x12\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x92\x04\x15\x16\n\xb0\x03\n\
    \x02\x04\x08\x12\x06\x9b\x04\0\xbd\x04\x01\x1a\xa1\x03\x20Specifies\x20a\
    \x20set\x20of\x20log\x20entries\x20that\x20are\x20not\x20to\x20be\x20sto\
    red\x20in\n\x20Logging.\x20If\x20your\x20GCP\x20resource\x20receives\x20\
    a\x20large\x20volume\x20of\x20logs,\x20you\x20can\n\x20use\x20exclusions\
    \x20to\x20reduce\x20your\x20chargeable\x20logs.\x20Exclusions\x20are\n\
    \x20processed\x20after\x20log\x20sinks,\x20so\x20you\x20can\x20export\
    \x20log\x20entries\x20before\x20they\x20are\n\x20excluded.\x20Note\x20th\
    at\x20organization-level\x20and\x20folder-level\x20exclusions\x20don't\n\
    \x20apply\x20to\x20child\x20resources,\x20and\x20that\x20you\x20can't\
    \x20exclude\x20audit\x20log\x20entries.\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\x9b\x04\x08\x14\n\xd2\x01\n\x04\x04\x08\x02\0\x12\x04\x9f\x04\x02\
    \x12\x1a\xc3\x01\x20Required.\x20A\x20client-assigned\x20identifier,\x20\
    such\x20as\n\x20`\"load-balancer-exclusion\"`.\x20Identifiers\x20are\x20\
    limited\x20to\x20100\x20characters\x20and\n\x20can\x20include\x20only\
    \x20letters,\x20digits,\x20underscores,\x20hyphens,\x20and\x20periods.\n\
    \n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x9f\x04\x02\x08\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\x9f\x04\t\r\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9f\
    \x04\x10\x11\n:\n\x04\x04\x08\x02\x01\x12\x04\xa2\x04\x02\x19\x1a,\x20Op\
    tional.\x20A\x20description\x20of\x20this\x20exclusion.\n\n\r\n\x05\x04\
    \x08\x02\x01\x05\x12\x04\xa2\x04\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\xa2\x04\t\x14\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xa2\x04\x17\
    \x18\n\xc4\x03\n\x04\x04\x08\x02\x02\x12\x04\xac\x04\x02\x14\x1a\xb5\x03\
    \x20Required.\x20An\x20[advanced\x20logs\x20filter](/logging/docs/view/a\
    dvanced-queries)\n\x20that\x20matches\x20the\x20log\x20entries\x20to\x20\
    be\x20excluded.\x20By\x20using\x20the\n\x20[sample\x20function](/logging\
    /docs/view/advanced-queries#sample),\n\x20you\x20can\x20exclude\x20less\
    \x20than\x20100%\x20of\x20the\x20matching\x20log\x20entries.\n\x20For\
    \x20example,\x20the\x20following\x20query\x20matches\x2099%\x20of\x20low\
    -severity\x20log\n\x20entries\x20from\x20Google\x20Cloud\x20Storage\x20b\
    uckets:\n\n\x20`\"resource.type=gcs_bucket\x20severity<ERROR\x20sample(i\
    nsertId,\x200.99)\"`\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xac\x04\x02\
    \x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xac\x04\t\x0f\n\r\n\x05\x04\
    \x08\x02\x02\x03\x12\x04\xac\x04\x12\x13\n\xea\x01\n\x04\x04\x08\x02\x03\
    \x12\x04\xb2\x04\x02\x14\x1a\xdb\x01\x20Optional.\x20If\x20set\x20to\x20\
    True,\x20then\x20this\x20exclusion\x20is\x20disabled\x20and\x20it\x20doe\
    s\x20not\n\x20exclude\x20any\x20log\x20entries.\x20You\x20can\x20[update\
    \x20an\n\x20exclusion][google.logging.v2.ConfigServiceV2.UpdateExclusion\
    ]\x20to\x20change\x20the\n\x20value\x20of\x20this\x20field.\n\n\r\n\x05\
    \x04\x08\x02\x03\x05\x12\x04\xb2\x04\x02\x06\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\xb2\x04\x07\x0f\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xb2\
    \x04\x12\x13\n{\n\x04\x04\x08\x02\x04\x12\x04\xb7\x04\x02,\x1am\x20Outpu\
    t\x20only.\x20The\x20creation\x20timestamp\x20of\x20the\x20exclusion.\n\
    \n\x20This\x20field\x20may\x20not\x20be\x20present\x20for\x20older\x20ex\
    clusions.\n\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xb7\x04\x02\x1b\n\r\n\
    \x05\x04\x08\x02\x04\x01\x12\x04\xb7\x04\x1c'\n\r\n\x05\x04\x08\x02\x04\
    \x03\x12\x04\xb7\x04*+\n~\n\x04\x04\x08\x02\x05\x12\x04\xbc\x04\x02,\x1a\
    p\x20Output\x20only.\x20The\x20last\x20update\x20timestamp\x20of\x20the\
    \x20exclusion.\n\n\x20This\x20field\x20may\x20not\x20be\x20present\x20fo\
    r\x20older\x20exclusions.\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xbc\
    \x04\x02\x1b\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xbc\x04\x1c'\n\r\n\
    \x05\x04\x08\x02\x05\x03\x12\x04\xbc\x04*+\n3\n\x02\x04\t\x12\x06\xc0\
    \x04\0\xd3\x04\x01\x1a%\x20The\x20parameters\x20to\x20`ListExclusions`.\
    \n\n\x0b\n\x03\x04\t\x01\x12\x04\xc0\x04\x08\x1d\n\xdd\x01\n\x04\x04\t\
    \x02\0\x12\x04\xc7\x04\x02\x14\x1a\xce\x01\x20Required.\x20The\x20parent\
    \x20resource\x20whose\x20exclusions\x20are\x20to\x20be\x20listed.\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"org\
    anizations/[ORGANIZATION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[B\
    ILLING_ACCOUNT_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\r\
    \n\x05\x04\t\x02\0\x05\x12\x04\xc7\x04\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xc7\x04\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xc7\x04\x12\x13\
    \n\x9f\x02\n\x04\x04\t\x02\x01\x12\x04\xcd\x04\x02\x18\x1a\x90\x02\x20Op\
    tional.\x20If\x20present,\x20then\x20retrieve\x20the\x20next\x20batch\
    \x20of\x20results\x20from\x20the\n\x20preceding\x20call\x20to\x20this\
    \x20method.\x20`pageToken`\x20must\x20be\x20the\x20value\x20of\n\x20`nex\
    tPageToken`\x20from\x20the\x20previous\x20response.\x20The\x20values\x20\
    of\x20other\x20method\n\x20parameters\x20should\x20be\x20identical\x20to\
    \x20those\x20in\x20the\x20previous\x20call.\n\n\r\n\x05\x04\t\x02\x01\
    \x05\x12\x04\xcd\x04\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xcd\x04\
    \t\x13\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xcd\x04\x16\x17\n\xd8\x01\n\
    \x04\x04\t\x02\x02\x12\x04\xd2\x04\x02\x16\x1a\xc9\x01\x20Optional.\x20T\
    he\x20maximum\x20number\x20of\x20results\x20to\x20return\x20from\x20this\
    \x20request.\n\x20Non-positive\x20values\x20are\x20ignored.\x20The\x20pr\
    esence\x20of\x20`nextPageToken`\x20in\x20the\n\x20response\x20indicates\
    \x20that\x20more\x20results\x20might\x20be\x20available.\n\n\r\n\x05\x04\
    \t\x02\x02\x05\x12\x04\xd2\x04\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\x12\
    \x04\xd2\x04\x08\x11\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xd2\x04\x14\x15\
    \n6\n\x02\x04\n\x12\x06\xd6\x04\0\xde\x04\x01\x1a(\x20Result\x20returned\
    \x20from\x20`ListExclusions`.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xd6\x04\
    \x08\x1e\n%\n\x04\x04\n\x02\0\x12\x04\xd8\x04\x02'\x1a\x17\x20A\x20list\
    \x20of\x20exclusions.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xd8\x04\x02\n\
    \n\r\n\x05\x04\n\x02\0\x06\x12\x04\xd8\x04\x0b\x17\n\r\n\x05\x04\n\x02\0\
    \x01\x12\x04\xd8\x04\x18\"\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xd8\x04%&\n\
    \xdf\x01\n\x04\x04\n\x02\x01\x12\x04\xdd\x04\x02\x1d\x1a\xd0\x01\x20If\
    \x20there\x20might\x20be\x20more\x20results\x20than\x20appear\x20in\x20t\
    his\x20response,\x20then\n\x20`nextPageToken`\x20is\x20included.\x20To\
    \x20get\x20the\x20next\x20set\x20of\x20results,\x20call\x20the\x20same\n\
    \x20method\x20again\x20using\x20the\x20value\x20of\x20`nextPageToken`\
    \x20as\x20`pageToken`.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xdd\x04\x02\
    \x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xdd\x04\t\x18\n\r\n\x05\x04\n\
    \x02\x01\x03\x12\x04\xdd\x04\x1b\x1c\n1\n\x02\x04\x0b\x12\x06\xe1\x04\0\
    \xeb\x04\x01\x1a#\x20The\x20parameters\x20to\x20`GetExclusion`.\n\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\xe1\x04\x08\x1b\n\xfc\x02\n\x04\x04\x0b\x02\0\
    \x12\x04\xea\x04\x02\x12\x1a\xed\x02\x20Required.\x20The\x20resource\x20\
    name\x20of\x20an\x20existing\x20exclusion:\n\n\x20\x20\x20\x20\x20\"proj\
    ects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"org\
    anizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\
    \x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]\
    \"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]\
    \"\n\n\x20Example:\x20`\"projects/my-project-id/exclusions/my-exclusion-\
    id\"`.\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xea\x04\x02\x08\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xea\x04\t\r\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xea\x04\x10\x11\n4\n\x02\x04\x0c\x12\x06\xee\x04\0\xfc\x04\x01\x1a&\
    \x20The\x20parameters\x20to\x20`CreateExclusion`.\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\xee\x04\x08\x1e\n\xa6\x02\n\x04\x04\x0c\x02\0\x12\x04\xf7\
    \x04\x02\x14\x1a\x97\x02\x20Required.\x20The\x20parent\x20resource\x20in\
    \x20which\x20to\x20create\x20the\x20exclusion:\n\n\x20\x20\x20\x20\x20\"\
    projects/[PROJECT_ID]\"\n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATI\
    ON_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]\"\n\
    \x20\x20\x20\x20\x20\"folders/[FOLDER_ID]\"\n\n\x20Examples:\x20`\"proje\
    cts/my-logging-project\"`,\x20`\"organizations/123456789\"`.\n\n\r\n\x05\
    \x04\x0c\x02\0\x05\x12\x04\xf7\x04\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\
    \x12\x04\xf7\x04\t\x0f\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf7\x04\x12\
    \x13\n\x8a\x01\n\x04\x04\x0c\x02\x01\x12\x04\xfb\x04\x02\x1d\x1a|\x20Req\
    uired.\x20The\x20new\x20exclusion,\x20whose\x20`name`\x20parameter\x20is\
    \x20an\x20exclusion\x20name\n\x20that\x20is\x20not\x20already\x20used\
    \x20in\x20the\x20parent\x20resource.\n\n\r\n\x05\x04\x0c\x02\x01\x06\x12\
    \x04\xfb\x04\x02\x0e\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xfb\x04\x0f\
    \x18\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xfb\x04\x1b\x1c\n4\n\x02\x04\
    \r\x12\x06\xff\x04\0\x96\x05\x01\x1a&\x20The\x20parameters\x20to\x20`Upd\
    ateExclusion`.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xff\x04\x08\x1e\n\xfe\x02\
    \n\x04\x04\r\x02\0\x12\x04\x88\x05\x02\x12\x1a\xef\x02\x20Required.\x20T\
    he\x20resource\x20name\x20of\x20the\x20exclusion\x20to\x20update:\n\n\
    \x20\x20\x20\x20\x20\"projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\"\
    \n\x20\x20\x20\x20\x20\"organizations/[ORGANIZATION_ID]/exclusions/[EXCL\
    USION_ID]\"\n\x20\x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/\
    exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/e\
    xclusions/[EXCLUSION_ID]\"\n\n\x20Example:\x20`\"projects/my-project-id/\
    exclusions/my-exclusion-id\"`.\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x88\
    \x05\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x88\x05\t\r\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\x88\x05\x10\x11\nz\n\x04\x04\r\x02\x01\x12\x04\x8c\
    \x05\x02\x1d\x1al\x20Required.\x20New\x20values\x20for\x20the\x20existin\
    g\x20exclusion.\x20Only\x20the\x20fields\x20specified\n\x20in\x20`update\
    _mask`\x20are\x20relevant.\n\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x8c\x05\
    \x02\x0e\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x8c\x05\x0f\x18\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\x8c\x05\x1b\x1c\n\xbf\x03\n\x04\x04\r\x02\x02\
    \x12\x04\x95\x05\x02,\x1a\xb0\x03\x20Required.\x20A\x20non-empty\x20list\
    \x20of\x20fields\x20to\x20change\x20in\x20the\x20existing\x20exclusion.\
    \n\x20New\x20values\x20for\x20the\x20fields\x20are\x20taken\x20from\x20t\
    he\x20corresponding\x20fields\x20in\x20the\n\x20[LogExclusion][google.lo\
    gging.v2.LogExclusion]\x20included\x20in\x20this\x20request.\x20Fields\
    \x20not\x20mentioned\x20in\n\x20`update_mask`\x20are\x20not\x20changed\
    \x20and\x20are\x20ignored\x20in\x20the\x20request.\n\n\x20For\x20example\
    ,\x20to\x20change\x20the\x20filter\x20and\x20description\x20of\x20an\x20\
    exclusion,\n\x20specify\x20an\x20`update_mask`\x20of\x20`\"filter,descri\
    ption\"`.\n\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\x95\x05\x02\x1b\n\r\n\
    \x05\x04\r\x02\x02\x01\x12\x04\x95\x05\x1c'\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\x95\x05*+\n4\n\x02\x04\x0e\x12\x06\x99\x05\0\xa3\x05\x01\x1a&\
    \x20The\x20parameters\x20to\x20`DeleteExclusion`.\n\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\x99\x05\x08\x1e\n\x86\x03\n\x04\x04\x0e\x02\0\x12\x04\xa2\
    \x05\x02\x12\x1a\xf7\x02\x20Required.\x20The\x20resource\x20name\x20of\
    \x20an\x20existing\x20exclusion\x20to\x20delete:\n\n\x20\x20\x20\x20\x20\
    \"projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\x20\x20\x20\
    \x20\"organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]\"\n\x20\
    \x20\x20\x20\x20\"billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLU\
    SION_ID]\"\n\x20\x20\x20\x20\x20\"folders/[FOLDER_ID]/exclusions/[EXCLUS\
    ION_ID]\"\n\n\x20Example:\x20`\"projects/my-project-id/exclusions/my-exc\
    lusion-id\"`.\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa2\x05\x02\x08\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xa2\x05\t\r\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\xa2\x05\x10\x11b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
