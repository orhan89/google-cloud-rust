// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/monitoring/v3/uptime_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct ListUptimeCheckConfigsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUptimeCheckConfigsRequest {
    fn default() -> &'a ListUptimeCheckConfigsRequest {
        <ListUptimeCheckConfigsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUptimeCheckConfigsRequest {
    pub fn new() -> ListUptimeCheckConfigsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUptimeCheckConfigsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUptimeCheckConfigsRequest {
        ListUptimeCheckConfigsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListUptimeCheckConfigsRequest| { &m.parent },
                |m: &mut ListUptimeCheckConfigsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListUptimeCheckConfigsRequest| { &m.page_size },
                |m: &mut ListUptimeCheckConfigsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListUptimeCheckConfigsRequest| { &m.page_token },
                |m: &mut ListUptimeCheckConfigsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUptimeCheckConfigsRequest>(
                "ListUptimeCheckConfigsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUptimeCheckConfigsRequest {
        static instance: ::protobuf::rt::LazyV2<ListUptimeCheckConfigsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUptimeCheckConfigsRequest::new)
    }
}

impl ::protobuf::Clear for ListUptimeCheckConfigsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUptimeCheckConfigsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUptimeCheckConfigsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUptimeCheckConfigsResponse {
    // message fields
    pub uptime_check_configs: ::protobuf::RepeatedField<super::uptime::UptimeCheckConfig>,
    pub next_page_token: ::std::string::String,
    pub total_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUptimeCheckConfigsResponse {
    fn default() -> &'a ListUptimeCheckConfigsResponse {
        <ListUptimeCheckConfigsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListUptimeCheckConfigsResponse {
    pub fn new() -> ListUptimeCheckConfigsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.monitoring.v3.UptimeCheckConfig uptime_check_configs = 1;


    pub fn get_uptime_check_configs(&self) -> &[super::uptime::UptimeCheckConfig] {
        &self.uptime_check_configs
    }
    pub fn clear_uptime_check_configs(&mut self) {
        self.uptime_check_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_uptime_check_configs(&mut self, v: ::protobuf::RepeatedField<super::uptime::UptimeCheckConfig>) {
        self.uptime_check_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uptime_check_configs(&mut self) -> &mut ::protobuf::RepeatedField<super::uptime::UptimeCheckConfig> {
        &mut self.uptime_check_configs
    }

    // Take field
    pub fn take_uptime_check_configs(&mut self) -> ::protobuf::RepeatedField<super::uptime::UptimeCheckConfig> {
        ::std::mem::replace(&mut self.uptime_check_configs, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    // int32 total_size = 3;


    pub fn get_total_size(&self) -> i32 {
        self.total_size
    }
    pub fn clear_total_size(&mut self) {
        self.total_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_size(&mut self, v: i32) {
        self.total_size = v;
    }
}

impl ::protobuf::Message for ListUptimeCheckConfigsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.uptime_check_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uptime_check_configs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uptime_check_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        if self.total_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uptime_check_configs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        if self.total_size != 0 {
            os.write_int32(3, self.total_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUptimeCheckConfigsResponse {
        ListUptimeCheckConfigsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::uptime::UptimeCheckConfig>>(
                "uptime_check_configs",
                |m: &ListUptimeCheckConfigsResponse| { &m.uptime_check_configs },
                |m: &mut ListUptimeCheckConfigsResponse| { &mut m.uptime_check_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListUptimeCheckConfigsResponse| { &m.next_page_token },
                |m: &mut ListUptimeCheckConfigsResponse| { &mut m.next_page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_size",
                |m: &ListUptimeCheckConfigsResponse| { &m.total_size },
                |m: &mut ListUptimeCheckConfigsResponse| { &mut m.total_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUptimeCheckConfigsResponse>(
                "ListUptimeCheckConfigsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUptimeCheckConfigsResponse {
        static instance: ::protobuf::rt::LazyV2<ListUptimeCheckConfigsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUptimeCheckConfigsResponse::new)
    }
}

impl ::protobuf::Clear for ListUptimeCheckConfigsResponse {
    fn clear(&mut self) {
        self.uptime_check_configs.clear();
        self.next_page_token.clear();
        self.total_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUptimeCheckConfigsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUptimeCheckConfigsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUptimeCheckConfigRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetUptimeCheckConfigRequest {
    fn default() -> &'a GetUptimeCheckConfigRequest {
        <GetUptimeCheckConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUptimeCheckConfigRequest {
    pub fn new() -> GetUptimeCheckConfigRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetUptimeCheckConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUptimeCheckConfigRequest {
        GetUptimeCheckConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetUptimeCheckConfigRequest| { &m.name },
                |m: &mut GetUptimeCheckConfigRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetUptimeCheckConfigRequest>(
                "GetUptimeCheckConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetUptimeCheckConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetUptimeCheckConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetUptimeCheckConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetUptimeCheckConfigRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUptimeCheckConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUptimeCheckConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateUptimeCheckConfigRequest {
    // message fields
    pub parent: ::std::string::String,
    pub uptime_check_config: ::protobuf::SingularPtrField<super::uptime::UptimeCheckConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateUptimeCheckConfigRequest {
    fn default() -> &'a CreateUptimeCheckConfigRequest {
        <CreateUptimeCheckConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateUptimeCheckConfigRequest {
    pub fn new() -> CreateUptimeCheckConfigRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // .google.monitoring.v3.UptimeCheckConfig uptime_check_config = 2;


    pub fn get_uptime_check_config(&self) -> &super::uptime::UptimeCheckConfig {
        self.uptime_check_config.as_ref().unwrap_or_else(|| <super::uptime::UptimeCheckConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uptime_check_config(&mut self) {
        self.uptime_check_config.clear();
    }

    pub fn has_uptime_check_config(&self) -> bool {
        self.uptime_check_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime_check_config(&mut self, v: super::uptime::UptimeCheckConfig) {
        self.uptime_check_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uptime_check_config(&mut self) -> &mut super::uptime::UptimeCheckConfig {
        if self.uptime_check_config.is_none() {
            self.uptime_check_config.set_default();
        }
        self.uptime_check_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_uptime_check_config(&mut self) -> super::uptime::UptimeCheckConfig {
        self.uptime_check_config.take().unwrap_or_else(|| super::uptime::UptimeCheckConfig::new())
    }
}

impl ::protobuf::Message for CreateUptimeCheckConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.uptime_check_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uptime_check_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let Some(ref v) = self.uptime_check_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let Some(ref v) = self.uptime_check_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateUptimeCheckConfigRequest {
        CreateUptimeCheckConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateUptimeCheckConfigRequest| { &m.parent },
                |m: &mut CreateUptimeCheckConfigRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::uptime::UptimeCheckConfig>>(
                "uptime_check_config",
                |m: &CreateUptimeCheckConfigRequest| { &m.uptime_check_config },
                |m: &mut CreateUptimeCheckConfigRequest| { &mut m.uptime_check_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateUptimeCheckConfigRequest>(
                "CreateUptimeCheckConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateUptimeCheckConfigRequest {
        static instance: ::protobuf::rt::LazyV2<CreateUptimeCheckConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateUptimeCheckConfigRequest::new)
    }
}

impl ::protobuf::Clear for CreateUptimeCheckConfigRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.uptime_check_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateUptimeCheckConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateUptimeCheckConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateUptimeCheckConfigRequest {
    // message fields
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    pub uptime_check_config: ::protobuf::SingularPtrField<super::uptime::UptimeCheckConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateUptimeCheckConfigRequest {
    fn default() -> &'a UpdateUptimeCheckConfigRequest {
        <UpdateUptimeCheckConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUptimeCheckConfigRequest {
    pub fn new() -> UpdateUptimeCheckConfigRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    // .google.monitoring.v3.UptimeCheckConfig uptime_check_config = 3;


    pub fn get_uptime_check_config(&self) -> &super::uptime::UptimeCheckConfig {
        self.uptime_check_config.as_ref().unwrap_or_else(|| <super::uptime::UptimeCheckConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uptime_check_config(&mut self) {
        self.uptime_check_config.clear();
    }

    pub fn has_uptime_check_config(&self) -> bool {
        self.uptime_check_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime_check_config(&mut self, v: super::uptime::UptimeCheckConfig) {
        self.uptime_check_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uptime_check_config(&mut self) -> &mut super::uptime::UptimeCheckConfig {
        if self.uptime_check_config.is_none() {
            self.uptime_check_config.set_default();
        }
        self.uptime_check_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_uptime_check_config(&mut self) -> super::uptime::UptimeCheckConfig {
        self.uptime_check_config.take().unwrap_or_else(|| super::uptime::UptimeCheckConfig::new())
    }
}

impl ::protobuf::Message for UpdateUptimeCheckConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uptime_check_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uptime_check_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uptime_check_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uptime_check_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateUptimeCheckConfigRequest {
        UpdateUptimeCheckConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateUptimeCheckConfigRequest| { &m.update_mask },
                |m: &mut UpdateUptimeCheckConfigRequest| { &mut m.update_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::uptime::UptimeCheckConfig>>(
                "uptime_check_config",
                |m: &UpdateUptimeCheckConfigRequest| { &m.uptime_check_config },
                |m: &mut UpdateUptimeCheckConfigRequest| { &mut m.uptime_check_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateUptimeCheckConfigRequest>(
                "UpdateUptimeCheckConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateUptimeCheckConfigRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateUptimeCheckConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateUptimeCheckConfigRequest::new)
    }
}

impl ::protobuf::Clear for UpdateUptimeCheckConfigRequest {
    fn clear(&mut self) {
        self.update_mask.clear();
        self.uptime_check_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateUptimeCheckConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUptimeCheckConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteUptimeCheckConfigRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteUptimeCheckConfigRequest {
    fn default() -> &'a DeleteUptimeCheckConfigRequest {
        <DeleteUptimeCheckConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUptimeCheckConfigRequest {
    pub fn new() -> DeleteUptimeCheckConfigRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteUptimeCheckConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteUptimeCheckConfigRequest {
        DeleteUptimeCheckConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteUptimeCheckConfigRequest| { &m.name },
                |m: &mut DeleteUptimeCheckConfigRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteUptimeCheckConfigRequest>(
                "DeleteUptimeCheckConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteUptimeCheckConfigRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteUptimeCheckConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteUptimeCheckConfigRequest::new)
    }
}

impl ::protobuf::Clear for DeleteUptimeCheckConfigRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteUptimeCheckConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUptimeCheckConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUptimeCheckIpsRequest {
    // message fields
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUptimeCheckIpsRequest {
    fn default() -> &'a ListUptimeCheckIpsRequest {
        <ListUptimeCheckIpsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUptimeCheckIpsRequest {
    pub fn new() -> ListUptimeCheckIpsRequest {
        ::std::default::Default::default()
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUptimeCheckIpsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUptimeCheckIpsRequest {
        ListUptimeCheckIpsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListUptimeCheckIpsRequest| { &m.page_size },
                |m: &mut ListUptimeCheckIpsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListUptimeCheckIpsRequest| { &m.page_token },
                |m: &mut ListUptimeCheckIpsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUptimeCheckIpsRequest>(
                "ListUptimeCheckIpsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUptimeCheckIpsRequest {
        static instance: ::protobuf::rt::LazyV2<ListUptimeCheckIpsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUptimeCheckIpsRequest::new)
    }
}

impl ::protobuf::Clear for ListUptimeCheckIpsRequest {
    fn clear(&mut self) {
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUptimeCheckIpsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUptimeCheckIpsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUptimeCheckIpsResponse {
    // message fields
    pub uptime_check_ips: ::protobuf::RepeatedField<super::uptime::UptimeCheckIp>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUptimeCheckIpsResponse {
    fn default() -> &'a ListUptimeCheckIpsResponse {
        <ListUptimeCheckIpsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListUptimeCheckIpsResponse {
    pub fn new() -> ListUptimeCheckIpsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.monitoring.v3.UptimeCheckIp uptime_check_ips = 1;


    pub fn get_uptime_check_ips(&self) -> &[super::uptime::UptimeCheckIp] {
        &self.uptime_check_ips
    }
    pub fn clear_uptime_check_ips(&mut self) {
        self.uptime_check_ips.clear();
    }

    // Param is passed by value, moved
    pub fn set_uptime_check_ips(&mut self, v: ::protobuf::RepeatedField<super::uptime::UptimeCheckIp>) {
        self.uptime_check_ips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uptime_check_ips(&mut self) -> &mut ::protobuf::RepeatedField<super::uptime::UptimeCheckIp> {
        &mut self.uptime_check_ips
    }

    // Take field
    pub fn take_uptime_check_ips(&mut self) -> ::protobuf::RepeatedField<super::uptime::UptimeCheckIp> {
        ::std::mem::replace(&mut self.uptime_check_ips, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUptimeCheckIpsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.uptime_check_ips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uptime_check_ips)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uptime_check_ips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uptime_check_ips {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUptimeCheckIpsResponse {
        ListUptimeCheckIpsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::uptime::UptimeCheckIp>>(
                "uptime_check_ips",
                |m: &ListUptimeCheckIpsResponse| { &m.uptime_check_ips },
                |m: &mut ListUptimeCheckIpsResponse| { &mut m.uptime_check_ips },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListUptimeCheckIpsResponse| { &m.next_page_token },
                |m: &mut ListUptimeCheckIpsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUptimeCheckIpsResponse>(
                "ListUptimeCheckIpsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUptimeCheckIpsResponse {
        static instance: ::protobuf::rt::LazyV2<ListUptimeCheckIpsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUptimeCheckIpsResponse::new)
    }
}

impl ::protobuf::Clear for ListUptimeCheckIpsResponse {
    fn clear(&mut self) {
        self.uptime_check_ips.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUptimeCheckIpsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUptimeCheckIpsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/monitoring/v3/uptime_service.proto\x12\x14google.monitoring.v3\
    \x1a\x1cgoogle/api/annotations.proto\x1a!google/monitoring/v3/uptime.pro\
    to\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.pr\
    oto\x1a\x20google/protobuf/field_mask.proto\x1a\x17google/api/client.pro\
    to\"s\n\x1dListUptimeCheckConfigsRequest\x12\x16\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSiz\
    e\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\xc2\x01\n\x1eLi\
    stUptimeCheckConfigsResponse\x12Y\n\x14uptime_check_configs\x18\x01\x20\
    \x03(\x0b2'.google.monitoring.v3.UptimeCheckConfigR\x12uptimeCheckConfig\
    s\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\x12\x1d\n\
    \ntotal_size\x18\x03\x20\x01(\x05R\ttotalSize\"1\n\x1bGetUptimeCheckConf\
    igRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\x91\x01\n\x1eC\
    reateUptimeCheckConfigRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parent\x12W\n\x13uptime_check_config\x18\x02\x20\x01(\x0b2'.google.m\
    onitoring.v3.UptimeCheckConfigR\x11uptimeCheckConfig\"\xb6\x01\n\x1eUpda\
    teUptimeCheckConfigRequest\x12;\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.FieldMaskR\nupdateMask\x12W\n\x13uptime_check_confi\
    g\x18\x03\x20\x01(\x0b2'.google.monitoring.v3.UptimeCheckConfigR\x11upti\
    meCheckConfig\"4\n\x1eDeleteUptimeCheckConfigRequest\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\"W\n\x19ListUptimeCheckIpsRequest\x12\x1b\n\
    \tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\
    \x03\x20\x01(\tR\tpageToken\"\x93\x01\n\x1aListUptimeCheckIpsResponse\
    \x12M\n\x10uptime_check_ips\x18\x01\x20\x03(\x0b2#.google.monitoring.v3.\
    UptimeCheckIpR\x0euptimeCheckIps\x12&\n\x0fnext_page_token\x18\x02\x20\
    \x01(\tR\rnextPageToken2\xf3\t\n\x12UptimeCheckService\x12\xb7\x01\n\x16\
    ListUptimeCheckConfigs\x123.google.monitoring.v3.ListUptimeCheckConfigsR\
    equest\x1a4.google.monitoring.v3.ListUptimeCheckConfigsResponse\"2\x82\
    \xd3\xe4\x93\x02,\x12*/v3/{parent=projects/*}/uptimeCheckConfigs\x12\xa6\
    \x01\n\x14GetUptimeCheckConfig\x121.google.monitoring.v3.GetUptimeCheckC\
    onfigRequest\x1a'.google.monitoring.v3.UptimeCheckConfig\"2\x82\xd3\xe4\
    \x93\x02,\x12*/v3/{name=projects/*/uptimeCheckConfigs/*}\x12\xc1\x01\n\
    \x17CreateUptimeCheckConfig\x124.google.monitoring.v3.CreateUptimeCheckC\
    onfigRequest\x1a'.google.monitoring.v3.UptimeCheckConfig\"G\x82\xd3\xe4\
    \x93\x02A\"*/v3/{parent=projects/*}/uptimeCheckConfigs:\x13uptime_check_\
    config\x12\xd5\x01\n\x17UpdateUptimeCheckConfig\x124.google.monitoring.v\
    3.UpdateUptimeCheckConfigRequest\x1a'.google.monitoring.v3.UptimeCheckCo\
    nfig\"[\x82\xd3\xe4\x93\x02U2>/v3/{uptime_check_config.name=projects/*/u\
    ptimeCheckConfigs/*}:\x13uptime_check_config\x12\x9b\x01\n\x17DeleteUpti\
    meCheckConfig\x124.google.monitoring.v3.DeleteUptimeCheckConfigRequest\
    \x1a\x16.google.protobuf.Empty\"2\x82\xd3\xe4\x93\x02,**/v3/{name=projec\
    ts/*/uptimeCheckConfigs/*}\x12\x93\x01\n\x12ListUptimeCheckIps\x12/.goog\
    le.monitoring.v3.ListUptimeCheckIpsRequest\x1a0.google.monitoring.v3.Lis\
    tUptimeCheckIpsResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v3/uptimeC\
    heckIps\x1a\xa9\x01\xd2A\x89\x01https://www.googleapis.com/auth/cloud-pl\
    atform,https://www.googleapis.com/auth/monitoring,https://www.googleapis\
    .com/auth/monitoring.read\xcaA\x19monitoring.googleapis.comB\xaa\x01\n\
    \x18com.google.monitoring.v3B\x12UptimeServiceProtoP\x01Z>google.golang.\
    org/genproto/googleapis/monitoring/v3;monitoring\xaa\x02\x1aGoogle.Cloud\
    .Monitoring.V3\xca\x02\x1aGoogle\\Cloud\\Monitoring\\V3J\x9d;\n\x07\x12\
    \x05\x0f\0\xd1\x01\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\
    \x20Copyright\x202019\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20y\
    ou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\
    \x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/li\
    censes/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\
    \x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\
    \x12\x03\x11\0\x1d\n\t\n\x02\x03\0\x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\
    \x03\x14\0+\n\t\n\x02\x03\x02\x12\x03\x15\0(\n\t\n\x02\x03\x03\x12\x03\
    \x16\0%\n\t\n\x02\x03\x04\x12\x03\x17\0*\n\t\n\x02\x03\x05\x12\x03\x18\0\
    !\n\x08\n\x01\x08\x12\x03\x1a\07\n\t\n\x02\x08%\x12\x03\x1a\07\n\x08\n\
    \x01\x08\x12\x03\x1b\0U\n\t\n\x02\x08\x0b\x12\x03\x1b\0U\n\x08\n\x01\x08\
    \x12\x03\x1c\0\"\n\t\n\x02\x08\n\x12\x03\x1c\0\"\n\x08\n\x01\x08\x12\x03\
    \x1d\03\n\t\n\x02\x08\x08\x12\x03\x1d\03\n\x08\n\x01\x08\x12\x03\x1e\01\
    \n\t\n\x02\x08\x01\x12\x03\x1e\01\n\x08\n\x01\x08\x12\x03\x1f\07\n\t\n\
    \x02\x08)\x12\x03\x1f\07\n\xa7\x04\n\x02\x06\0\x12\x04)\0a\x01\x1a\x9a\
    \x04\x20The\x20UptimeCheckService\x20API\x20is\x20used\x20to\x20manage\
    \x20(list,\x20create,\x20delete,\x20edit)\n\x20Uptime\x20check\x20config\
    urations\x20in\x20the\x20Stackdriver\x20Monitoring\x20product.\x20An\x20\
    Uptime\n\x20check\x20is\x20a\x20piece\x20of\x20configuration\x20that\x20\
    determines\x20which\x20resources\x20and\n\x20services\x20to\x20monitor\
    \x20for\x20availability.\x20These\x20configurations\x20can\x20also\x20be\
    \n\x20configured\x20interactively\x20by\x20navigating\x20to\x20the\x20[C\
    loud\x20Console]\n\x20(http://console.cloud.google.com),\x20selecting\
    \x20the\x20appropriate\x20project,\n\x20clicking\x20on\x20\"Monitoring\"\
    \x20on\x20the\x20left-hand\x20side\x20to\x20navigate\x20to\x20Stackdrive\
    r,\n\x20and\x20then\x20clicking\x20on\x20\"Uptime\".\n\n\n\n\x03\x06\0\
    \x01\x12\x03)\x08\x1a\n\n\n\x03\x06\0\x03\x12\x03*\x02A\n\x0c\n\x05\x06\
    \0\x03\x99\x08\x12\x03*\x02A\n\x0b\n\x03\x06\0\x03\x12\x04+\x02.8\n\r\n\
    \x05\x06\0\x03\x9a\x08\x12\x04+\x02.8\n\x7f\n\x04\x06\0\x02\0\x12\x042\
    \x026\x03\x1aq\x20Lists\x20the\x20existing\x20valid\x20Uptime\x20check\
    \x20configurations\x20for\x20the\x20project\n\x20(leaving\x20out\x20any\
    \x20invalid\x20configurations).\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x032\
    \x06\x1c\n\x0c\n\x05\x06\0\x02\0\x02\x12\x032\x1d:\n\x0c\n\x05\x06\0\x02\
    \0\x03\x12\x032Ec\n\r\n\x05\x06\0\x02\0\x04\x12\x043\x045\x06\n\x11\n\t\
    \x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x043\x045\x06\n9\n\x04\x06\0\x02\x01\
    \x12\x049\x02=\x03\x1a+\x20Gets\x20a\x20single\x20Uptime\x20check\x20con\
    figuration.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x039\x06\x1a\n\x0c\n\x05\
    \x06\0\x02\x01\x02\x12\x039\x1b6\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x039A\
    R\n\r\n\x05\x06\0\x02\x01\x04\x12\x04:\x04<\x06\n\x11\n\t\x06\0\x02\x01\
    \x04\xb0\xca\xbc\"\x12\x04:\x04<\x06\n9\n\x04\x06\0\x02\x02\x12\x04@\x02\
    E\x03\x1a+\x20Creates\x20a\x20new\x20Uptime\x20check\x20configuration.\n\
    \n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03@\x06\x1d\n\x0c\n\x05\x06\0\x02\
    \x02\x02\x12\x03@\x1e<\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03@GX\n\r\n\
    \x05\x06\0\x02\x02\x04\x12\x04A\x04D\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\
    \xca\xbc\"\x12\x04A\x04D\x06\n\x91\x02\n\x04\x06\0\x02\x03\x12\x04K\x02P\
    \x03\x1a\x82\x02\x20Updates\x20an\x20Uptime\x20check\x20configuration.\
    \x20You\x20can\x20either\x20replace\x20the\x20entire\n\x20configuration\
    \x20with\x20a\x20new\x20one\x20or\x20replace\x20only\x20certain\x20field\
    s\x20in\x20the\x20current\n\x20configuration\x20by\x20specifying\x20the\
    \x20fields\x20to\x20be\x20updated\x20via\x20`updateMask`.\n\x20Returns\
    \x20the\x20updated\x20configuration.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\
    \x03K\x06\x1d\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03K\x1e<\n\x0c\n\x05\
    \x06\0\x02\x03\x03\x12\x03KGX\n\r\n\x05\x06\0\x02\x03\x04\x12\x04L\x04O\
    \x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04L\x04O\x06\n\xe7\
    \x01\n\x04\x06\0\x02\x04\x12\x04U\x02Y\x03\x1a\xd8\x01\x20Deletes\x20an\
    \x20Uptime\x20check\x20configuration.\x20Note\x20that\x20this\x20method\
    \x20will\x20fail\n\x20if\x20the\x20Uptime\x20check\x20configuration\x20i\
    s\x20referenced\x20by\x20an\x20alert\x20policy\x20or\n\x20other\x20depen\
    dent\x20configs\x20that\x20would\x20be\x20rendered\x20invalid\x20by\x20t\
    he\x20deletion.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03U\x06\x1d\n\x0c\n\
    \x05\x06\0\x02\x04\x02\x12\x03U\x1e<\n\x0c\n\x05\x06\0\x02\x04\x03\x12\
    \x03UG\\\n\r\n\x05\x06\0\x02\x04\x04\x12\x04V\x04X\x06\n\x11\n\t\x06\0\
    \x02\x04\x04\xb0\xca\xbc\"\x12\x04V\x04X\x06\nG\n\x04\x06\0\x02\x05\x12\
    \x04\\\x02`\x03\x1a9\x20Returns\x20the\x20list\x20of\x20IP\x20addresses\
    \x20that\x20checkers\x20run\x20from\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\
    \x03\\\x06\x18\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\\\x192\n\x0c\n\x05\
    \x06\0\x02\x05\x03\x12\x03\\=W\n\r\n\x05\x06\0\x02\x05\x04\x12\x04]\x04_\
    \x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04]\x04_\x06\nD\n\
    \x02\x04\0\x12\x04d\0s\x01\x1a8\x20The\x20protocol\x20for\x20the\x20`Lis\
    tUptimeCheckConfigs`\x20request.\n\n\n\n\x03\x04\0\x01\x12\x03d\x08%\nr\
    \n\x04\x04\0\x02\0\x12\x03g\x02\x14\x1ae\x20The\x20project\x20whose\x20U\
    ptime\x20check\x20configurations\x20are\x20listed.\x20The\x20format\n\
    \x20\x20\x20is\x20`projects/[PROJECT_ID]`.\n\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03g\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03g\t\x0f\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03g\x12\x13\n\x80\x02\n\x04\x04\0\x02\x01\x12\x03m\
    \x02\x16\x1a\xf2\x01\x20The\x20maximum\x20number\x20of\x20results\x20to\
    \x20return\x20in\x20a\x20single\x20response.\x20The\x20server\n\x20may\
    \x20further\x20constrain\x20the\x20maximum\x20number\x20of\x20results\
    \x20returned\x20in\x20a\x20single\n\x20page.\x20If\x20the\x20page_size\
    \x20is\x20<=0,\x20the\x20server\x20will\x20decide\x20the\x20number\x20of\
    \x20results\n\x20to\x20be\x20returned.\n\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03m\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03m\x08\x11\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03m\x14\x15\n\xe1\x01\n\x04\x04\0\x02\x02\
    \x12\x03r\x02\x18\x1a\xd3\x01\x20If\x20this\x20field\x20is\x20not\x20emp\
    ty\x20then\x20it\x20must\x20contain\x20the\x20`nextPageToken`\x20value\n\
    \x20returned\x20by\x20a\x20previous\x20call\x20to\x20this\x20method.\x20\
    \x20Using\x20this\x20field\x20causes\x20the\n\x20method\x20to\x20return\
    \x20more\x20results\x20from\x20the\x20previous\x20method\x20call.\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03r\x02\x08\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03r\t\x13\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03r\x16\x17\nF\n\
    \x02\x04\x01\x12\x05v\0\x84\x01\x01\x1a9\x20The\x20protocol\x20for\x20th\
    e\x20`ListUptimeCheckConfigs`\x20response.\n\n\n\n\x03\x04\x01\x01\x12\
    \x03v\x08&\n8\n\x04\x04\x01\x02\0\x12\x03x\x026\x1a+\x20The\x20returned\
    \x20Uptime\x20check\x20configurations.\n\n\x0c\n\x05\x04\x01\x02\0\x04\
    \x12\x03x\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03x\x0b\x1c\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03x\x1d1\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03x45\n\xc9\x02\n\x04\x04\x01\x02\x01\x12\x03\x7f\x02\x1d\x1a\xbb\x02\
    \x20This\x20field\x20represents\x20the\x20pagination\x20token\x20to\x20r\
    etrieve\x20the\x20next\x20page\x20of\n\x20results.\x20If\x20the\x20value\
    \x20is\x20empty,\x20it\x20means\x20no\x20further\x20results\x20for\x20th\
    e\n\x20request.\x20To\x20retrieve\x20the\x20next\x20page\x20of\x20result\
    s,\x20the\x20value\x20of\x20the\n\x20next_page_token\x20is\x20passed\x20\
    to\x20the\x20subsequent\x20List\x20method\x20call\x20(in\x20the\n\x20req\
    uest\x20message's\x20page_token\x20field).\n\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x7f\t\
    \x18\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x7f\x1b\x1c\nq\n\x04\x04\
    \x01\x02\x02\x12\x04\x83\x01\x02\x17\x1ac\x20The\x20total\x20number\x20o\
    f\x20Uptime\x20check\x20configurations\x20for\x20the\x20project,\n\x20ir\
    respective\x20of\x20any\x20pagination.\n\n\r\n\x05\x04\x01\x02\x02\x05\
    \x12\x04\x83\x01\x02\x07\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\x83\x01\
    \x08\x12\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\x83\x01\x15\x16\nD\n\x02\
    \x04\x02\x12\x06\x87\x01\0\x8b\x01\x01\x1a6\x20The\x20protocol\x20for\
    \x20the\x20`GetUptimeCheckConfig`\x20request.\n\n\x0b\n\x03\x04\x02\x01\
    \x12\x04\x87\x01\x08#\n\x8a\x01\n\x04\x04\x02\x02\0\x12\x04\x8a\x01\x02\
    \x12\x1a|\x20The\x20Uptime\x20check\x20configuration\x20to\x20retrieve.\
    \x20The\x20format\n\x20\x20\x20is\x20`projects/[PROJECT_ID]/uptimeCheckC\
    onfigs/[UPTIME_CHECK_ID]`.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x8a\x01\
    \x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x8a\x01\t\r\n\r\n\x05\x04\
    \x02\x02\0\x03\x12\x04\x8a\x01\x10\x11\nG\n\x02\x04\x03\x12\x06\x8e\x01\
    \0\x95\x01\x01\x1a9\x20The\x20protocol\x20for\x20the\x20`CreateUptimeChe\
    ckConfig`\x20request.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x8e\x01\x08&\nj\
    \n\x04\x04\x03\x02\0\x12\x04\x91\x01\x02\x14\x1a\\\x20The\x20project\x20\
    in\x20which\x20to\x20create\x20the\x20Uptime\x20check.\x20The\x20format\
    \n\x20\x20\x20is\x20`projects/[PROJECT_ID]`.\n\n\r\n\x05\x04\x03\x02\0\
    \x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x91\x01\
    \t\x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x91\x01\x12\x13\n3\n\x04\x04\
    \x03\x02\x01\x12\x04\x94\x01\x02,\x1a%\x20The\x20new\x20Uptime\x20check\
    \x20configuration.\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x94\x01\x02\
    \x13\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x94\x01\x14'\n\r\n\x05\x04\
    \x03\x02\x01\x03\x12\x04\x94\x01*+\nG\n\x02\x04\x04\x12\x06\x98\x01\0\
    \xab\x01\x01\x1a9\x20The\x20protocol\x20for\x20the\x20`UpdateUptimeCheck\
    Config`\x20request.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x98\x01\x08&\n\x88\
    \x02\n\x04\x04\x04\x02\0\x12\x04\x9d\x01\x02,\x1a\xf9\x01\x20Optional.\
    \x20If\x20present,\x20only\x20the\x20listed\x20fields\x20in\x20the\x20cu\
    rrent\x20Uptime\x20check\n\x20configuration\x20are\x20updated\x20with\
    \x20values\x20from\x20the\x20new\x20configuration.\x20If\x20this\n\x20fi\
    eld\x20is\x20empty,\x20then\x20the\x20current\x20configuration\x20is\x20\
    completely\x20replaced\x20with\n\x20the\x20new\x20configuration.\n\n\r\n\
    \x05\x04\x04\x02\0\x06\x12\x04\x9d\x01\x02\x1b\n\r\n\x05\x04\x04\x02\0\
    \x01\x12\x04\x9d\x01\x1c'\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x9d\x01*+\
    \n\xdf\x04\n\x04\x04\x04\x02\x01\x12\x04\xaa\x01\x02,\x1a\xd0\x04\x20Req\
    uired.\x20If\x20an\x20`updateMask`\x20has\x20been\x20specified,\x20this\
    \x20field\x20gives\n\x20the\x20values\x20for\x20the\x20set\x20of\x20fiel\
    ds\x20mentioned\x20in\x20the\x20`updateMask`.\x20If\x20an\n\x20`updateMa\
    sk`\x20has\x20not\x20been\x20given,\x20this\x20Uptime\x20check\x20config\
    uration\x20replaces\n\x20the\x20current\x20configuration.\x20If\x20a\x20\
    field\x20is\x20mentioned\x20in\x20`updateMask`\x20but\n\x20the\x20corres\
    onding\x20field\x20is\x20omitted\x20in\x20this\x20partial\x20Uptime\x20c\
    heck\n\x20configuration,\x20it\x20has\x20the\x20effect\x20of\x20deleting\
    /clearing\x20the\x20field\x20from\x20the\n\x20configuration\x20on\x20the\
    \x20server.\n\n\x20The\x20following\x20fields\x20can\x20be\x20updated:\
    \x20`display_name`,\n\x20`http_check`,\x20`tcp_check`,\x20`timeout`,\x20\
    `content_matchers`,\x20and\n\x20`selected_regions`.\n\n\r\n\x05\x04\x04\
    \x02\x01\x06\x12\x04\xaa\x01\x02\x13\n\r\n\x05\x04\x04\x02\x01\x01\x12\
    \x04\xaa\x01\x14'\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xaa\x01*+\nG\n\
    \x02\x04\x05\x12\x06\xae\x01\0\xb2\x01\x01\x1a9\x20The\x20protocol\x20fo\
    r\x20the\x20`DeleteUptimeCheckConfig`\x20request.\n\n\x0b\n\x03\x04\x05\
    \x01\x12\x04\xae\x01\x08&\n\x88\x01\n\x04\x04\x05\x02\0\x12\x04\xb1\x01\
    \x02\x12\x1az\x20The\x20Uptime\x20check\x20configuration\x20to\x20delete\
    .\x20The\x20format\n\x20\x20\x20is\x20`projects/[PROJECT_ID]/uptimeCheck\
    Configs/[UPTIME_CHECK_ID]`.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xb1\
    \x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xb1\x01\t\r\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\xb1\x01\x10\x11\nB\n\x02\x04\x06\x12\x06\xb5\
    \x01\0\xc2\x01\x01\x1a4\x20The\x20protocol\x20for\x20the\x20`ListUptimeC\
    heckIps`\x20request.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xb5\x01\x08!\n\
    \xaa\x02\n\x04\x04\x06\x02\0\x12\x04\xbb\x01\x02\x16\x1a\x9b\x02\x20The\
    \x20maximum\x20number\x20of\x20results\x20to\x20return\x20in\x20a\x20sin\
    gle\x20response.\x20The\x20server\n\x20may\x20further\x20constrain\x20th\
    e\x20maximum\x20number\x20of\x20results\x20returned\x20in\x20a\x20single\
    \n\x20page.\x20If\x20the\x20page_size\x20is\x20<=0,\x20the\x20server\x20\
    will\x20decide\x20the\x20number\x20of\x20results\n\x20to\x20be\x20return\
    ed.\n\x20NOTE:\x20this\x20field\x20is\x20not\x20yet\x20implemented\n\n\r\
    \n\x05\x04\x06\x02\0\x05\x12\x04\xbb\x01\x02\x07\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\xbb\x01\x08\x11\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xbb\x01\
    \x14\x15\n\x8b\x02\n\x04\x04\x06\x02\x01\x12\x04\xc1\x01\x02\x18\x1a\xfc\
    \x01\x20If\x20this\x20field\x20is\x20not\x20empty\x20then\x20it\x20must\
    \x20contain\x20the\x20`nextPageToken`\x20value\n\x20returned\x20by\x20a\
    \x20previous\x20call\x20to\x20this\x20method.\x20\x20Using\x20this\x20fi\
    eld\x20causes\x20the\n\x20method\x20to\x20return\x20more\x20results\x20f\
    rom\x20the\x20previous\x20method\x20call.\n\x20NOTE:\x20this\x20field\
    \x20is\x20not\x20yet\x20implemented\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\
    \x04\xc1\x01\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xc1\x01\t\x13\
    \n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc1\x01\x16\x17\nC\n\x02\x04\x07\
    \x12\x06\xc5\x01\0\xd1\x01\x01\x1a5\x20The\x20protocol\x20for\x20the\x20\
    `ListUptimeCheckIps`\x20response.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xc5\
    \x01\x08\"\nn\n\x04\x04\x07\x02\0\x12\x04\xc8\x01\x02.\x1a`\x20The\x20re\
    turned\x20list\x20of\x20IP\x20addresses\x20(including\x20region\x20and\
    \x20location)\x20that\x20the\n\x20checkers\x20run\x20from.\n\n\r\n\x05\
    \x04\x07\x02\0\x04\x12\x04\xc8\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\
    \x04\xc8\x01\x0b\x18\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xc8\x01\x19)\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xc8\x01,-\n\xf3\x02\n\x04\x04\x07\x02\
    \x01\x12\x04\xd0\x01\x02\x1d\x1a\xe4\x02\x20This\x20field\x20represents\
    \x20the\x20pagination\x20token\x20to\x20retrieve\x20the\x20next\x20page\
    \x20of\n\x20results.\x20If\x20the\x20value\x20is\x20empty,\x20it\x20mean\
    s\x20no\x20further\x20results\x20for\x20the\n\x20request.\x20To\x20retri\
    eve\x20the\x20next\x20page\x20of\x20results,\x20the\x20value\x20of\x20th\
    e\n\x20next_page_token\x20is\x20passed\x20to\x20the\x20subsequent\x20Lis\
    t\x20method\x20call\x20(in\x20the\n\x20request\x20message's\x20page_toke\
    n\x20field).\n\x20NOTE:\x20this\x20field\x20is\x20not\x20yet\x20implemen\
    ted\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xd0\x01\x02\x08\n\r\n\x05\
    \x04\x07\x02\x01\x01\x12\x04\xd0\x01\t\x18\n\r\n\x05\x04\x07\x02\x01\x03\
    \x12\x04\xd0\x01\x1b\x1cb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
