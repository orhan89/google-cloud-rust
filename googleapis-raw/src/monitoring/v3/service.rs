// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/monitoring/v3/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub telemetry: ::protobuf::SingularPtrField<Service_Telemetry>,
    // message oneof groups
    pub identifier: ::std::option::Option<Service_oneof_identifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Service_oneof_identifier {
    custom(Service_Custom),
    app_engine(Service_AppEngine),
    cloud_endpoints(Service_CloudEndpoints),
    cluster_istio(Service_ClusterIstio),
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.monitoring.v3.Service.Custom custom = 6;


    pub fn get_custom(&self) -> &Service_Custom {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::custom(ref v)) => v,
            _ => <Service_Custom as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_custom(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_custom(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::custom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom(&mut self, v: Service_Custom) {
        self.identifier = ::std::option::Option::Some(Service_oneof_identifier::custom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom(&mut self) -> &mut Service_Custom {
        if let ::std::option::Option::Some(Service_oneof_identifier::custom(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Service_oneof_identifier::custom(Service_Custom::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::custom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom(&mut self) -> Service_Custom {
        if self.has_custom() {
            match self.identifier.take() {
                ::std::option::Option::Some(Service_oneof_identifier::custom(v)) => v,
                _ => panic!(),
            }
        } else {
            Service_Custom::new()
        }
    }

    // .google.monitoring.v3.Service.AppEngine app_engine = 7;


    pub fn get_app_engine(&self) -> &Service_AppEngine {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::app_engine(ref v)) => v,
            _ => <Service_AppEngine as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_app_engine(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_app_engine(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::app_engine(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_app_engine(&mut self, v: Service_AppEngine) {
        self.identifier = ::std::option::Option::Some(Service_oneof_identifier::app_engine(v))
    }

    // Mutable pointer to the field.
    pub fn mut_app_engine(&mut self) -> &mut Service_AppEngine {
        if let ::std::option::Option::Some(Service_oneof_identifier::app_engine(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Service_oneof_identifier::app_engine(Service_AppEngine::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::app_engine(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_app_engine(&mut self) -> Service_AppEngine {
        if self.has_app_engine() {
            match self.identifier.take() {
                ::std::option::Option::Some(Service_oneof_identifier::app_engine(v)) => v,
                _ => panic!(),
            }
        } else {
            Service_AppEngine::new()
        }
    }

    // .google.monitoring.v3.Service.CloudEndpoints cloud_endpoints = 8;


    pub fn get_cloud_endpoints(&self) -> &Service_CloudEndpoints {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(ref v)) => v,
            _ => <Service_CloudEndpoints as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cloud_endpoints(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_cloud_endpoints(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cloud_endpoints(&mut self, v: Service_CloudEndpoints) {
        self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cloud_endpoints(&mut self) -> &mut Service_CloudEndpoints {
        if let ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(Service_CloudEndpoints::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cloud_endpoints(&mut self) -> Service_CloudEndpoints {
        if self.has_cloud_endpoints() {
            match self.identifier.take() {
                ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(v)) => v,
                _ => panic!(),
            }
        } else {
            Service_CloudEndpoints::new()
        }
    }

    // .google.monitoring.v3.Service.ClusterIstio cluster_istio = 9;


    pub fn get_cluster_istio(&self) -> &Service_ClusterIstio {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(ref v)) => v,
            _ => <Service_ClusterIstio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cluster_istio(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_cluster_istio(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_istio(&mut self, v: Service_ClusterIstio) {
        self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_istio(&mut self) -> &mut Service_ClusterIstio {
        if let ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(Service_ClusterIstio::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_istio(&mut self) -> Service_ClusterIstio {
        if self.has_cluster_istio() {
            match self.identifier.take() {
                ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(v)) => v,
                _ => panic!(),
            }
        } else {
            Service_ClusterIstio::new()
        }
    }

    // .google.monitoring.v3.Service.Telemetry telemetry = 13;


    pub fn get_telemetry(&self) -> &Service_Telemetry {
        self.telemetry.as_ref().unwrap_or_else(|| <Service_Telemetry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_telemetry(&mut self) {
        self.telemetry.clear();
    }

    pub fn has_telemetry(&self) -> bool {
        self.telemetry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_telemetry(&mut self, v: Service_Telemetry) {
        self.telemetry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_telemetry(&mut self) -> &mut Service_Telemetry {
        if self.telemetry.is_none() {
            self.telemetry.set_default();
        }
        self.telemetry.as_mut().unwrap()
    }

    // Take field
    pub fn take_telemetry(&mut self) -> Service_Telemetry {
        self.telemetry.take().unwrap_or_else(|| Service_Telemetry::new())
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        if let Some(Service_oneof_identifier::custom(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Service_oneof_identifier::app_engine(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Service_oneof_identifier::cloud_endpoints(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Service_oneof_identifier::cluster_istio(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.telemetry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Service_oneof_identifier::custom(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Service_oneof_identifier::app_engine(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cloud_endpoints(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Service_oneof_identifier::cluster_istio(is.read_message()?));
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.telemetry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if let Some(ref v) = self.telemetry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Service_oneof_identifier::custom(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Service_oneof_identifier::app_engine(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Service_oneof_identifier::cloud_endpoints(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Service_oneof_identifier::cluster_istio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if let Some(ref v) = self.telemetry.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Service_oneof_identifier::custom(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Service_oneof_identifier::app_engine(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Service_oneof_identifier::cloud_endpoints(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Service_oneof_identifier::cluster_istio(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Service| { &m.name },
                |m: &mut Service| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &Service| { &m.display_name },
                |m: &mut Service| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Service_Custom>(
                "custom",
                Service::has_custom,
                Service::get_custom,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Service_AppEngine>(
                "app_engine",
                Service::has_app_engine,
                Service::get_app_engine,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Service_CloudEndpoints>(
                "cloud_endpoints",
                Service::has_cloud_endpoints,
                Service::get_cloud_endpoints,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Service_ClusterIstio>(
                "cluster_istio",
                Service::has_cluster_istio,
                Service::get_cluster_istio,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service_Telemetry>>(
                "telemetry",
                |m: &Service| { &m.telemetry },
                |m: &mut Service| { &mut m.telemetry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                "Service",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service {
        static instance: ::protobuf::rt::LazyV2<Service> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service::new)
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.telemetry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service_Custom {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service_Custom {
    fn default() -> &'a Service_Custom {
        <Service_Custom as ::protobuf::Message>::default_instance()
    }
}

impl Service_Custom {
    pub fn new() -> Service_Custom {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Service_Custom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service_Custom {
        Service_Custom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service_Custom>(
                "Service.Custom",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service_Custom {
        static instance: ::protobuf::rt::LazyV2<Service_Custom> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service_Custom::new)
    }
}

impl ::protobuf::Clear for Service_Custom {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service_Custom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service_Custom {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service_AppEngine {
    // message fields
    pub module_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service_AppEngine {
    fn default() -> &'a Service_AppEngine {
        <Service_AppEngine as ::protobuf::Message>::default_instance()
    }
}

impl Service_AppEngine {
    pub fn new() -> Service_AppEngine {
        ::std::default::Default::default()
    }

    // string module_id = 1;


    pub fn get_module_id(&self) -> &str {
        &self.module_id
    }
    pub fn clear_module_id(&mut self) {
        self.module_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_id(&mut self, v: ::std::string::String) {
        self.module_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_id(&mut self) -> &mut ::std::string::String {
        &mut self.module_id
    }

    // Take field
    pub fn take_module_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Service_AppEngine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.module_id.is_empty() {
            os.write_string(1, &self.module_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service_AppEngine {
        Service_AppEngine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "module_id",
                |m: &Service_AppEngine| { &m.module_id },
                |m: &mut Service_AppEngine| { &mut m.module_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service_AppEngine>(
                "Service.AppEngine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service_AppEngine {
        static instance: ::protobuf::rt::LazyV2<Service_AppEngine> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service_AppEngine::new)
    }
}

impl ::protobuf::Clear for Service_AppEngine {
    fn clear(&mut self) {
        self.module_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service_AppEngine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service_AppEngine {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service_CloudEndpoints {
    // message fields
    pub service: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service_CloudEndpoints {
    fn default() -> &'a Service_CloudEndpoints {
        <Service_CloudEndpoints as ::protobuf::Message>::default_instance()
    }
}

impl Service_CloudEndpoints {
    pub fn new() -> Service_CloudEndpoints {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Service_CloudEndpoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service_CloudEndpoints {
        Service_CloudEndpoints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &Service_CloudEndpoints| { &m.service },
                |m: &mut Service_CloudEndpoints| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service_CloudEndpoints>(
                "Service.CloudEndpoints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service_CloudEndpoints {
        static instance: ::protobuf::rt::LazyV2<Service_CloudEndpoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service_CloudEndpoints::new)
    }
}

impl ::protobuf::Clear for Service_CloudEndpoints {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service_CloudEndpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service_CloudEndpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service_ClusterIstio {
    // message fields
    pub location: ::std::string::String,
    pub cluster_name: ::std::string::String,
    pub service_namespace: ::std::string::String,
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service_ClusterIstio {
    fn default() -> &'a Service_ClusterIstio {
        <Service_ClusterIstio as ::protobuf::Message>::default_instance()
    }
}

impl Service_ClusterIstio {
    pub fn new() -> Service_ClusterIstio {
        ::std::default::Default::default()
    }

    // string location = 1;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // string cluster_name = 2;


    pub fn get_cluster_name(&self) -> &str {
        &self.cluster_name
    }
    pub fn clear_cluster_name(&mut self) {
        self.cluster_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_name(&mut self, v: ::std::string::String) {
        self.cluster_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_name(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_name
    }

    // Take field
    pub fn take_cluster_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_name, ::std::string::String::new())
    }

    // string service_namespace = 3;


    pub fn get_service_namespace(&self) -> &str {
        &self.service_namespace
    }
    pub fn clear_service_namespace(&mut self) {
        self.service_namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_namespace(&mut self, v: ::std::string::String) {
        self.service_namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.service_namespace
    }

    // Take field
    pub fn take_service_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_namespace, ::std::string::String::new())
    }

    // string service_name = 4;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Service_ClusterIstio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_namespace)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.location);
        }
        if !self.cluster_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cluster_name);
        }
        if !self.service_namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.service_namespace);
        }
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.location.is_empty() {
            os.write_string(1, &self.location)?;
        }
        if !self.cluster_name.is_empty() {
            os.write_string(2, &self.cluster_name)?;
        }
        if !self.service_namespace.is_empty() {
            os.write_string(3, &self.service_namespace)?;
        }
        if !self.service_name.is_empty() {
            os.write_string(4, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service_ClusterIstio {
        Service_ClusterIstio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Service_ClusterIstio| { &m.location },
                |m: &mut Service_ClusterIstio| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_name",
                |m: &Service_ClusterIstio| { &m.cluster_name },
                |m: &mut Service_ClusterIstio| { &mut m.cluster_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_namespace",
                |m: &Service_ClusterIstio| { &m.service_namespace },
                |m: &mut Service_ClusterIstio| { &mut m.service_namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &Service_ClusterIstio| { &m.service_name },
                |m: &mut Service_ClusterIstio| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service_ClusterIstio>(
                "Service.ClusterIstio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service_ClusterIstio {
        static instance: ::protobuf::rt::LazyV2<Service_ClusterIstio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service_ClusterIstio::new)
    }
}

impl ::protobuf::Clear for Service_ClusterIstio {
    fn clear(&mut self) {
        self.location.clear();
        self.cluster_name.clear();
        self.service_namespace.clear();
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service_ClusterIstio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service_ClusterIstio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service_Telemetry {
    // message fields
    pub resource_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service_Telemetry {
    fn default() -> &'a Service_Telemetry {
        <Service_Telemetry as ::protobuf::Message>::default_instance()
    }
}

impl Service_Telemetry {
    pub fn new() -> Service_Telemetry {
        ::std::default::Default::default()
    }

    // string resource_name = 1;


    pub fn get_resource_name(&self) -> &str {
        &self.resource_name
    }
    pub fn clear_resource_name(&mut self) {
        self.resource_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_name(&mut self, v: ::std::string::String) {
        self.resource_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_name(&mut self) -> &mut ::std::string::String {
        &mut self.resource_name
    }

    // Take field
    pub fn take_resource_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Service_Telemetry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.resource_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.resource_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.resource_name.is_empty() {
            os.write_string(1, &self.resource_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service_Telemetry {
        Service_Telemetry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_name",
                |m: &Service_Telemetry| { &m.resource_name },
                |m: &mut Service_Telemetry| { &mut m.resource_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service_Telemetry>(
                "Service.Telemetry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service_Telemetry {
        static instance: ::protobuf::rt::LazyV2<Service_Telemetry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service_Telemetry::new)
    }
}

impl ::protobuf::Clear for Service_Telemetry {
    fn clear(&mut self) {
        self.resource_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service_Telemetry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service_Telemetry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceLevelObjective {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub service_level_indicator: ::protobuf::SingularPtrField<ServiceLevelIndicator>,
    pub goal: f64,
    // message oneof groups
    pub period: ::std::option::Option<ServiceLevelObjective_oneof_period>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceLevelObjective {
    fn default() -> &'a ServiceLevelObjective {
        <ServiceLevelObjective as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServiceLevelObjective_oneof_period {
    rolling_period(::protobuf::well_known_types::Duration),
    calendar_period(super::calendar_period::CalendarPeriod),
}

impl ServiceLevelObjective {
    pub fn new() -> ServiceLevelObjective {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 11;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // .google.monitoring.v3.ServiceLevelIndicator service_level_indicator = 3;


    pub fn get_service_level_indicator(&self) -> &ServiceLevelIndicator {
        self.service_level_indicator.as_ref().unwrap_or_else(|| <ServiceLevelIndicator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_level_indicator(&mut self) {
        self.service_level_indicator.clear();
    }

    pub fn has_service_level_indicator(&self) -> bool {
        self.service_level_indicator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_level_indicator(&mut self, v: ServiceLevelIndicator) {
        self.service_level_indicator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_level_indicator(&mut self) -> &mut ServiceLevelIndicator {
        if self.service_level_indicator.is_none() {
            self.service_level_indicator.set_default();
        }
        self.service_level_indicator.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_level_indicator(&mut self) -> ServiceLevelIndicator {
        self.service_level_indicator.take().unwrap_or_else(|| ServiceLevelIndicator::new())
    }

    // double goal = 4;


    pub fn get_goal(&self) -> f64 {
        self.goal
    }
    pub fn clear_goal(&mut self) {
        self.goal = 0.;
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: f64) {
        self.goal = v;
    }

    // .google.protobuf.Duration rolling_period = 5;


    pub fn get_rolling_period(&self) -> &::protobuf::well_known_types::Duration {
        match self.period {
            ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rolling_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_rolling_period(&self) -> bool {
        match self.period {
            ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rolling_period(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.period = ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rolling_period(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(_)) = self.period {
        } else {
            self.period = ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(::protobuf::well_known_types::Duration::new()));
        }
        match self.period {
            ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rolling_period(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_rolling_period() {
            match self.period.take() {
                ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // .google.type.CalendarPeriod calendar_period = 6;


    pub fn get_calendar_period(&self) -> super::calendar_period::CalendarPeriod {
        match self.period {
            ::std::option::Option::Some(ServiceLevelObjective_oneof_period::calendar_period(v)) => v,
            _ => super::calendar_period::CalendarPeriod::CALENDAR_PERIOD_UNSPECIFIED,
        }
    }
    pub fn clear_calendar_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_calendar_period(&self) -> bool {
        match self.period {
            ::std::option::Option::Some(ServiceLevelObjective_oneof_period::calendar_period(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_calendar_period(&mut self, v: super::calendar_period::CalendarPeriod) {
        self.period = ::std::option::Option::Some(ServiceLevelObjective_oneof_period::calendar_period(v))
    }
}

impl ::protobuf::Message for ServiceLevelObjective {
    fn is_initialized(&self) -> bool {
        for v in &self.service_level_indicator {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ServiceLevelObjective_oneof_period::rolling_period(ref v)) = self.period {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_level_indicator)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.goal = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.period = ::std::option::Option::Some(ServiceLevelObjective_oneof_period::rolling_period(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.period = ::std::option::Option::Some(ServiceLevelObjective_oneof_period::calendar_period(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.display_name);
        }
        if let Some(ref v) = self.service_level_indicator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.goal != 0. {
            my_size += 9;
        }
        if let ::std::option::Option::Some(ref v) = self.period {
            match v {
                &ServiceLevelObjective_oneof_period::rolling_period(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ServiceLevelObjective_oneof_period::calendar_period(v) => {
                    my_size += ::protobuf::rt::enum_size(6, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(11, &self.display_name)?;
        }
        if let Some(ref v) = self.service_level_indicator.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.goal != 0. {
            os.write_double(4, self.goal)?;
        }
        if let ::std::option::Option::Some(ref v) = self.period {
            match v {
                &ServiceLevelObjective_oneof_period::rolling_period(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ServiceLevelObjective_oneof_period::calendar_period(v) => {
                    os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceLevelObjective {
        ServiceLevelObjective::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ServiceLevelObjective| { &m.name },
                |m: &mut ServiceLevelObjective| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &ServiceLevelObjective| { &m.display_name },
                |m: &mut ServiceLevelObjective| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceLevelIndicator>>(
                "service_level_indicator",
                |m: &ServiceLevelObjective| { &m.service_level_indicator },
                |m: &mut ServiceLevelObjective| { &mut m.service_level_indicator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "goal",
                |m: &ServiceLevelObjective| { &m.goal },
                |m: &mut ServiceLevelObjective| { &mut m.goal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "rolling_period",
                ServiceLevelObjective::has_rolling_period,
                ServiceLevelObjective::get_rolling_period,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, super::calendar_period::CalendarPeriod>(
                "calendar_period",
                ServiceLevelObjective::has_calendar_period,
                ServiceLevelObjective::get_calendar_period,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceLevelObjective>(
                "ServiceLevelObjective",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceLevelObjective {
        static instance: ::protobuf::rt::LazyV2<ServiceLevelObjective> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceLevelObjective::new)
    }
}

impl ::protobuf::Clear for ServiceLevelObjective {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.service_level_indicator.clear();
        self.goal = 0.;
        self.period = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceLevelObjective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceLevelObjective {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServiceLevelObjective_View {
    VIEW_UNSPECIFIED = 0,
    FULL = 2,
    EXPLICIT = 1,
}

impl ::protobuf::ProtobufEnum for ServiceLevelObjective_View {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceLevelObjective_View> {
        match value {
            0 => ::std::option::Option::Some(ServiceLevelObjective_View::VIEW_UNSPECIFIED),
            2 => ::std::option::Option::Some(ServiceLevelObjective_View::FULL),
            1 => ::std::option::Option::Some(ServiceLevelObjective_View::EXPLICIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceLevelObjective_View] = &[
            ServiceLevelObjective_View::VIEW_UNSPECIFIED,
            ServiceLevelObjective_View::FULL,
            ServiceLevelObjective_View::EXPLICIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServiceLevelObjective_View>("ServiceLevelObjective.View", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServiceLevelObjective_View {
}

impl ::std::default::Default for ServiceLevelObjective_View {
    fn default() -> Self {
        ServiceLevelObjective_View::VIEW_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceLevelObjective_View {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceLevelIndicator {
    // message oneof groups
    pub field_type: ::std::option::Option<ServiceLevelIndicator_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceLevelIndicator {
    fn default() -> &'a ServiceLevelIndicator {
        <ServiceLevelIndicator as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServiceLevelIndicator_oneof_type {
    basic_sli(BasicSli),
    request_based(RequestBasedSli),
    windows_based(WindowsBasedSli),
}

impl ServiceLevelIndicator {
    pub fn new() -> ServiceLevelIndicator {
        ::std::default::Default::default()
    }

    // .google.monitoring.v3.BasicSli basic_sli = 4;


    pub fn get_basic_sli(&self) -> &BasicSli {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(ref v)) => v,
            _ => <BasicSli as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_basic_sli(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_basic_sli(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_basic_sli(&mut self, v: BasicSli) {
        self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(v))
    }

    // Mutable pointer to the field.
    pub fn mut_basic_sli(&mut self) -> &mut BasicSli {
        if let ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(BasicSli::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_basic_sli(&mut self) -> BasicSli {
        if self.has_basic_sli() {
            match self.field_type.take() {
                ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(v)) => v,
                _ => panic!(),
            }
        } else {
            BasicSli::new()
        }
    }

    // .google.monitoring.v3.RequestBasedSli request_based = 1;


    pub fn get_request_based(&self) -> &RequestBasedSli {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(ref v)) => v,
            _ => <RequestBasedSli as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_based(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_request_based(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_based(&mut self, v: RequestBasedSli) {
        self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_based(&mut self) -> &mut RequestBasedSli {
        if let ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(RequestBasedSli::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_based(&mut self) -> RequestBasedSli {
        if self.has_request_based() {
            match self.field_type.take() {
                ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestBasedSli::new()
        }
    }

    // .google.monitoring.v3.WindowsBasedSli windows_based = 2;


    pub fn get_windows_based(&self) -> &WindowsBasedSli {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(ref v)) => v,
            _ => <WindowsBasedSli as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_windows_based(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_windows_based(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_windows_based(&mut self, v: WindowsBasedSli) {
        self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(v))
    }

    // Mutable pointer to the field.
    pub fn mut_windows_based(&mut self) -> &mut WindowsBasedSli {
        if let ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(WindowsBasedSli::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_windows_based(&mut self) -> WindowsBasedSli {
        if self.has_windows_based() {
            match self.field_type.take() {
                ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowsBasedSli::new()
        }
    }
}

impl ::protobuf::Message for ServiceLevelIndicator {
    fn is_initialized(&self) -> bool {
        if let Some(ServiceLevelIndicator_oneof_type::basic_sli(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ServiceLevelIndicator_oneof_type::request_based(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ServiceLevelIndicator_oneof_type::windows_based(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::basic_sli(is.read_message()?));
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::request_based(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(ServiceLevelIndicator_oneof_type::windows_based(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ServiceLevelIndicator_oneof_type::basic_sli(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ServiceLevelIndicator_oneof_type::request_based(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ServiceLevelIndicator_oneof_type::windows_based(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &ServiceLevelIndicator_oneof_type::basic_sli(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ServiceLevelIndicator_oneof_type::request_based(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ServiceLevelIndicator_oneof_type::windows_based(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceLevelIndicator {
        ServiceLevelIndicator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BasicSli>(
                "basic_sli",
                ServiceLevelIndicator::has_basic_sli,
                ServiceLevelIndicator::get_basic_sli,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestBasedSli>(
                "request_based",
                ServiceLevelIndicator::has_request_based,
                ServiceLevelIndicator::get_request_based,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WindowsBasedSli>(
                "windows_based",
                ServiceLevelIndicator::has_windows_based,
                ServiceLevelIndicator::get_windows_based,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceLevelIndicator>(
                "ServiceLevelIndicator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceLevelIndicator {
        static instance: ::protobuf::rt::LazyV2<ServiceLevelIndicator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceLevelIndicator::new)
    }
}

impl ::protobuf::Clear for ServiceLevelIndicator {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceLevelIndicator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceLevelIndicator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicSli {
    // message fields
    pub method: ::protobuf::RepeatedField<::std::string::String>,
    pub location: ::protobuf::RepeatedField<::std::string::String>,
    pub version: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub sli_criteria: ::std::option::Option<BasicSli_oneof_sli_criteria>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicSli {
    fn default() -> &'a BasicSli {
        <BasicSli as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BasicSli_oneof_sli_criteria {
    availability(BasicSli_AvailabilityCriteria),
    latency(BasicSli_LatencyCriteria),
}

impl BasicSli {
    pub fn new() -> BasicSli {
        ::std::default::Default::default()
    }

    // repeated string method = 7;


    pub fn get_method(&self) -> &[::std::string::String] {
        &self.method
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.method = v;
    }

    // Mutable pointer to the field.
    pub fn mut_method(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.method, ::protobuf::RepeatedField::new())
    }

    // repeated string location = 8;


    pub fn get_location(&self) -> &[::std::string::String] {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.location = v;
    }

    // Mutable pointer to the field.
    pub fn mut_location(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.location, ::protobuf::RepeatedField::new())
    }

    // repeated string version = 9;


    pub fn get_version(&self) -> &[::std::string::String] {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.version = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.version, ::protobuf::RepeatedField::new())
    }

    // .google.monitoring.v3.BasicSli.AvailabilityCriteria availability = 2;


    pub fn get_availability(&self) -> &BasicSli_AvailabilityCriteria {
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(ref v)) => v,
            _ => <BasicSli_AvailabilityCriteria as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_availability(&mut self) {
        self.sli_criteria = ::std::option::Option::None;
    }

    pub fn has_availability(&self) -> bool {
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_availability(&mut self, v: BasicSli_AvailabilityCriteria) {
        self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(v))
    }

    // Mutable pointer to the field.
    pub fn mut_availability(&mut self) -> &mut BasicSli_AvailabilityCriteria {
        if let ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(_)) = self.sli_criteria {
        } else {
            self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(BasicSli_AvailabilityCriteria::new()));
        }
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_availability(&mut self) -> BasicSli_AvailabilityCriteria {
        if self.has_availability() {
            match self.sli_criteria.take() {
                ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(v)) => v,
                _ => panic!(),
            }
        } else {
            BasicSli_AvailabilityCriteria::new()
        }
    }

    // .google.monitoring.v3.BasicSli.LatencyCriteria latency = 3;


    pub fn get_latency(&self) -> &BasicSli_LatencyCriteria {
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(ref v)) => v,
            _ => <BasicSli_LatencyCriteria as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_latency(&mut self) {
        self.sli_criteria = ::std::option::Option::None;
    }

    pub fn has_latency(&self) -> bool {
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_latency(&mut self, v: BasicSli_LatencyCriteria) {
        self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_latency(&mut self) -> &mut BasicSli_LatencyCriteria {
        if let ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(_)) = self.sli_criteria {
        } else {
            self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(BasicSli_LatencyCriteria::new()));
        }
        match self.sli_criteria {
            ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_latency(&mut self) -> BasicSli_LatencyCriteria {
        if self.has_latency() {
            match self.sli_criteria.take() {
                ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(v)) => v,
                _ => panic!(),
            }
        } else {
            BasicSli_LatencyCriteria::new()
        }
    }
}

impl ::protobuf::Message for BasicSli {
    fn is_initialized(&self) -> bool {
        if let Some(BasicSli_oneof_sli_criteria::availability(ref v)) = self.sli_criteria {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BasicSli_oneof_sli_criteria::latency(ref v)) = self.sli_criteria {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.method)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.location)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::availability(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sli_criteria = ::std::option::Option::Some(BasicSli_oneof_sli_criteria::latency(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.method {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.location {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.version {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sli_criteria {
            match v {
                &BasicSli_oneof_sli_criteria::availability(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BasicSli_oneof_sli_criteria::latency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.method {
            os.write_string(7, &v)?;
        };
        for v in &self.location {
            os.write_string(8, &v)?;
        };
        for v in &self.version {
            os.write_string(9, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sli_criteria {
            match v {
                &BasicSli_oneof_sli_criteria::availability(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BasicSli_oneof_sli_criteria::latency(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicSli {
        BasicSli::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method",
                |m: &BasicSli| { &m.method },
                |m: &mut BasicSli| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &BasicSli| { &m.location },
                |m: &mut BasicSli| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &BasicSli| { &m.version },
                |m: &mut BasicSli| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BasicSli_AvailabilityCriteria>(
                "availability",
                BasicSli::has_availability,
                BasicSli::get_availability,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BasicSli_LatencyCriteria>(
                "latency",
                BasicSli::has_latency,
                BasicSli::get_latency,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicSli>(
                "BasicSli",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicSli {
        static instance: ::protobuf::rt::LazyV2<BasicSli> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicSli::new)
    }
}

impl ::protobuf::Clear for BasicSli {
    fn clear(&mut self) {
        self.method.clear();
        self.location.clear();
        self.version.clear();
        self.sli_criteria = ::std::option::Option::None;
        self.sli_criteria = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicSli {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicSli {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicSli_AvailabilityCriteria {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicSli_AvailabilityCriteria {
    fn default() -> &'a BasicSli_AvailabilityCriteria {
        <BasicSli_AvailabilityCriteria as ::protobuf::Message>::default_instance()
    }
}

impl BasicSli_AvailabilityCriteria {
    pub fn new() -> BasicSli_AvailabilityCriteria {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BasicSli_AvailabilityCriteria {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicSli_AvailabilityCriteria {
        BasicSli_AvailabilityCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicSli_AvailabilityCriteria>(
                "BasicSli.AvailabilityCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicSli_AvailabilityCriteria {
        static instance: ::protobuf::rt::LazyV2<BasicSli_AvailabilityCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicSli_AvailabilityCriteria::new)
    }
}

impl ::protobuf::Clear for BasicSli_AvailabilityCriteria {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicSli_AvailabilityCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicSli_AvailabilityCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicSli_LatencyCriteria {
    // message fields
    pub threshold: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BasicSli_LatencyCriteria {
    fn default() -> &'a BasicSli_LatencyCriteria {
        <BasicSli_LatencyCriteria as ::protobuf::Message>::default_instance()
    }
}

impl BasicSli_LatencyCriteria {
    pub fn new() -> BasicSli_LatencyCriteria {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration threshold = 3;


    pub fn get_threshold(&self) -> &::protobuf::well_known_types::Duration {
        self.threshold.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_threshold(&mut self) {
        self.threshold.clear();
    }

    pub fn has_threshold(&self) -> bool {
        self.threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.threshold = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_threshold(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.threshold.is_none() {
            self.threshold.set_default();
        }
        self.threshold.as_mut().unwrap()
    }

    // Take field
    pub fn take_threshold(&mut self) -> ::protobuf::well_known_types::Duration {
        self.threshold.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for BasicSli_LatencyCriteria {
    fn is_initialized(&self) -> bool {
        for v in &self.threshold {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.threshold)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.threshold.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.threshold.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicSli_LatencyCriteria {
        BasicSli_LatencyCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "threshold",
                |m: &BasicSli_LatencyCriteria| { &m.threshold },
                |m: &mut BasicSli_LatencyCriteria| { &mut m.threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BasicSli_LatencyCriteria>(
                "BasicSli.LatencyCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BasicSli_LatencyCriteria {
        static instance: ::protobuf::rt::LazyV2<BasicSli_LatencyCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BasicSli_LatencyCriteria::new)
    }
}

impl ::protobuf::Clear for BasicSli_LatencyCriteria {
    fn clear(&mut self) {
        self.threshold.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicSli_LatencyCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicSli_LatencyCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Range {
    // message fields
    pub min: f64,
    pub max: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Range {
    fn default() -> &'a Range {
        <Range as ::protobuf::Message>::default_instance()
    }
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // double min = 1;


    pub fn get_min(&self) -> f64 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: f64) {
        self.min = v;
    }

    // double max = 2;


    pub fn get_max(&self) -> f64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: f64) {
        self.max = v;
    }
}

impl ::protobuf::Message for Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min != 0. {
            my_size += 9;
        }
        if self.max != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min != 0. {
            os.write_double(1, self.min)?;
        }
        if self.max != 0. {
            os.write_double(2, self.max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Range {
        Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "min",
                |m: &Range| { &m.min },
                |m: &mut Range| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "max",
                |m: &Range| { &m.max },
                |m: &mut Range| { &mut m.max },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Range>(
                "Range",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Range {
        static instance: ::protobuf::rt::LazyV2<Range> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Range::new)
    }
}

impl ::protobuf::Clear for Range {
    fn clear(&mut self) {
        self.min = 0.;
        self.max = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestBasedSli {
    // message oneof groups
    pub method: ::std::option::Option<RequestBasedSli_oneof_method>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestBasedSli {
    fn default() -> &'a RequestBasedSli {
        <RequestBasedSli as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestBasedSli_oneof_method {
    good_total_ratio(TimeSeriesRatio),
    distribution_cut(DistributionCut),
}

impl RequestBasedSli {
    pub fn new() -> RequestBasedSli {
        ::std::default::Default::default()
    }

    // .google.monitoring.v3.TimeSeriesRatio good_total_ratio = 1;


    pub fn get_good_total_ratio(&self) -> &TimeSeriesRatio {
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(ref v)) => v,
            _ => <TimeSeriesRatio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_good_total_ratio(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_good_total_ratio(&self) -> bool {
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_good_total_ratio(&mut self, v: TimeSeriesRatio) {
        self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_good_total_ratio(&mut self) -> &mut TimeSeriesRatio {
        if let ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(_)) = self.method {
        } else {
            self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(TimeSeriesRatio::new()));
        }
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_good_total_ratio(&mut self) -> TimeSeriesRatio {
        if self.has_good_total_ratio() {
            match self.method.take() {
                ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(v)) => v,
                _ => panic!(),
            }
        } else {
            TimeSeriesRatio::new()
        }
    }

    // .google.monitoring.v3.DistributionCut distribution_cut = 3;


    pub fn get_distribution_cut(&self) -> &DistributionCut {
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(ref v)) => v,
            _ => <DistributionCut as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_distribution_cut(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_distribution_cut(&self) -> bool {
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_distribution_cut(&mut self, v: DistributionCut) {
        self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(v))
    }

    // Mutable pointer to the field.
    pub fn mut_distribution_cut(&mut self) -> &mut DistributionCut {
        if let ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(_)) = self.method {
        } else {
            self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(DistributionCut::new()));
        }
        match self.method {
            ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_distribution_cut(&mut self) -> DistributionCut {
        if self.has_distribution_cut() {
            match self.method.take() {
                ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(v)) => v,
                _ => panic!(),
            }
        } else {
            DistributionCut::new()
        }
    }
}

impl ::protobuf::Message for RequestBasedSli {
    fn is_initialized(&self) -> bool {
        if let Some(RequestBasedSli_oneof_method::good_total_ratio(ref v)) = self.method {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestBasedSli_oneof_method::distribution_cut(ref v)) = self.method {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::good_total_ratio(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.method = ::std::option::Option::Some(RequestBasedSli_oneof_method::distribution_cut(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.method {
            match v {
                &RequestBasedSli_oneof_method::good_total_ratio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestBasedSli_oneof_method::distribution_cut(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.method {
            match v {
                &RequestBasedSli_oneof_method::good_total_ratio(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestBasedSli_oneof_method::distribution_cut(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestBasedSli {
        RequestBasedSli::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TimeSeriesRatio>(
                "good_total_ratio",
                RequestBasedSli::has_good_total_ratio,
                RequestBasedSli::get_good_total_ratio,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DistributionCut>(
                "distribution_cut",
                RequestBasedSli::has_distribution_cut,
                RequestBasedSli::get_distribution_cut,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestBasedSli>(
                "RequestBasedSli",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestBasedSli {
        static instance: ::protobuf::rt::LazyV2<RequestBasedSli> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestBasedSli::new)
    }
}

impl ::protobuf::Clear for RequestBasedSli {
    fn clear(&mut self) {
        self.method = ::std::option::Option::None;
        self.method = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestBasedSli {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestBasedSli {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeSeriesRatio {
    // message fields
    pub good_service_filter: ::std::string::String,
    pub bad_service_filter: ::std::string::String,
    pub total_service_filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeSeriesRatio {
    fn default() -> &'a TimeSeriesRatio {
        <TimeSeriesRatio as ::protobuf::Message>::default_instance()
    }
}

impl TimeSeriesRatio {
    pub fn new() -> TimeSeriesRatio {
        ::std::default::Default::default()
    }

    // string good_service_filter = 4;


    pub fn get_good_service_filter(&self) -> &str {
        &self.good_service_filter
    }
    pub fn clear_good_service_filter(&mut self) {
        self.good_service_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_good_service_filter(&mut self, v: ::std::string::String) {
        self.good_service_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_good_service_filter(&mut self) -> &mut ::std::string::String {
        &mut self.good_service_filter
    }

    // Take field
    pub fn take_good_service_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.good_service_filter, ::std::string::String::new())
    }

    // string bad_service_filter = 5;


    pub fn get_bad_service_filter(&self) -> &str {
        &self.bad_service_filter
    }
    pub fn clear_bad_service_filter(&mut self) {
        self.bad_service_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_bad_service_filter(&mut self, v: ::std::string::String) {
        self.bad_service_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bad_service_filter(&mut self) -> &mut ::std::string::String {
        &mut self.bad_service_filter
    }

    // Take field
    pub fn take_bad_service_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bad_service_filter, ::std::string::String::new())
    }

    // string total_service_filter = 6;


    pub fn get_total_service_filter(&self) -> &str {
        &self.total_service_filter
    }
    pub fn clear_total_service_filter(&mut self) {
        self.total_service_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_service_filter(&mut self, v: ::std::string::String) {
        self.total_service_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_service_filter(&mut self) -> &mut ::std::string::String {
        &mut self.total_service_filter
    }

    // Take field
    pub fn take_total_service_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_service_filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TimeSeriesRatio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.good_service_filter)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bad_service_filter)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_service_filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.good_service_filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.good_service_filter);
        }
        if !self.bad_service_filter.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bad_service_filter);
        }
        if !self.total_service_filter.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.total_service_filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.good_service_filter.is_empty() {
            os.write_string(4, &self.good_service_filter)?;
        }
        if !self.bad_service_filter.is_empty() {
            os.write_string(5, &self.bad_service_filter)?;
        }
        if !self.total_service_filter.is_empty() {
            os.write_string(6, &self.total_service_filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeSeriesRatio {
        TimeSeriesRatio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "good_service_filter",
                |m: &TimeSeriesRatio| { &m.good_service_filter },
                |m: &mut TimeSeriesRatio| { &mut m.good_service_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bad_service_filter",
                |m: &TimeSeriesRatio| { &m.bad_service_filter },
                |m: &mut TimeSeriesRatio| { &mut m.bad_service_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "total_service_filter",
                |m: &TimeSeriesRatio| { &m.total_service_filter },
                |m: &mut TimeSeriesRatio| { &mut m.total_service_filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeSeriesRatio>(
                "TimeSeriesRatio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeSeriesRatio {
        static instance: ::protobuf::rt::LazyV2<TimeSeriesRatio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeSeriesRatio::new)
    }
}

impl ::protobuf::Clear for TimeSeriesRatio {
    fn clear(&mut self) {
        self.good_service_filter.clear();
        self.bad_service_filter.clear();
        self.total_service_filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeSeriesRatio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSeriesRatio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DistributionCut {
    // message fields
    pub distribution_filter: ::std::string::String,
    pub range: ::protobuf::SingularPtrField<Range>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DistributionCut {
    fn default() -> &'a DistributionCut {
        <DistributionCut as ::protobuf::Message>::default_instance()
    }
}

impl DistributionCut {
    pub fn new() -> DistributionCut {
        ::std::default::Default::default()
    }

    // string distribution_filter = 4;


    pub fn get_distribution_filter(&self) -> &str {
        &self.distribution_filter
    }
    pub fn clear_distribution_filter(&mut self) {
        self.distribution_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_distribution_filter(&mut self, v: ::std::string::String) {
        self.distribution_filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_distribution_filter(&mut self) -> &mut ::std::string::String {
        &mut self.distribution_filter
    }

    // Take field
    pub fn take_distribution_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.distribution_filter, ::std::string::String::new())
    }

    // .google.monitoring.v3.Range range = 5;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| <Range as ::protobuf::Message>::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }
}

impl ::protobuf::Message for DistributionCut {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.distribution_filter)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.distribution_filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.distribution_filter);
        }
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.distribution_filter.is_empty() {
            os.write_string(4, &self.distribution_filter)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DistributionCut {
        DistributionCut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "distribution_filter",
                |m: &DistributionCut| { &m.distribution_filter },
                |m: &mut DistributionCut| { &mut m.distribution_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Range>>(
                "range",
                |m: &DistributionCut| { &m.range },
                |m: &mut DistributionCut| { &mut m.range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DistributionCut>(
                "DistributionCut",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DistributionCut {
        static instance: ::protobuf::rt::LazyV2<DistributionCut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DistributionCut::new)
    }
}

impl ::protobuf::Clear for DistributionCut {
    fn clear(&mut self) {
        self.distribution_filter.clear();
        self.range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DistributionCut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DistributionCut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsBasedSli {
    // message fields
    pub window_period: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // message oneof groups
    pub window_criterion: ::std::option::Option<WindowsBasedSli_oneof_window_criterion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsBasedSli {
    fn default() -> &'a WindowsBasedSli {
        <WindowsBasedSli as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum WindowsBasedSli_oneof_window_criterion {
    good_bad_metric_filter(::std::string::String),
    good_total_ratio_threshold(WindowsBasedSli_PerformanceThreshold),
    metric_mean_in_range(WindowsBasedSli_MetricRange),
    metric_sum_in_range(WindowsBasedSli_MetricRange),
}

impl WindowsBasedSli {
    pub fn new() -> WindowsBasedSli {
        ::std::default::Default::default()
    }

    // string good_bad_metric_filter = 5;


    pub fn get_good_bad_metric_filter(&self) -> &str {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_good_bad_metric_filter(&mut self) {
        self.window_criterion = ::std::option::Option::None;
    }

    pub fn has_good_bad_metric_filter(&self) -> bool {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_good_bad_metric_filter(&mut self, v: ::std::string::String) {
        self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_good_bad_metric_filter(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(_)) = self.window_criterion {
        } else {
            self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(::std::string::String::new()));
        }
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_good_bad_metric_filter(&mut self) -> ::std::string::String {
        if self.has_good_bad_metric_filter() {
            match self.window_criterion.take() {
                ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.monitoring.v3.WindowsBasedSli.PerformanceThreshold good_total_ratio_threshold = 2;


    pub fn get_good_total_ratio_threshold(&self) -> &WindowsBasedSli_PerformanceThreshold {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(ref v)) => v,
            _ => <WindowsBasedSli_PerformanceThreshold as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_good_total_ratio_threshold(&mut self) {
        self.window_criterion = ::std::option::Option::None;
    }

    pub fn has_good_total_ratio_threshold(&self) -> bool {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_good_total_ratio_threshold(&mut self, v: WindowsBasedSli_PerformanceThreshold) {
        self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_good_total_ratio_threshold(&mut self) -> &mut WindowsBasedSli_PerformanceThreshold {
        if let ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(_)) = self.window_criterion {
        } else {
            self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(WindowsBasedSli_PerformanceThreshold::new()));
        }
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_good_total_ratio_threshold(&mut self) -> WindowsBasedSli_PerformanceThreshold {
        if self.has_good_total_ratio_threshold() {
            match self.window_criterion.take() {
                ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowsBasedSli_PerformanceThreshold::new()
        }
    }

    // .google.monitoring.v3.WindowsBasedSli.MetricRange metric_mean_in_range = 6;


    pub fn get_metric_mean_in_range(&self) -> &WindowsBasedSli_MetricRange {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(ref v)) => v,
            _ => <WindowsBasedSli_MetricRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metric_mean_in_range(&mut self) {
        self.window_criterion = ::std::option::Option::None;
    }

    pub fn has_metric_mean_in_range(&self) -> bool {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metric_mean_in_range(&mut self, v: WindowsBasedSli_MetricRange) {
        self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metric_mean_in_range(&mut self) -> &mut WindowsBasedSli_MetricRange {
        if let ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(_)) = self.window_criterion {
        } else {
            self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(WindowsBasedSli_MetricRange::new()));
        }
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metric_mean_in_range(&mut self) -> WindowsBasedSli_MetricRange {
        if self.has_metric_mean_in_range() {
            match self.window_criterion.take() {
                ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowsBasedSli_MetricRange::new()
        }
    }

    // .google.monitoring.v3.WindowsBasedSli.MetricRange metric_sum_in_range = 7;


    pub fn get_metric_sum_in_range(&self) -> &WindowsBasedSli_MetricRange {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(ref v)) => v,
            _ => <WindowsBasedSli_MetricRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metric_sum_in_range(&mut self) {
        self.window_criterion = ::std::option::Option::None;
    }

    pub fn has_metric_sum_in_range(&self) -> bool {
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metric_sum_in_range(&mut self, v: WindowsBasedSli_MetricRange) {
        self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metric_sum_in_range(&mut self) -> &mut WindowsBasedSli_MetricRange {
        if let ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(_)) = self.window_criterion {
        } else {
            self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(WindowsBasedSli_MetricRange::new()));
        }
        match self.window_criterion {
            ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metric_sum_in_range(&mut self) -> WindowsBasedSli_MetricRange {
        if self.has_metric_sum_in_range() {
            match self.window_criterion.take() {
                ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(v)) => v,
                _ => panic!(),
            }
        } else {
            WindowsBasedSli_MetricRange::new()
        }
    }

    // .google.protobuf.Duration window_period = 4;


    pub fn get_window_period(&self) -> &::protobuf::well_known_types::Duration {
        self.window_period.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window_period(&mut self) {
        self.window_period.clear();
    }

    pub fn has_window_period(&self) -> bool {
        self.window_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_period(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.window_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_period(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.window_period.is_none() {
            self.window_period.set_default();
        }
        self.window_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_period(&mut self) -> ::protobuf::well_known_types::Duration {
        self.window_period.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for WindowsBasedSli {
    fn is_initialized(&self) -> bool {
        if let Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(ref v)) = self.window_criterion {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(ref v)) = self.window_criterion {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(ref v)) = self.window_criterion {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.window_period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.window_criterion = ::std::option::Option::Some(WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window_period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.window_criterion {
            match v {
                &WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window_period.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.window_criterion {
            match v {
                &WindowsBasedSli_oneof_window_criterion::good_bad_metric_filter(ref v) => {
                    os.write_string(5, v)?;
                },
                &WindowsBasedSli_oneof_window_criterion::good_total_ratio_threshold(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WindowsBasedSli_oneof_window_criterion::metric_mean_in_range(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WindowsBasedSli_oneof_window_criterion::metric_sum_in_range(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsBasedSli {
        WindowsBasedSli::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "good_bad_metric_filter",
                WindowsBasedSli::has_good_bad_metric_filter,
                WindowsBasedSli::get_good_bad_metric_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WindowsBasedSli_PerformanceThreshold>(
                "good_total_ratio_threshold",
                WindowsBasedSli::has_good_total_ratio_threshold,
                WindowsBasedSli::get_good_total_ratio_threshold,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WindowsBasedSli_MetricRange>(
                "metric_mean_in_range",
                WindowsBasedSli::has_metric_mean_in_range,
                WindowsBasedSli::get_metric_mean_in_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WindowsBasedSli_MetricRange>(
                "metric_sum_in_range",
                WindowsBasedSli::has_metric_sum_in_range,
                WindowsBasedSli::get_metric_sum_in_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "window_period",
                |m: &WindowsBasedSli| { &m.window_period },
                |m: &mut WindowsBasedSli| { &mut m.window_period },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsBasedSli>(
                "WindowsBasedSli",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsBasedSli {
        static instance: ::protobuf::rt::LazyV2<WindowsBasedSli> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsBasedSli::new)
    }
}

impl ::protobuf::Clear for WindowsBasedSli {
    fn clear(&mut self) {
        self.window_criterion = ::std::option::Option::None;
        self.window_criterion = ::std::option::Option::None;
        self.window_criterion = ::std::option::Option::None;
        self.window_criterion = ::std::option::Option::None;
        self.window_period.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsBasedSli {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsBasedSli {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsBasedSli_PerformanceThreshold {
    // message fields
    pub threshold: f64,
    // message oneof groups
    pub field_type: ::std::option::Option<WindowsBasedSli_PerformanceThreshold_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsBasedSli_PerformanceThreshold {
    fn default() -> &'a WindowsBasedSli_PerformanceThreshold {
        <WindowsBasedSli_PerformanceThreshold as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum WindowsBasedSli_PerformanceThreshold_oneof_type {
    performance(RequestBasedSli),
    basic_sli_performance(BasicSli),
}

impl WindowsBasedSli_PerformanceThreshold {
    pub fn new() -> WindowsBasedSli_PerformanceThreshold {
        ::std::default::Default::default()
    }

    // .google.monitoring.v3.RequestBasedSli performance = 1;


    pub fn get_performance(&self) -> &RequestBasedSli {
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(ref v)) => v,
            _ => <RequestBasedSli as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_performance(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_performance(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_performance(&mut self, v: RequestBasedSli) {
        self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(v))
    }

    // Mutable pointer to the field.
    pub fn mut_performance(&mut self) -> &mut RequestBasedSli {
        if let ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(RequestBasedSli::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_performance(&mut self) -> RequestBasedSli {
        if self.has_performance() {
            match self.field_type.take() {
                ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestBasedSli::new()
        }
    }

    // .google.monitoring.v3.BasicSli basic_sli_performance = 3;


    pub fn get_basic_sli_performance(&self) -> &BasicSli {
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(ref v)) => v,
            _ => <BasicSli as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_basic_sli_performance(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_basic_sli_performance(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_basic_sli_performance(&mut self, v: BasicSli) {
        self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(v))
    }

    // Mutable pointer to the field.
    pub fn mut_basic_sli_performance(&mut self) -> &mut BasicSli {
        if let ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(BasicSli::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_basic_sli_performance(&mut self) -> BasicSli {
        if self.has_basic_sli_performance() {
            match self.field_type.take() {
                ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(v)) => v,
                _ => panic!(),
            }
        } else {
            BasicSli::new()
        }
    }

    // double threshold = 2;


    pub fn get_threshold(&self) -> f64 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: f64) {
        self.threshold = v;
    }
}

impl ::protobuf::Message for WindowsBasedSli_PerformanceThreshold {
    fn is_initialized(&self) -> bool {
        if let Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::performance(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.threshold = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0. {
            my_size += 9;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &WindowsBasedSli_PerformanceThreshold_oneof_type::performance(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0. {
            os.write_double(2, self.threshold)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &WindowsBasedSli_PerformanceThreshold_oneof_type::performance(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WindowsBasedSli_PerformanceThreshold_oneof_type::basic_sli_performance(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsBasedSli_PerformanceThreshold {
        WindowsBasedSli_PerformanceThreshold::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestBasedSli>(
                "performance",
                WindowsBasedSli_PerformanceThreshold::has_performance,
                WindowsBasedSli_PerformanceThreshold::get_performance,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BasicSli>(
                "basic_sli_performance",
                WindowsBasedSli_PerformanceThreshold::has_basic_sli_performance,
                WindowsBasedSli_PerformanceThreshold::get_basic_sli_performance,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "threshold",
                |m: &WindowsBasedSli_PerformanceThreshold| { &m.threshold },
                |m: &mut WindowsBasedSli_PerformanceThreshold| { &mut m.threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsBasedSli_PerformanceThreshold>(
                "WindowsBasedSli.PerformanceThreshold",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsBasedSli_PerformanceThreshold {
        static instance: ::protobuf::rt::LazyV2<WindowsBasedSli_PerformanceThreshold> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsBasedSli_PerformanceThreshold::new)
    }
}

impl ::protobuf::Clear for WindowsBasedSli_PerformanceThreshold {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.threshold = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsBasedSli_PerformanceThreshold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsBasedSli_PerformanceThreshold {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsBasedSli_MetricRange {
    // message fields
    pub time_series: ::std::string::String,
    pub range: ::protobuf::SingularPtrField<Range>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsBasedSli_MetricRange {
    fn default() -> &'a WindowsBasedSli_MetricRange {
        <WindowsBasedSli_MetricRange as ::protobuf::Message>::default_instance()
    }
}

impl WindowsBasedSli_MetricRange {
    pub fn new() -> WindowsBasedSli_MetricRange {
        ::std::default::Default::default()
    }

    // string time_series = 1;


    pub fn get_time_series(&self) -> &str {
        &self.time_series
    }
    pub fn clear_time_series(&mut self) {
        self.time_series.clear();
    }

    // Param is passed by value, moved
    pub fn set_time_series(&mut self, v: ::std::string::String) {
        self.time_series = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_series(&mut self) -> &mut ::std::string::String {
        &mut self.time_series
    }

    // Take field
    pub fn take_time_series(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.time_series, ::std::string::String::new())
    }

    // .google.monitoring.v3.Range range = 4;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| <Range as ::protobuf::Message>::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }
}

impl ::protobuf::Message for WindowsBasedSli_MetricRange {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.time_series)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.time_series.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.time_series);
        }
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.time_series.is_empty() {
            os.write_string(1, &self.time_series)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsBasedSli_MetricRange {
        WindowsBasedSli_MetricRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "time_series",
                |m: &WindowsBasedSli_MetricRange| { &m.time_series },
                |m: &mut WindowsBasedSli_MetricRange| { &mut m.time_series },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Range>>(
                "range",
                |m: &WindowsBasedSli_MetricRange| { &m.range },
                |m: &mut WindowsBasedSli_MetricRange| { &mut m.range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsBasedSli_MetricRange>(
                "WindowsBasedSli.MetricRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsBasedSli_MetricRange {
        static instance: ::protobuf::rt::LazyV2<WindowsBasedSli_MetricRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsBasedSli_MetricRange::new)
    }
}

impl ::protobuf::Clear for WindowsBasedSli_MetricRange {
    fn clear(&mut self) {
        self.time_series.clear();
        self.range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsBasedSli_MetricRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsBasedSli_MetricRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"google/monitoring/v3/service.proto\x12\x14google.monitoring.v3\x1a#g\
    oogle/api/monitored_resource.proto\x1a\x1egoogle/protobuf/duration.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a!google/type/calendar_period.\
    proto\"\xfd\x05\n\x07Service\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdisplayName\x12>\n\x06c\
    ustom\x18\x06\x20\x01(\x0b2$.google.monitoring.v3.Service.CustomH\0R\x06\
    custom\x12H\n\napp_engine\x18\x07\x20\x01(\x0b2'.google.monitoring.v3.Se\
    rvice.AppEngineH\0R\tappEngine\x12W\n\x0fcloud_endpoints\x18\x08\x20\x01\
    (\x0b2,.google.monitoring.v3.Service.CloudEndpointsH\0R\x0ecloudEndpoint\
    s\x12Q\n\rcluster_istio\x18\t\x20\x01(\x0b2*.google.monitoring.v3.Servic\
    e.ClusterIstioH\0R\x0cclusterIstio\x12E\n\ttelemetry\x18\r\x20\x01(\x0b2\
    '.google.monitoring.v3.Service.TelemetryR\ttelemetry\x1a\x08\n\x06Custom\
    \x1a(\n\tAppEngine\x12\x1b\n\tmodule_id\x18\x01\x20\x01(\tR\x08moduleId\
    \x1a*\n\x0eCloudEndpoints\x12\x18\n\x07service\x18\x01\x20\x01(\tR\x07se\
    rvice\x1a\x9d\x01\n\x0cClusterIstio\x12\x1a\n\x08location\x18\x01\x20\
    \x01(\tR\x08location\x12!\n\x0ccluster_name\x18\x02\x20\x01(\tR\x0bclust\
    erName\x12+\n\x11service_namespace\x18\x03\x20\x01(\tR\x10serviceNamespa\
    ce\x12!\n\x0cservice_name\x18\x04\x20\x01(\tR\x0bserviceName\x1a0\n\tTel\
    emetry\x12#\n\rresource_name\x18\x01\x20\x01(\tR\x0cresourceNameB\x0c\n\
    \nidentifier\"\x93\x03\n\x15ServiceLevelObjective\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\x0b\x20\x01(\tR\x0bd\
    isplayName\x12c\n\x17service_level_indicator\x18\x03\x20\x01(\x0b2+.goog\
    le.monitoring.v3.ServiceLevelIndicatorR\x15serviceLevelIndicator\x12\x12\
    \n\x04goal\x18\x04\x20\x01(\x01R\x04goal\x12B\n\x0erolling_period\x18\
    \x05\x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\rrollingPeriod\x12F\
    \n\x0fcalendar_period\x18\x06\x20\x01(\x0e2\x1b.google.type.CalendarPeri\
    odH\0R\x0ecalendarPeriod\"4\n\x04View\x12\x14\n\x10VIEW_UNSPECIFIED\x10\
    \0\x12\x08\n\x04FULL\x10\x02\x12\x0c\n\x08EXPLICIT\x10\x01B\x08\n\x06per\
    iod\"\xfa\x01\n\x15ServiceLevelIndicator\x12=\n\tbasic_sli\x18\x04\x20\
    \x01(\x0b2\x1e.google.monitoring.v3.BasicSliH\0R\x08basicSli\x12L\n\rreq\
    uest_based\x18\x01\x20\x01(\x0b2%.google.monitoring.v3.RequestBasedSliH\
    \0R\x0crequestBased\x12L\n\rwindows_based\x18\x02\x20\x01(\x0b2%.google.\
    monitoring.v3.WindowsBasedSliH\0R\x0cwindowsBasedB\x06\n\x04type\"\xf3\
    \x02\n\x08BasicSli\x12\x16\n\x06method\x18\x07\x20\x03(\tR\x06method\x12\
    \x1a\n\x08location\x18\x08\x20\x03(\tR\x08location\x12\x18\n\x07version\
    \x18\t\x20\x03(\tR\x07version\x12Y\n\x0cavailability\x18\x02\x20\x01(\
    \x0b23.google.monitoring.v3.BasicSli.AvailabilityCriteriaH\0R\x0cavailab\
    ility\x12J\n\x07latency\x18\x03\x20\x01(\x0b2..google.monitoring.v3.Basi\
    cSli.LatencyCriteriaH\0R\x07latency\x1a\x16\n\x14AvailabilityCriteria\
    \x1aJ\n\x0fLatencyCriteria\x127\n\tthreshold\x18\x03\x20\x01(\x0b2\x19.g\
    oogle.protobuf.DurationR\tthresholdB\x0e\n\x0csli_criteria\"+\n\x05Range\
    \x12\x10\n\x03min\x18\x01\x20\x01(\x01R\x03min\x12\x10\n\x03max\x18\x02\
    \x20\x01(\x01R\x03max\"\xc2\x01\n\x0fRequestBasedSli\x12Q\n\x10good_tota\
    l_ratio\x18\x01\x20\x01(\x0b2%.google.monitoring.v3.TimeSeriesRatioH\0R\
    \x0egoodTotalRatio\x12R\n\x10distribution_cut\x18\x03\x20\x01(\x0b2%.goo\
    gle.monitoring.v3.DistributionCutH\0R\x0fdistributionCutB\x08\n\x06metho\
    d\"\xa1\x01\n\x0fTimeSeriesRatio\x12.\n\x13good_service_filter\x18\x04\
    \x20\x01(\tR\x11goodServiceFilter\x12,\n\x12bad_service_filter\x18\x05\
    \x20\x01(\tR\x10badServiceFilter\x120\n\x14total_service_filter\x18\x06\
    \x20\x01(\tR\x12totalServiceFilter\"u\n\x0fDistributionCut\x12/\n\x13dis\
    tribution_filter\x18\x04\x20\x01(\tR\x12distributionFilter\x121\n\x05ran\
    ge\x18\x05\x20\x01(\x0b2\x1b.google.monitoring.v3.RangeR\x05range\"\xa4\
    \x06\n\x0fWindowsBasedSli\x125\n\x16good_bad_metric_filter\x18\x05\x20\
    \x01(\tH\0R\x13goodBadMetricFilter\x12y\n\x1agood_total_ratio_threshold\
    \x18\x02\x20\x01(\x0b2:.google.monitoring.v3.WindowsBasedSli.Performance\
    ThresholdH\0R\x17goodTotalRatioThreshold\x12d\n\x14metric_mean_in_range\
    \x18\x06\x20\x01(\x0b21.google.monitoring.v3.WindowsBasedSli.MetricRange\
    H\0R\x11metricMeanInRange\x12b\n\x13metric_sum_in_range\x18\x07\x20\x01(\
    \x0b21.google.monitoring.v3.WindowsBasedSli.MetricRangeH\0R\x10metricSum\
    InRange\x12>\n\rwindow_period\x18\x04\x20\x01(\x0b2\x19.google.protobuf.\
    DurationR\x0cwindowPeriod\x1a\xdd\x01\n\x14PerformanceThreshold\x12I\n\
    \x0bperformance\x18\x01\x20\x01(\x0b2%.google.monitoring.v3.RequestBased\
    SliH\0R\x0bperformance\x12T\n\x15basic_sli_performance\x18\x03\x20\x01(\
    \x0b2\x1e.google.monitoring.v3.BasicSliH\0R\x13basicSliPerformance\x12\
    \x1c\n\tthreshold\x18\x02\x20\x01(\x01R\tthresholdB\x06\n\x04type\x1aa\n\
    \x0bMetricRange\x12\x1f\n\x0btime_series\x18\x01\x20\x01(\tR\ntimeSeries\
    \x121\n\x05range\x18\x04\x20\x01(\x0b2\x1b.google.monitoring.v3.RangeR\
    \x05rangeB\x12\n\x10window_criterionB\xae\x01\n\x18com.google.monitoring\
    .v3B\x16ServiceMonitoringProtoP\x01Z>google.golang.org/genproto/googleap\
    is/monitoring/v3;monitoring\xaa\x02\x1aGoogle.Cloud.Monitoring.V3\xca\
    \x02\x1aGoogle\\Cloud\\Monitoring\\V3J\xb9\x7f\n\x07\x12\x05\x0f\0\xfa\
    \x02\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x20\
    2019\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20Lice\
    nse,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\
    \x1d\n\t\n\x02\x03\0\x12\x03\x13\0-\n\t\n\x02\x03\x01\x12\x03\x14\0(\n\t\
    \n\x02\x03\x02\x12\x03\x15\0)\n\t\n\x02\x03\x03\x12\x03\x16\0+\n\x08\n\
    \x01\x08\x12\x03\x18\07\n\t\n\x02\x08%\x12\x03\x18\07\n\x08\n\x01\x08\
    \x12\x03\x19\0U\n\t\n\x02\x08\x0b\x12\x03\x19\0U\n\x08\n\x01\x08\x12\x03\
    \x1a\0\"\n\t\n\x02\x08\n\x12\x03\x1a\0\"\n\x08\n\x01\x08\x12\x03\x1b\07\
    \n\t\n\x02\x08\x08\x12\x03\x1b\07\n\x08\n\x01\x08\x12\x03\x1c\01\n\t\n\
    \x02\x08\x01\x12\x03\x1c\01\n\x08\n\x01\x08\x12\x03\x1d\07\n\t\n\x02\x08\
    )\x12\x03\x1d\07\n\xc0\x02\n\x02\x04\0\x12\x04$\0o\x01\x1a\xb3\x02\x20A\
    \x20`Service`\x20is\x20a\x20discrete,\x20autonomous,\x20and\x20network-a\
    ccessible\x20unit,\x20designed\n\x20to\x20solve\x20an\x20individual\x20c\
    oncern\n\x20([Wikipedia](https://en.wikipedia.org/wiki/Service-orientati\
    on)).\x20In\n\x20Stackdriver\x20Monitoring,\x20a\x20`Service`\x20acts\
    \x20as\x20the\x20root\x20resource\x20under\x20which\n\x20operational\x20\
    aspects\x20of\x20the\x20service\x20are\x20accessible.\n\n\n\n\x03\x04\0\
    \x01\x12\x03$\x08\x0f\na\n\x04\x04\0\x03\0\x12\x04'\x02)\x03\x1aS\x20Cus\
    tom\x20view\x20of\x20service\x20telemetry.\x20Currently\x20a\x20place-ho\
    lder\x20pending\x20final\n\x20design.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\
    \x03'\n\x10\nU\n\x04\x04\0\x03\x01\x12\x04,\x021\x03\x1aG\x20App\x20Engi\
    ne\x20service.\x20Learn\x20more\x20at\x20https://cloud.google.com/appeng\
    ine.\n\n\x0c\n\x05\x04\0\x03\x01\x01\x12\x03,\n\x13\n\xdd\x01\n\x06\x04\
    \0\x03\x01\x02\0\x12\x030\x04\x19\x1a\xcd\x01\x20The\x20ID\x20of\x20the\
    \x20App\x20Engine\x20module\x20underlying\x20this\x20service.\x20Corresp\
    onds\x20to\n\x20the\x20`module_id`\x20resource\x20label\x20in\x20the\x20\
    `gae_app`\x20monitored\x20resource:\n\x20https://cloud.google.com/monito\
    ring/api/resources#tag_gae_app\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\
    \x030\x04\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\x030\x0b\x14\n\x0e\n\
    \x07\x04\0\x03\x01\x02\0\x03\x12\x030\x17\x18\nZ\n\x04\x04\0\x03\x02\x12\
    \x044\x029\x03\x1aL\x20Cloud\x20Endpoints\x20service.\x20Learn\x20more\
    \x20at\x20https://cloud.google.com/endpoints.\n\n\x0c\n\x05\x04\0\x03\
    \x02\x01\x12\x034\n\x18\n\xdb\x01\n\x06\x04\0\x03\x02\x02\0\x12\x038\x04\
    \x17\x1a\xcb\x01\x20The\x20name\x20of\x20the\x20Cloud\x20Endpoints\x20se\
    rvice\x20underlying\x20this\x20service.\n\x20Corresponds\x20to\x20the\
    \x20`service`\x20resource\x20label\x20in\x20the\x20`api`\x20monitored\n\
    \x20resource:\x20https://cloud.google.com/monitoring/api/resources#tag_a\
    pi\n\n\x0e\n\x07\x04\0\x03\x02\x02\0\x05\x12\x038\x04\n\n\x0e\n\x07\x04\
    \0\x03\x02\x02\0\x01\x12\x038\x0b\x12\n\x0e\n\x07\x04\0\x03\x02\x02\0\
    \x03\x12\x038\x15\x16\n=\n\x04\x04\0\x03\x03\x12\x04<\x02N\x03\x1a/\x20I\
    stio\x20service.\x20Learn\x20more\x20at\x20http://istio.io.\n\n\x0c\n\
    \x05\x04\0\x03\x03\x01\x12\x03<\n\x16\n\xab\x01\n\x06\x04\0\x03\x03\x02\
    \0\x12\x03@\x04\x18\x1a\x9b\x01\x20The\x20location\x20of\x20the\x20Kuber\
    netes\x20cluster\x20in\x20which\x20this\x20Istio\x20service\x20is\n\x20d\
    efined.\x20Corresponds\x20to\x20the\x20`location`\x20resource\x20label\
    \x20in\x20`k8s_cluster`\n\x20resources.\n\n\x0e\n\x07\x04\0\x03\x03\x02\
    \0\x05\x12\x03@\x04\n\n\x0e\n\x07\x04\0\x03\x03\x02\0\x01\x12\x03@\x0b\
    \x13\n\x0e\n\x07\x04\0\x03\x03\x02\0\x03\x12\x03@\x16\x17\n\xab\x01\n\
    \x06\x04\0\x03\x03\x02\x01\x12\x03E\x04\x1c\x1a\x9b\x01\x20The\x20name\
    \x20of\x20the\x20Kubernetes\x20cluster\x20in\x20which\x20this\x20Istio\
    \x20service\x20is\n\x20defined.\x20Corresponds\x20to\x20the\x20`cluster_\
    name`\x20resource\x20label\x20in\n\x20`k8s_cluster`\x20resources.\n\n\
    \x0e\n\x07\x04\0\x03\x03\x02\x01\x05\x12\x03E\x04\n\n\x0e\n\x07\x04\0\
    \x03\x03\x02\x01\x01\x12\x03E\x0b\x17\n\x0e\n\x07\x04\0\x03\x03\x02\x01\
    \x03\x12\x03E\x1a\x1b\n\xa0\x01\n\x06\x04\0\x03\x03\x02\x02\x12\x03I\x04\
    !\x1a\x90\x01\x20The\x20namespace\x20of\x20the\x20Istio\x20service\x20un\
    derlying\x20this\x20service.\x20Corresponds\n\x20to\x20the\x20`destinati\
    on_service_namespace`\x20metric\x20label\x20in\x20Istio\x20metrics.\n\n\
    \x0e\n\x07\x04\0\x03\x03\x02\x02\x05\x12\x03I\x04\n\n\x0e\n\x07\x04\0\
    \x03\x03\x02\x02\x01\x12\x03I\x0b\x1c\n\x0e\n\x07\x04\0\x03\x03\x02\x02\
    \x03\x12\x03I\x1f\x20\n\x96\x01\n\x06\x04\0\x03\x03\x02\x03\x12\x03M\x04\
    \x1c\x1a\x86\x01\x20The\x20name\x20of\x20the\x20Istio\x20service\x20unde\
    rlying\x20this\x20service.\x20Corresponds\x20to\x20the\n\x20`destination\
    _service_name`\x20metric\x20label\x20in\x20Istio\x20metrics.\n\n\x0e\n\
    \x07\x04\0\x03\x03\x02\x03\x05\x12\x03M\x04\n\n\x0e\n\x07\x04\0\x03\x03\
    \x02\x03\x01\x12\x03M\x0b\x17\n\x0e\n\x07\x04\0\x03\x03\x02\x03\x03\x12\
    \x03M\x1a\x1b\nF\n\x04\x04\0\x03\x04\x12\x04Q\x02U\x03\x1a8\x20Configura\
    tion\x20for\x20how\x20to\x20query\x20telemetry\x20on\x20a\x20Service.\n\
    \n\x0c\n\x05\x04\0\x03\x04\x01\x12\x03Q\n\x13\n\x9a\x01\n\x06\x04\0\x03\
    \x04\x02\0\x12\x03T\x04\x1d\x1a\x8a\x01\x20The\x20full\x20name\x20of\x20\
    the\x20resource\x20that\x20defines\x20this\x20service.\x20Formatted\x20a\
    s\n\x20described\x20in\x20https://cloud.google.com/apis/design/resource_\
    names.\n\n\x0e\n\x07\x04\0\x03\x04\x02\0\x05\x12\x03T\x04\n\n\x0e\n\x07\
    \x04\0\x03\x04\x02\0\x01\x12\x03T\x0b\x18\n\x0e\n\x07\x04\0\x03\x04\x02\
    \0\x03\x12\x03T\x1b\x1c\nj\n\x04\x04\0\x02\0\x12\x03Y\x02\x12\x1a]\x20Re\
    source\x20name\x20for\x20this\x20Service.\x20Of\x20the\x20form\n\x20`pro\
    jects/{project_id}/services/{service_id}`.\n\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03Y\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03Y\t\r\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03Y\x10\x11\n>\n\x04\x04\0\x02\x01\x12\x03\\\x02\
    \x1a\x1a1\x20Name\x20used\x20for\x20UI\x20elements\x20listing\x20this\
    \x20Service.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\\\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\\\t\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03\\\x18\x19\nV\n\x04\x04\0\x08\0\x12\x04_\x02k\x03\x1aH\x20REQUIRED.\
    \x20Service-identifying\x20atoms\x20specifying\x20the\x20underlying\x20s\
    ervice.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03_\x08\x12\n#\n\x04\x04\0\
    \x02\x02\x12\x03a\x04\x16\x1a\x16\x20Custom\x20service\x20type.\n\n\x0c\
    \n\x05\x04\0\x02\x02\x06\x12\x03a\x04\n\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03a\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03a\x14\x15\n1\n\
    \x04\x04\0\x02\x03\x12\x03d\x04\x1d\x1a$\x20Type\x20used\x20for\x20App\
    \x20Engine\x20services.\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03d\x04\r\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03d\x0e\x18\n\x0c\n\x05\x04\0\x02\x03\
    \x03\x12\x03d\x1b\x1c\n6\n\x04\x04\0\x02\x04\x12\x03g\x04'\x1a)\x20Type\
    \x20used\x20for\x20Cloud\x20Endpoints\x20services.\n\n\x0c\n\x05\x04\0\
    \x02\x04\x06\x12\x03g\x04\x12\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03g\x13\
    \"\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03g%&\nN\n\x04\x04\0\x02\x05\x12\
    \x03j\x04#\x1aA\x20Type\x20used\x20for\x20Istio\x20services\x20that\x20l\
    ive\x20in\x20a\x20Kubernetes\x20cluster.\n\n\x0c\n\x05\x04\0\x02\x05\x06\
    \x12\x03j\x04\x10\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03j\x11\x1e\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03j!\"\nE\n\x04\x04\0\x02\x06\x12\x03n\x02\
    \x1b\x1a8\x20Configuration\x20for\x20how\x20to\x20query\x20telemetry\x20\
    on\x20a\x20Service.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03n\x02\x0b\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03n\x0c\x15\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03n\x18\x1a\n\xd7\x03\n\x02\x04\x01\x12\x05w\0\xa7\x01\x01\x1a\
    \xc9\x03\x20A\x20Service-Level\x20Objective\x20(SLO)\x20describes\x20a\
    \x20level\x20of\x20desired\x20good\x20service.\x20It\n\x20consists\x20of\
    \x20a\x20service-level\x20indicator\x20(SLI),\x20a\x20performance\x20goa\
    l,\x20and\x20a\x20period\n\x20over\x20which\x20the\x20objective\x20is\
    \x20to\x20be\x20evaluated\x20against\x20that\x20goal.\x20The\x20SLO\x20c\
    an\n\x20use\x20SLIs\x20defined\x20in\x20a\x20number\x20of\x20different\
    \x20manners.\x20Typical\x20SLOs\x20might\x20include\n\x20\"99%\x20of\x20\
    requests\x20in\x20each\x20rolling\x20week\x20have\x20latency\x20below\
    \x20200\x20milliseconds\"\x20or\n\x20\"99.5%\x20of\x20requests\x20in\x20\
    each\x20calendar\x20month\x20return\x20successfully.\"\n\n\n\n\x03\x04\
    \x01\x01\x12\x03w\x08\x1d\n\xd9\x01\n\x04\x04\x01\x04\0\x12\x05{\x02\x89\
    \x01\x03\x1a\xc9\x01\x20`ServiceLevelObjective.View`\x20determines\x20wh\
    at\x20form\x20of\n\x20`ServiceLevelObjective`\x20is\x20returned\x20from\
    \x20`GetServiceLevelObjective`,\n\x20`ListServiceLevelObjectives`,\x20an\
    d\x20`ListServiceLevelObjectiveVersions`\x20RPCs.\n\n\x0c\n\x05\x04\x01\
    \x04\0\x01\x12\x03{\x07\x0b\n\x1e\n\x06\x04\x01\x04\0\x02\0\x12\x03}\x04\
    \x19\x1a\x0f\x20Same\x20as\x20FULL.\n\n\x0e\n\x07\x04\x01\x04\0\x02\0\
    \x01\x12\x03}\x04\x14\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03}\x17\
    \x18\n\xa2\x01\n\x06\x04\x01\x04\0\x02\x01\x12\x04\x81\x01\x04\r\x1a\x91\
    \x01\x20Return\x20the\x20embedded\x20`ServiceLevelIndicator`\x20in\x20th\
    e\x20form\x20in\x20which\x20it\x20was\n\x20defined.\x20If\x20it\x20was\
    \x20defined\x20using\x20a\x20`BasicSli`,\x20return\x20that\x20`BasicSli`\
    .\n\n\x0f\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x04\x81\x01\x04\x08\n\x0f\
    \n\x07\x04\x01\x04\0\x02\x01\x02\x12\x04\x81\x01\x0b\x0c\n\xc6\x02\n\x06\
    \x04\x01\x04\0\x02\x02\x12\x04\x88\x01\x04\x11\x1a\xb5\x02\x20For\x20`Se\
    rviceLevelIndicator`s\x20using\x20`BasicSli`\x20articulation,\x20instead\
    \n\x20return\x20the\x20`ServiceLevelIndicator`\x20with\x20its\x20mode\
    \x20of\x20computation\x20fully\n\x20spelled\x20out\x20as\x20a\x20`Reques\
    tBasedSli`.\x20For\x20`ServiceLevelIndicator`s\x20using\n\x20`RequestBas\
    edSli`\x20or\x20`WindowsBasedSli`,\x20return\x20the\n\x20`ServiceLevelIn\
    dicator`\x20as\x20it\x20was\x20provided.\n\n\x0f\n\x07\x04\x01\x04\0\x02\
    \x02\x01\x12\x04\x88\x01\x04\x0c\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x02\
    \x12\x04\x88\x01\x0f\x10\n\x9f\x01\n\x04\x04\x01\x02\0\x12\x04\x8e\x01\
    \x02\x12\x1a\x90\x01\x20Resource\x20name\x20for\x20this\x20`ServiceLevel\
    Objective`.\n\x20Of\x20the\x20form\n\x20`projects/{project_id}/services/\
    {service_id}/serviceLevelObjectives/{slo_name}`.\n\n\r\n\x05\x04\x01\x02\
    \0\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x8e\
    \x01\t\r\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x8e\x01\x10\x11\n;\n\x04\
    \x04\x01\x02\x01\x12\x04\x91\x01\x02\x1b\x1a-\x20Name\x20used\x20for\x20\
    UI\x20elements\x20listing\x20this\x20SLO.\n\n\r\n\x05\x04\x01\x02\x01\
    \x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x91\
    \x01\t\x15\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x91\x01\x18\x1a\n\xaf\
    \x01\n\x04\x04\x01\x02\x02\x12\x04\x96\x01\x024\x1a\xa0\x01\x20The\x20de\
    finition\x20of\x20good\x20service,\x20used\x20to\x20measure\x20and\x20ca\
    lculate\x20the\x20quality\n\x20of\x20the\x20`Service`'s\x20performance\
    \x20with\x20respect\x20to\x20a\x20single\x20aspect\x20of\x20service\n\
    \x20quality.\n\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\x96\x01\x02\x17\n\r\
    \n\x05\x04\x01\x02\x02\x01\x12\x04\x96\x01\x18/\n\r\n\x05\x04\x01\x02\
    \x02\x03\x12\x04\x96\x0123\nr\n\x04\x04\x01\x02\x03\x12\x04\x9a\x01\x02\
    \x12\x1ad\x20The\x20fraction\x20of\x20service\x20that\x20must\x20be\x20g\
    ood\x20in\x20order\x20for\x20this\x20objective\x20to\x20be\n\x20met.\x20\
    `0\x20<\x20goal\x20<=\x201`.\n\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\x9a\
    \x01\x02\x08\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\x9a\x01\t\r\n\r\n\x05\
    \x04\x01\x02\x03\x03\x12\x04\x9a\x01\x10\x11\nM\n\x04\x04\x01\x08\0\x12\
    \x06\x9d\x01\x02\xa6\x01\x03\x1a=\x20The\x20time\x20period\x20over\x20wh\
    ich\x20the\x20objective\x20will\x20be\x20evaluated.\n\n\r\n\x05\x04\x01\
    \x08\0\x01\x12\x04\x9d\x01\x08\x0e\n\x94\x01\n\x04\x04\x01\x02\x04\x12\
    \x04\xa0\x01\x040\x1a\x85\x01\x20A\x20rolling\x20time\x20period,\x20sema\
    ntically\x20\"in\x20the\x20past\x20`<rolling_period>`\".\n\x20Must\x20be\
    \x20an\x20integer\x20multiple\x20of\x201\x20day\x20no\x20larger\x20than\
    \x2030\x20days.\n\n\r\n\x05\x04\x01\x02\x04\x06\x12\x04\xa0\x01\x04\x1c\
    \n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xa0\x01\x1d+\n\r\n\x05\x04\x01\
    \x02\x04\x03\x12\x04\xa0\x01./\n\xb2\x01\n\x04\x04\x01\x02\x05\x12\x04\
    \xa5\x01\x043\x1a\xa3\x01\x20A\x20calendar\x20period,\x20semantically\
    \x20\"since\x20the\x20start\x20of\x20the\x20current\n\x20`<calendar_peri\
    od>`\".\x20At\x20this\x20time,\x20only\x20`DAY`,\x20`WEEK`,\x20`FORTNIGH\
    T`,\x20and\n\x20`MONTH`\x20are\x20supported.\n\n\r\n\x05\x04\x01\x02\x05\
    \x06\x12\x04\xa5\x01\x04\x1e\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\xa5\
    \x01\x1f.\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\xa5\x0112\n\xad\x07\n\
    \x02\x04\x02\x12\x06\xb6\x01\0\xc4\x01\x01\x1a\x9e\x07\x20A\x20Service-L\
    evel\x20Indicator\x20(SLI)\x20describes\x20the\x20\"performance\"\x20of\
    \x20a\x20service.\x20For\n\x20some\x20services,\x20the\x20SLI\x20is\x20w\
    ell-defined.\x20In\x20such\x20cases,\x20the\x20SLI\x20can\x20be\n\x20des\
    cribed\x20easily\x20by\x20referencing\x20the\x20well-known\x20SLI\x20and\
    \x20providing\x20the\x20needed\n\x20parameters.\x20Alternatively,\x20a\
    \x20\"custom\"\x20SLI\x20can\x20be\x20defined\x20with\x20a\x20query\x20t\
    o\x20the\n\x20underlying\x20metric\x20store.\x20An\x20SLI\x20is\x20defin\
    ed\x20to\x20be\x20`good_service\x20/\n\x20total_service`\x20over\x20any\
    \x20queried\x20time\x20interval.\x20The\x20value\x20of\x20performance\n\
    \x20always\x20falls\x20into\x20the\x20range\x20`0\x20<=\x20performance\
    \x20<=\x201`.\x20A\x20custom\x20SLI\x20describes\n\x20how\x20to\x20compu\
    te\x20this\x20ratio,\x20whether\x20this\x20is\x20by\x20dividing\x20value\
    s\x20from\x20a\x20pair\x20of\n\x20time\x20series,\x20cutting\x20a\x20`Di\
    stribution`\x20into\x20good\x20and\x20bad\x20counts,\x20or\x20counting\n\
    \x20time\x20windows\x20in\x20which\x20the\x20service\x20complies\x20with\
    \x20a\x20criterion.\x20For\x20separation\n\x20of\x20concerns,\x20a\x20si\
    ngle\x20Service-Level\x20Indicator\x20measures\x20performance\x20for\x20\
    only\n\x20one\x20aspect\x20of\x20service\x20quality,\x20such\x20as\x20fr\
    action\x20of\x20successful\x20queries\x20or\n\x20fast-enough\x20queries.\
    \n\n\x0b\n\x03\x04\x02\x01\x12\x04\xb6\x01\x08\x1d\n\xb2\x01\n\x04\x04\
    \x02\x08\0\x12\x06\xba\x01\x02\xc3\x01\x03\x1a\xa1\x01\x20Service\x20lev\
    el\x20indicators\x20can\x20be\x20grouped\x20by\x20whether\x20the\x20\"un\
    it\"\x20of\x20service\n\x20being\x20measured\x20is\x20based\x20on\x20cou\
    nts\x20of\x20good\x20requests\x20or\x20on\x20counts\x20of\x20good\n\x20t\
    ime\x20windows\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\xba\x01\x08\x0c\n7\
    \n\x04\x04\x02\x02\0\x12\x04\xbc\x01\x04\x1b\x1a)\x20Basic\x20SLI\x20on\
    \x20a\x20well-known\x20service\x20type.\n\n\r\n\x05\x04\x02\x02\0\x06\
    \x12\x04\xbc\x01\x04\x0c\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xbc\x01\r\
    \x16\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xbc\x01\x19\x1a\n\"\n\x04\x04\
    \x02\x02\x01\x12\x04\xbf\x01\x04&\x1a\x14\x20Request-based\x20SLIs\n\n\r\
    \n\x05\x04\x02\x02\x01\x06\x12\x04\xbf\x01\x04\x13\n\r\n\x05\x04\x02\x02\
    \x01\x01\x12\x04\xbf\x01\x14!\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xbf\
    \x01$%\n\"\n\x04\x04\x02\x02\x02\x12\x04\xc2\x01\x04&\x1a\x14\x20Windows\
    -based\x20SLIs\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xc2\x01\x04\x13\n\
    \r\n\x05\x04\x02\x02\x02\x01\x12\x04\xc2\x01\x14!\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xc2\x01$%\n\xf9\x02\n\x02\x04\x03\x12\x06\xcc\x01\0\xf8\
    \x01\x01\x1a\xea\x02\x20An\x20SLI\x20measuring\x20performance\x20on\x20a\
    \x20well-known\x20service\x20type.\x20Performance\x20will\n\x20be\x20com\
    puted\x20on\x20the\x20basis\x20of\x20pre-defined\x20metrics.\x20The\x20t\
    ype\x20of\x20the\n\x20`service_resource`\x20determines\x20the\x20metrics\
    \x20to\x20use\x20and\x20the\n\x20`service_resource.labels`\x20and\x20`me\
    tric_labels`\x20are\x20used\x20to\x20construct\x20a\n\x20monitoring\x20f\
    ilter\x20to\x20filter\x20that\x20metric\x20down\x20to\x20just\x20the\x20\
    data\x20relevant\x20to\n\x20this\x20service.\n\n\x0b\n\x03\x04\x03\x01\
    \x12\x04\xcc\x01\x08\x10\n=\n\x04\x04\x03\x03\0\x12\x06\xce\x01\x02\xd0\
    \x01\x03\x1a-\x20Future\x20parameters\x20for\x20the\x20availability\x20S\
    LI.\n\n\r\n\x05\x04\x03\x03\0\x01\x12\x04\xce\x01\n\x1e\n9\n\x04\x04\x03\
    \x03\x01\x12\x06\xd3\x01\x02\xd7\x01\x03\x1a)\x20Parameters\x20for\x20a\
    \x20latency\x20threshold\x20SLI.\n\n\r\n\x05\x04\x03\x03\x01\x01\x12\x04\
    \xd3\x01\n\x19\n\x84\x01\n\x06\x04\x03\x03\x01\x02\0\x12\x04\xd6\x01\x04\
    +\x1at\x20Good\x20service\x20is\x20defined\x20to\x20be\x20the\x20count\
    \x20of\x20requests\x20made\x20to\x20this\x20service\n\x20that\x20return\
    \x20in\x20no\x20more\x20than\x20`threshold`.\n\n\x0f\n\x07\x04\x03\x03\
    \x01\x02\0\x06\x12\x04\xd6\x01\x04\x1c\n\x0f\n\x07\x04\x03\x03\x01\x02\0\
    \x01\x12\x04\xd6\x01\x1d&\n\x0f\n\x07\x04\x03\x03\x01\x02\0\x03\x12\x04\
    \xd6\x01)*\n\xc7\x02\n\x04\x04\x03\x02\0\x12\x04\xde\x01\x02\x1d\x1a\xb8\
    \x02\x20OPTIONAL:\x20The\x20set\x20of\x20RPCs\x20to\x20which\x20this\x20\
    SLI\x20is\x20relevant.\x20Telemetry\x20from\n\x20other\x20methods\x20wil\
    l\x20not\x20be\x20used\x20to\x20calculate\x20performance\x20for\x20this\
    \x20SLI.\x20If\n\x20omitted,\x20this\x20SLI\x20applies\x20to\x20all\x20t\
    he\x20Service's\x20methods.\x20For\x20service\x20types\n\x20that\x20don'\
    t\x20support\x20breaking\x20down\x20by\x20method,\x20setting\x20this\x20\
    field\x20will\x20result\n\x20in\x20an\x20error.\n\n\r\n\x05\x04\x03\x02\
    \0\x04\x12\x04\xde\x01\x02\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xde\x01\
    \x0b\x11\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xde\x01\x12\x18\n\r\n\x05\
    \x04\x03\x02\0\x03\x12\x04\xde\x01\x1b\x1c\n\xe6\x02\n\x04\x04\x03\x02\
    \x01\x12\x04\xe5\x01\x02\x1f\x1a\xd7\x02\x20OPTIONAL:\x20The\x20set\x20o\
    f\x20locations\x20to\x20which\x20this\x20SLI\x20is\x20relevant.\x20Telem\
    etry\n\x20from\x20other\x20locations\x20will\x20not\x20be\x20used\x20to\
    \x20calculate\x20performance\x20for\x20this\n\x20SLI.\x20If\x20omitted,\
    \x20this\x20SLI\x20applies\x20to\x20all\x20locations\x20in\x20which\x20t\
    he\x20Service\x20has\n\x20activity.\x20For\x20service\x20types\x20that\
    \x20don't\x20support\x20breaking\x20down\x20by\x20location,\n\x20setting\
    \x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\n\r\n\x05\
    \x04\x03\x02\x01\x04\x12\x04\xe5\x01\x02\n\n\r\n\x05\x04\x03\x02\x01\x05\
    \x12\x04\xe5\x01\x0b\x11\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xe5\x01\
    \x12\x1a\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xe5\x01\x1d\x1e\n\xcc\x02\
    \n\x04\x04\x03\x02\x02\x12\x04\xec\x01\x02\x1e\x1a\xbd\x02\x20OPTIONAL:\
    \x20The\x20set\x20of\x20API\x20versions\x20to\x20which\x20this\x20SLI\
    \x20is\x20relevant.\x20Telemetry\n\x20from\x20other\x20API\x20versions\
    \x20will\x20not\x20be\x20used\x20to\x20calculate\x20performance\x20for\
    \x20this\n\x20SLI.\x20If\x20omitted,\x20this\x20SLI\x20applies\x20to\x20\
    all\x20API\x20versions.\x20For\x20service\x20types\n\x20that\x20don't\
    \x20support\x20breaking\x20down\x20by\x20version,\x20setting\x20this\x20\
    field\x20will\x20result\n\x20in\x20an\x20error.\n\n\r\n\x05\x04\x03\x02\
    \x02\x04\x12\x04\xec\x01\x02\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xec\
    \x01\x0b\x11\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xec\x01\x12\x19\n\r\n\
    \x05\x04\x03\x02\x02\x03\x12\x04\xec\x01\x1c\x1d\nT\n\x04\x04\x03\x08\0\
    \x12\x06\xef\x01\x02\xf7\x01\x03\x1aD\x20This\x20SLI\x20can\x20be\x20eva\
    luated\x20on\x20the\x20basis\x20of\x20availability\x20or\x20latency.\n\n\
    \r\n\x05\x04\x03\x08\0\x01\x12\x04\xef\x01\x08\x14\ns\n\x04\x04\x03\x02\
    \x03\x12\x04\xf2\x01\x04*\x1ae\x20Good\x20service\x20is\x20defined\x20to\
    \x20be\x20the\x20count\x20of\x20requests\x20made\x20to\x20this\x20servic\
    e\n\x20that\x20return\x20successfully.\n\n\r\n\x05\x04\x03\x02\x03\x06\
    \x12\x04\xf2\x01\x04\x18\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xf2\x01\
    \x19%\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xf2\x01()\n\x94\x01\n\x04\
    \x04\x03\x02\x04\x12\x04\xf6\x01\x04\x20\x1a\x85\x01\x20Good\x20service\
    \x20is\x20defined\x20to\x20be\x20the\x20count\x20of\x20requests\x20made\
    \x20to\x20this\x20service\n\x20that\x20are\x20fast\x20enough\x20with\x20\
    respect\x20to\x20`latency.threshold`.\n\n\r\n\x05\x04\x03\x02\x04\x06\
    \x12\x04\xf6\x01\x04\x13\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xf6\x01\
    \x14\x1b\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xf6\x01\x1e\x1f\n\xea\x01\
    \n\x02\x04\x04\x12\x06\xfd\x01\0\x83\x02\x01\x1a\xdb\x01\x20Range\x20of\
    \x20numerical\x20values,\x20inclusive\x20of\x20`min`\x20and\x20exclusive\
    \x20of\x20`max`.\x20If\x20the\n\x20open\x20range\x20\"<\x20range.max\"\
    \x20is\x20desired,\x20set\x20`range.min\x20=\x20-infinity`.\x20If\x20the\
    \x20open\n\x20range\x20\">=\x20range.min\"\x20is\x20desired,\x20set\x20`\
    range.max\x20=\x20infinity`.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xfd\x01\
    \x08\r\n\x1e\n\x04\x04\x04\x02\0\x12\x04\xff\x01\x02\x11\x1a\x10\x20Rang\
    e\x20minimum.\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xff\x01\x02\x08\n\r\
    \n\x05\x04\x04\x02\0\x01\x12\x04\xff\x01\t\x0c\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\xff\x01\x0f\x10\n\x1e\n\x04\x04\x04\x02\x01\x12\x04\x82\x02\
    \x02\x11\x1a\x10\x20Range\x20maximum.\n\n\r\n\x05\x04\x04\x02\x01\x05\
    \x12\x04\x82\x02\x02\x08\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x82\x02\t\
    \x0c\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x82\x02\x0f\x10\na\n\x02\x04\
    \x05\x12\x06\x87\x02\0\x94\x02\x01\x1aS\x20Service\x20Level\x20Indicator\
    s\x20for\x20which\x20atomic\x20units\x20of\x20service\x20are\x20counted\
    \n\x20directly.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x87\x02\x08\x17\nT\n\
    \x04\x04\x05\x08\0\x12\x06\x89\x02\x02\x93\x02\x03\x1aD\x20The\x20means\
    \x20to\x20compute\x20a\x20ratio\x20of\x20`good_service`\x20to\x20`total_\
    service`.\n\n\r\n\x05\x04\x05\x08\0\x01\x12\x04\x89\x02\x08\x0e\n\x82\
    \x01\n\x04\x04\x05\x02\0\x12\x04\x8c\x02\x04)\x1at\x20`good_total_ratio`\
    \x20is\x20used\x20when\x20the\x20ratio\x20of\x20`good_service`\x20to\n\
    \x20`total_service`\x20is\x20computed\x20from\x20two\x20`TimeSeries`.\n\
    \n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x8c\x02\x04\x13\n\r\n\x05\x04\x05\
    \x02\0\x01\x12\x04\x8c\x02\x14$\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x8c\
    \x02'(\n\xea\x01\n\x04\x04\x05\x02\x01\x12\x04\x92\x02\x04)\x1a\xdb\x01\
    \x20`distribution_cut`\x20is\x20used\x20when\x20`good_service`\x20is\x20\
    a\x20count\x20of\x20values\n\x20aggregated\x20in\x20a\x20`Distribution`\
    \x20that\x20fall\x20into\x20a\x20good\x20range.\x20The\n\x20`total_servi\
    ce`\x20is\x20the\x20total\x20count\x20of\x20all\x20values\x20aggregated\
    \x20in\x20the\n\x20`Distribution`.\n\n\r\n\x05\x04\x05\x02\x01\x06\x12\
    \x04\x92\x02\x04\x13\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x92\x02\x14$\
    \n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x92\x02'(\n\xb0\x03\n\x02\x04\x06\
    \x12\x06\x9c\x02\0\xaf\x02\x01\x1a\xa1\x03\x20A\x20`TimeSeriesRatio`\x20\
    specifies\x20two\x20`TimeSeries`\x20to\x20use\x20for\x20computing\x20the\
    \n\x20`good_service\x20/\x20total_service`\x20ratio.\x20The\x20specified\
    \x20`TimeSeries`\x20must\x20have\n\x20`ValueType\x20=\x20DOUBLE`\x20or\
    \x20`ValueType\x20=\x20INT64`\x20and\x20must\x20have\x20`MetricKind\x20=\
    \n\x20DELTA`\x20or\x20`MetricKind\x20=\x20CUMULATIVE`.\x20The\x20`TimeSe\
    riesRatio`\x20must\x20specify\n\x20exactly\x20two\x20of\x20good,\x20bad,\
    \x20and\x20total,\x20and\x20the\x20relationship\x20`good_service\x20+\n\
    \x20bad_service\x20=\x20total_service`\x20will\x20be\x20assumed.\n\n\x0b\
    \n\x03\x04\x06\x01\x12\x04\x9c\x02\x08\x17\n\x91\x02\n\x04\x04\x06\x02\0\
    \x12\x04\xa1\x02\x02!\x1a\x82\x02\x20A\x20[monitoring\x20filter](https:/\
    /cloud.google.com/monitoring/api/v3/filters)\n\x20specifying\x20a\x20`Ti\
    meSeries`\x20quantifying\x20good\x20service\x20provided.\x20Must\x20have\
    \n\x20`ValueType\x20=\x20DOUBLE`\x20or\x20`ValueType\x20=\x20INT64`\x20a\
    nd\x20must\x20have\x20`MetricKind\x20=\n\x20DELTA`\x20or\x20`MetricKind\
    \x20=\x20CUMULATIVE`.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa1\x02\x02\
    \x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa1\x02\t\x1c\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\xa1\x02\x1f\x20\n\xea\x02\n\x04\x04\x06\x02\x01\x12\
    \x04\xa8\x02\x02\x20\x1a\xdb\x02\x20A\x20[monitoring\x20filter](https://\
    cloud.google.com/monitoring/api/v3/filters)\n\x20specifying\x20a\x20`Tim\
    eSeries`\x20quantifying\x20bad\x20service,\x20either\x20demanded\x20serv\
    ice\n\x20that\x20was\x20not\x20provided\x20or\x20demanded\x20service\x20\
    that\x20was\x20of\x20inadequate\x20quality.\n\x20Must\x20have\x20`ValueT\
    ype\x20=\x20DOUBLE`\x20or\x20`ValueType\x20=\x20INT64`\x20and\x20must\
    \x20have\n\x20`MetricKind\x20=\x20DELTA`\x20or\x20`MetricKind\x20=\x20CU\
    MULATIVE`.\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xa8\x02\x02\x08\n\r\n\
    \x05\x04\x06\x02\x01\x01\x12\x04\xa8\x02\t\x1b\n\r\n\x05\x04\x06\x02\x01\
    \x03\x12\x04\xa8\x02\x1e\x1f\n\x92\x02\n\x04\x04\x06\x02\x02\x12\x04\xae\
    \x02\x02\"\x1a\x83\x02\x20A\x20[monitoring\x20filter](https://cloud.goog\
    le.com/monitoring/api/v3/filters)\n\x20specifying\x20a\x20`TimeSeries`\
    \x20quantifying\x20total\x20demanded\x20service.\x20Must\x20have\n\x20`V\
    alueType\x20=\x20DOUBLE`\x20or\x20`ValueType\x20=\x20INT64`\x20and\x20mu\
    st\x20have\x20`MetricKind\x20=\n\x20DELTA`\x20or\x20`MetricKind\x20=\x20\
    CUMULATIVE`.\n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xae\x02\x02\x08\n\r\
    \n\x05\x04\x06\x02\x02\x01\x12\x04\xae\x02\t\x1d\n\r\n\x05\x04\x06\x02\
    \x02\x03\x12\x04\xae\x02\x20!\n\xe6\x02\n\x02\x04\x07\x12\x06\xb6\x02\0\
    \xbf\x02\x01\x1a\xd7\x02\x20A\x20`DistributionCut`\x20defines\x20a\x20`T\
    imeSeries`\x20and\x20thresholds\x20used\x20for\x20measuring\n\x20good\
    \x20service\x20and\x20total\x20service.\x20The\x20`TimeSeries`\x20must\
    \x20have\x20`ValueType\x20=\n\x20DISTRIBUTION`\x20and\x20`MetricKind\x20\
    =\x20DELTA`\x20or\x20`MetricKind\x20=\x20CUMULATIVE`.\x20The\n\x20comput\
    ed\x20`good_service`\x20will\x20be\x20the\x20count\x20of\x20values\x20x\
    \x20in\x20the\x20`Distribution`\n\x20such\x20that\x20`range.min\x20<=\
    \x20x\x20<\x20range.max`.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xb6\x02\x08\
    \x17\n\xe6\x01\n\x04\x04\x07\x02\0\x12\x04\xba\x02\x02!\x1a\xd7\x01\x20A\
    \x20[monitoring\x20filter](https://cloud.google.com/monitoring/api/v3/fi\
    lters)\n\x20specifying\x20a\x20`TimeSeries`\x20aggregating\x20values.\
    \x20Must\x20have\x20`ValueType\x20=\n\x20DISTRIBUTION`\x20and\x20`Metric\
    Kind\x20=\x20DELTA`\x20or\x20`MetricKind\x20=\x20CUMULATIVE`.\n\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\xba\x02\x02\x08\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xba\x02\t\x1c\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xba\x02\
    \x1f\x20\nn\n\x04\x04\x07\x02\x01\x12\x04\xbe\x02\x02\x12\x1a`\x20Range\
    \x20of\x20values\x20considered\x20\"good.\"\x20For\x20a\x20one-sided\x20\
    range,\x20set\x20one\x20bound\x20to\n\x20an\x20infinite\x20value.\n\n\r\
    \n\x05\x04\x07\x02\x01\x06\x12\x04\xbe\x02\x02\x07\n\r\n\x05\x04\x07\x02\
    \x01\x01\x12\x04\xbe\x02\x08\r\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xbe\
    \x02\x10\x11\n\xe3\x01\n\x02\x04\x08\x12\x06\xc4\x02\0\xfa\x02\x01\x1a\
    \xd4\x01\x20A\x20`WindowsBasedSli`\x20defines\x20`good_service`\x20as\
    \x20the\x20count\x20of\x20time\x20windows\x20for\n\x20which\x20the\x20pr\
    ovided\x20service\x20was\x20of\x20good\x20quality.\x20Criteria\x20for\
    \x20determining\n\x20if\x20service\x20was\x20good\x20are\x20embedded\x20\
    in\x20the\x20`window_criterion`.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc4\
    \x02\x08\x17\n\x84\x01\n\x04\x04\x08\x03\0\x12\x06\xc7\x02\x02\xd4\x02\
    \x03\x1at\x20A\x20`PerformanceThreshold`\x20is\x20used\x20when\x20each\
    \x20window\x20is\x20good\x20when\x20that\x20window\n\x20has\x20a\x20suff\
    iciently\x20high\x20`performance`.\n\n\r\n\x05\x04\x08\x03\0\x01\x12\x04\
    \xc7\x02\n\x1e\ny\n\x06\x04\x08\x03\0\x08\0\x12\x06\xca\x02\x04\xd0\x02\
    \x05\x1ag\x20The\x20means,\x20either\x20a\x20request-based\x20SLI\x20or\
    \x20a\x20basic\x20SLI,\x20by\x20which\x20to\x20compute\n\x20performance\
    \x20over\x20a\x20window.\n\n\x0f\n\x07\x04\x08\x03\0\x08\0\x01\x12\x04\
    \xca\x02\n\x0e\nH\n\x06\x04\x08\x03\0\x02\0\x12\x04\xcc\x02\x06&\x1a8\
    \x20`RequestBasedSli`\x20to\x20evaluate\x20to\x20judge\x20window\x20qual\
    ity.\n\n\x0f\n\x07\x04\x08\x03\0\x02\0\x06\x12\x04\xcc\x02\x06\x15\n\x0f\
    \n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\xcc\x02\x16!\n\x0f\n\x07\x04\x08\
    \x03\0\x02\0\x03\x12\x04\xcc\x02$%\nA\n\x06\x04\x08\x03\0\x02\x01\x12\
    \x04\xcf\x02\x06)\x1a1\x20`BasicSli`\x20to\x20evaluate\x20to\x20judge\
    \x20window\x20quality.\n\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x06\x12\x04\
    \xcf\x02\x06\x0e\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x01\x12\x04\xcf\x02\
    \x0f$\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\xcf\x02'(\nV\n\x06\
    \x04\x08\x03\0\x02\x02\x12\x04\xd3\x02\x04\x19\x1aF\x20If\x20window\x20`\
    performance\x20>=\x20threshold`,\x20the\x20window\x20is\x20counted\x20as\
    \x20good.\n\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x05\x12\x04\xd3\x02\x04\n\
    \n\x0f\n\x07\x04\x08\x03\0\x02\x02\x01\x12\x04\xd3\x02\x0b\x14\n\x0f\n\
    \x07\x04\x08\x03\0\x02\x02\x03\x12\x04\xd3\x02\x17\x18\n\x82\x02\n\x04\
    \x04\x08\x03\x01\x12\x06\xda\x02\x02\xe2\x02\x03\x1a\xf1\x01\x20A\x20`Me\
    tricRange`\x20is\x20used\x20when\x20each\x20window\x20is\x20good\x20when\
    \x20the\x20value\x20x\x20of\x20a\n\x20single\x20`TimeSeries`\x20satisfie\
    s\x20`range.min\x20<=\x20x\x20<\x20range.max`.\x20The\x20provided\n\x20`\
    TimeSeries`\x20must\x20have\x20`ValueType\x20=\x20INT64`\x20or\x20`Value\
    Type\x20=\x20DOUBLE`\x20and\n\x20`MetricKind\x20=\x20GAUGE`.\n\n\r\n\x05\
    \x04\x08\x03\x01\x01\x12\x04\xda\x02\n\x15\n\x9f\x01\n\x06\x04\x08\x03\
    \x01\x02\0\x12\x04\xdd\x02\x04\x1b\x1a\x8e\x01\x20A\x20[monitoring\x20fi\
    lter](https://cloud.google.com/monitoring/api/v3/filters)\n\x20specifyin\
    g\x20the\x20`TimeSeries`\x20to\x20use\x20for\x20evaluating\x20window\x20\
    quality.\n\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x05\x12\x04\xdd\x02\x04\n\n\
    \x0f\n\x07\x04\x08\x03\x01\x02\0\x01\x12\x04\xdd\x02\x0b\x16\n\x0f\n\x07\
    \x04\x08\x03\x01\x02\0\x03\x12\x04\xdd\x02\x19\x1a\np\n\x06\x04\x08\x03\
    \x01\x02\x01\x12\x04\xe1\x02\x04\x14\x1a`\x20Range\x20of\x20values\x20co\
    nsidered\x20\"good.\"\x20For\x20a\x20one-sided\x20range,\x20set\x20one\
    \x20bound\n\x20to\x20an\x20infinite\x20value.\n\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x01\x06\x12\x04\xe1\x02\x04\t\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x01\x01\x12\x04\xe1\x02\n\x0f\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\x03\
    \x12\x04\xe1\x02\x12\x13\nF\n\x04\x04\x08\x08\0\x12\x06\xe5\x02\x02\xf5\
    \x02\x03\x1a6\x20The\x20criterion\x20to\x20use\x20for\x20evaluating\x20w\
    indow\x20goodness.\n\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\xe5\x02\x08\x18\
    \n\xcd\x01\n\x04\x04\x08\x02\0\x12\x04\xe9\x02\x04&\x1a\xbe\x01\x20A\x20\
    [monitoring\x20filter](https://cloud.google.com/monitoring/api/v3/filter\
    s)\n\x20specifying\x20a\x20`TimeSeries`\x20with\x20`ValueType\x20=\x20BO\
    OL`.\x20The\x20window\x20is\x20good\x20if\n\x20any\x20`true`\x20values\
    \x20appear\x20in\x20the\x20window.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\
    \xe9\x02\x04\n\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xe9\x02\x0b!\n\r\n\
    \x05\x04\x08\x02\0\x03\x12\x04\xe9\x02$%\nE\n\x04\x04\x08\x02\x01\x12\
    \x04\xec\x02\x048\x1a7\x20A\x20window\x20is\x20good\x20if\x20its\x20`per\
    formance`\x20is\x20high\x20enough.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\
    \x04\xec\x02\x04\x18\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xec\x02\x193\
    \n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xec\x0267\nm\n\x04\x04\x08\x02\
    \x02\x12\x04\xf0\x02\x04)\x1a_\x20A\x20window\x20is\x20good\x20if\x20the\
    \x20metric's\x20value\x20is\x20in\x20a\x20good\x20range,\x20averaged\n\
    \x20across\x20returned\x20streams.\n\n\r\n\x05\x04\x08\x02\x02\x06\x12\
    \x04\xf0\x02\x04\x0f\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xf0\x02\x10$\
    \n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xf0\x02'(\nk\n\x04\x04\x08\x02\
    \x03\x12\x04\xf4\x02\x04(\x1a]\x20A\x20window\x20is\x20good\x20if\x20the\
    \x20metric's\x20value\x20is\x20in\x20a\x20good\x20range,\x20summed\x20ac\
    ross\n\x20returned\x20streams.\n\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\
    \xf4\x02\x04\x0f\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xf4\x02\x10#\n\r\
    \n\x05\x04\x08\x02\x03\x03\x12\x04\xf4\x02&'\nz\n\x04\x04\x08\x02\x04\
    \x12\x04\xf9\x02\x02-\x1al\x20Duration\x20over\x20which\x20window\x20qua\
    lity\x20is\x20evaluated.\x20Must\x20be\x20an\x20integer\n\x20fraction\
    \x20of\x20a\x20day\x20and\x20at\x20least\x20`60s`.\n\n\r\n\x05\x04\x08\
    \x02\x04\x06\x12\x04\xf9\x02\x02\x1a\n\r\n\x05\x04\x08\x02\x04\x01\x12\
    \x04\xf9\x02\x1b(\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xf9\x02+,b\x06pr\
    oto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
